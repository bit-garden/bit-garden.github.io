<html>
<title>Testing board</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser.html import *
# storage is like dictionary
#from browser.local_storage import storage

async def ui():
  window.snacks.append('Hello world')



  
  
# ready the aio tasks
async def main():
  await aio.gather(snackbar(), ui(), keybind())
  

  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

  
# --- other UI stuff

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple(*_):
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s', 'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple(*_):
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple(*_):
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple(*_):
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)

def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

def SWITCH(text:str , state: bool = False, Type: str = 'checkbox', Class: str = 'switch', name: str = '') -> LABEL:
  return LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'})
  )
  
async def popup(content):
  frame = DIV(Class='darken', style={
    'background': 'rgba(0, 0, 0, 0)',
    'transition': 'background .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    'width': '100%',
    'height': '100%',
    'position': 'fixed',
    'top': '0px',
    'left': '0px',
    'z-index': '1'
  })

  box = DIV(content, Class='card', style={
    'position': 'absolute',
    'left': '12.5%',
    'top': '25%',
    'opacity': 0,
    'width': '75%',
    'height': '75%',
    'margin': '-16px',
    'transition': 'opacity .4s, top .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  })

  frame <= box

  doc <= frame

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.style['top'] = '12.5%'

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.style['top'] = '25%'
  await aio.sleep(.4)

  frame.remove()
  
async def snack(content, delay=5):
  # make element
  _snack = DIV(content, Class='card',
                style={
                  'position': 'fixed',
                  'z-index': '2',
                  'bottom': '-16px',
                  'left': '50%',
                  'transform': 'translate(-50%, 100%)',
                  'transition': 'transform .4s, bottom .4s',
                  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
                })
  # attach to doc
  doc <= _snack
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = '16px'
  _snack.style['transform'] = 'translate(-50%, 0%)'
  # sleep for 5
  await aio.sleep(.4+delay)
  # update pos
  _snack.style['bottom'] = '-16px'
  _snack.style['transform'] = 'translate(-50%, 100%)'
  await aio.sleep(.4)
  _snack.remove()
  # return

async def snackbar():
  window.snacks = []
  while True:
    while window.snacks:
      val = window.snacks.pop(0)
      await snack(val)
      
    await aio.sleep(0)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        if ev.key == 'Escape':
          tar = doc.querySelectorAll('.darken')
          if len(tar):
            aio.cancel_event(tar[-1])

    ev = await aio.select_event(doc, 'keyup keydown')
  
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass


def enforce(f):
  annos = f.__annotations__
  del annos['return']

  vars = f.__code__.co_varnames

  defs = f.__defaults__ or []
  offset = len(vars) - f.__code__.co_argcount

  #print(defs)
  defs = [v for v in vars[-(len(defs)+offset): -offset]]

  def new_f(*args, **kwds):
    _args = {vars[i]: v for i, v in enumerate(args)}
    _args.update(**kwds)
    for k, v in annos.items():
      if k in _args:
        if not isinstance(_args[k], v):
          raise TypeError(f"Expected type {v} but {k} was given type {type(_args[k])}.")

    return f(*args, **kwds)
  new_f.__name__ = f.__name__
  return new_f

def enforce_class(f):
  annos = f.__annotations__
  #del annos['return']

  vars = list(annos.keys())

  defs = [f.__dict__[i] for i in annos if i in f.__dict__]

  #print(defs)
  defs = [v for v in vars[-len(defs):]]

  def new_f(self, *args, **kwds):
    _args = {vars[i]: v for i, v in enumerate(args)}
    _args.update(**kwds)
    for k, v in annos.items():
      if k in _args:
        if v is not any and not isinstance(_args[k], v):
          raise TypeError(f"Expected type {v} but {k} was given type {type(_args[k])}.")
      elif k not in f.__dict__:
        raise ValueError(f"Parameter {k} missing.")
      else:
        if type(f.__dict__[k]) is bound:
          _args[k] = f.__dict__[k].default
        else:
          _args[k] = f.__dict__[k]
    for k, v in _args.items():
      if k not in annos:
        raise ValueError(f"{k} is not a valid parameter.")
    
    self.__dict__.update(**_args)

    pi = getattr(self, '__post_init__', None)
    if pi:
      pi()
  f.__init__ = new_f
  if '__repr__' not in f.__dict__:
    def strip_dict(self):
      return str({k: v for k, v in self.__dict__.items() if not k.startswith('_')})
    f.__repr__ = strip_dict
  return f


class bound:
  """Custome attribute to delegate changes to a property."""
  def __init__(self, default, name):
    self.name = name
    if not default:
      if type(default) in (set, list, tuple, dict):
        self.default = type(default)()
    self.default = default

  # set name not working in current brython version
  def __set_name__(self, owner, name):
    self.name = name

  def __get__(self, instance, owner):
    if not instance: return self.default
    return instance.__dict__[self.name]

  def __delete__(self, instance):
    del instance.__dict__[self.name]

  def __set__(self, instance, value):
    curval = instance.__dict__.get(self.name, self)

    instance.__dict__[self.name] = value

    if value != curval:
      getattr(instance, f'on_{self.name}')(curval, value)


@enforce_class
class Engine:
  """Organizes classes to be quickly referenced later.
  
  This takes supplied entities, gets their base classes and makes a dictionary
    referring to all the classes. This is looked up as a dictionary with __getitem__.
  """

  entities: list = bound([], 'entities')
  components: list = bound([], 'components')
  objs: dict = bound({}, 'objs')

  def __post_init__(self):
    for e in self.entities:
      self.objs[e] = []
      for base in e.__bases__:
        self.objs[base] = []
        self.components.append(base)

  def load(self, data):
    """Load dictionary and create objects as needed."""
    for k,v in self.objs.items():
      if k in self.entities and k.__qualname__ in data:
        for item in data[k.__qualname__]:
          self.add(k(**item))
  
  def __repr__(self):
    return str({e.__qualname__: self.objs[e] for e in self.entities})

  def __getitem__(self, key):
    return self.objs[key]

  def add(self, obj):
    self.objs[obj.__class__].append(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].append(obj)

  def remove(self, obj):
    self.objs[obj.__class__].remove(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].remove(obj)


# --- table stuff

def ig(obj, prop):
  return [i[prop] for i in obj]

def itemgetter(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return obj[item]
  else:
    def g(obj):
      return tuple(obj[item] for item in items)
  return g


class groupby:
  # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
  # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
  def __init__(self, iterable, key=None):
    if key is None:
      key = lambda x: x
    self.keyfunc = key
    self.it = iter(iterable)
    self.tgtkey = self.currkey = self.currvalue = object()
  def __iter__(self):
    return self
  def __next__(self):
    self.id = object()
    while self.currkey == self.tgtkey:
      self.currvalue = next(self.it)  # Exit on StopIteration
      self.currkey = self.keyfunc(self.currvalue)
    self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
  def _grouper(self, tgtkey, id):
    while self.id is id and self.currkey == tgtkey:
      yield self.currvalue
      try:
        self.currvalue = next(self.it)
      except StopIteration:
        return
      self.currkey = self.keyfunc(self.currvalue)

def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out


base_table_str = '''
@enforce_class
class R:
  _sub_table: str = ''
  pass

  def __getitem__(self, key):
    return self.__dict__[key]

  def __setitem__(self, key, value):
    return setattr(self, key, value)
  
locals()['R'] = R
'''

def trycast(d, anno):
  for k, v in d.items():
    if anno[k] is not any and not isinstance(v, anno[k]):
      d[k] = anno[k](v)


# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out


class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    prop_str = ''
    prop_dict = {}

    row_props = self.code.split('\n\n')[0]
    for i in row_props.splitlines():
      if ':' in i:
        prop_dict[i.split(':')[0]] = i

    for h in self.headers:
      if h not in prop_dict:
        prop_str += f"\n  {h}: any = ''"
      else:
        prop_str += f"\n  {prop_dict[h]}"

    loc = {}
    exec(base_table_str.replace('pass', prop_str), globals(), loc)

    self.Row = loc['R']
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        _d = {k:v for k, v in zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]) if v != ''}
        trycast(_d, self.Row.__annotations__)
        self.table.append(self.Row(**_d))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n' 
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}'
    return out


  def run_code(t):
    exec(t.code)

  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}



aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
