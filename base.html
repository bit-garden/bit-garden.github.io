<html>
<title>Testing</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<style>
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
        color:white;
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}

body{
  background:#121212;
  padding:0px;
  margin:0px;
}

input::-webkit-calendar-picker-indicator {
  display: none;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython_aio.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser import aio
from browser.html import *
# storage is like dictionary
#from browser.local_storage import storage



g = None

def g_resize(self):
  gmap(self, 0, 1, doc['Income'])
  gmap(self, 1, 1, doc['Incomebox'])
  gmap(self, 0, 2, doc['Household'])
  gmap(self, 1, 2, doc['Householdbox'])
  gmap(self, 0, 3, doc['State'])
  gmap(self, 1, 3, doc['Statesbox'])
  gmap(self, 2, 0, doc['Frequency'])
  gmap(self, 2, 1, doc['Frequencybox'])

  gmap(self, 2, 3, doc['Calculate'])
  gmap(self, 2, 2, doc['Reset'])

async def ui():
  global g

  g = Gridman(rows=[64]*4, cols=[150, 300, 150])

  labels = ['Income', 'Household', 'State', 'Frequency']
  doc <= InputOptions(['Other', 'Alaska', 'Hawaii'], Id='states')
  doc <= InputOptions(['Weekly', 'Monthly', 'Yearly'], Id='frequencies')

  for label in labels:
    doc <= Space(Flex(label), Id=label)

  doc <= Space(Input(), Id='Incomebox')
  doc <= Space(Input(), Id='Householdbox')
  doc <= Space(Input(_list='states', force_list=True), Id='Statesbox')
  doc <= Space(Input(_list='frequencies', force_list=True), Id='Frequencybox')

  doc <= Space(Button('Calculate'), Id='Calculate')
  doc <= Space(Button('Reset'), Id='Reset')



  g.bind(update=g_resize)
  on_resize(g)


  



  
  
def on_resize(*l, **kw):
  global g
  g.width = getdim(doc.querySelector('body')).width
  g.height = getdim(doc.querySelector('body')).height
  # do layout changes with this
  
window.addEventListener('resize', on_resize);

def on_scroll(self, *l, **kw):
  if window.pageYOffset == 0:
    pass
  else:
    pass
  # do layout changes with this
window.addEventListener('scroll', on_scroll);


def tint(r, g, b, a, val):
  '''Tints rgb values to apply 'white' layer to materials'''

  rt = r + (val * (255 - r))
  gt = g + (val * (255 - g))
  bt = b + (val * (255 - b))
  return (rt, gt, bt, a)

class Space(DIV):
  def __init__(self, *l, **kw):
    super().__init__(*l, style={'position': 'absolute', 'margin': '0px', 'padding': '0px',
      'display': 'flex',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'transition': 'all 0.3s',
      'box-sizing': 'border-box',}, **kw)

class Flex(DIV):
  opacities = {0:  0, 1: .05, 2: .07, 3: .08, 4: .09, 6: .11, 8: .12, 12: .14, 16: .15, 24: .16}
  shadows = {0: 'none', 
              1: '0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)',
              2: '0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)',
              3: '0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)',
              4: '0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)',
              6: '0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)',
              8: '0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)',
              12: '0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)',
              16: '0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)',
              24: '0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)',}

  def __init__(self, *l, color=(18, 18, 18, 1), padding='12px 18px', elevation=0, flow='row wrap', justify='flex-start', align_items='stretch', align_content='stretch', grow=1, flat=False, style={}, **kw):
    base_style = {
      #'position': 'absolute',
      'border': 'none',
      'margin': '8px',
      'border-radius': '5px',
      'font-size': '16px',
      'cursor': 'default',
      'color': 'white',
      'outline': 'none',
      #'background': f'rgba{color}',
      'display': 'flex',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'transition': 'all 0.3s',
      'box-sizing': 'border-box',
      'overflow': 'auto',
    }
    base_style.update(style)

    super().__init__(*l, style=base_style, **kw)

    self.__color = color
    self.__elevation = elevation
    self.flat = flat
    self.color = color
    self.padding = padding
    self.elevation = elevation
    self.flow = flow
    self.justify = justify
    self.align_items = align_items
    self.align_content = align_content
    self.grow = grow


  @property
  def color(self):
    return self.__color
  @color.setter
  def color(self, value):
    self.__color = value
    if not self.flat:
      self.style['background'] = f'rgba{tint(*value, self.opacities[self.elevation])}'
    else:
      self.style['background'] = f'rgba(255, 255, 255, {self.opacities[self.elevation]})'

  @property
  def padding(self):
    return self.__padding
  @padding.setter
  def padding(self, value):
    self.__padding = value
    self.style['padding'] = value

  @property
  def elevation(self):
    return self.__elevation
  @elevation.setter
  def elevation(self, value):
    self.__elevation = value
    if not self.flat:
      self.style['background'] = f'rgba{tint(*self.color, self.opacities[value])}'
      self.style['box-shadow'] = self.shadows[value]
    else:
      self.style['background'] = f'rgba(255, 255, 255, {self.opacities[value]})'

  @property
  def flow(self):
    '''
      row (default): left to right in ltr; right to left in rtl
      row-reverse: right to left in ltr; left to right in rtl
      column: same as row but top to bottom
      column-reverse: same as row-reverse but bottom to top
      nowrap (default): all flex items will be on one line
      wrap: flex items will wrap onto multiple lines, from top to bottom.
      wrap-reverse: flex items will wrap onto multiple lines from bottom to top.
    '''
    return self.__flow
  @flow.setter
  def flow(self, value):
    self.__flow = value
    self.style['flex-flow'] = value

  @property
  def justify(self):
    '''
      flex-start (default): items are packed toward the start of the flex-direction.
      flex-end: items are packed toward the end of the flex-direction.
      start: items are packed toward the start of the writing-mode direction.
      end: items are packed toward the end of the writing-mode direction.
      left: items are packed toward left edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
      right: items are packed toward right edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
      center: items are centered along the line
      space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line
      space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren't equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.
      space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal.
    '''
    return self.__justify
  @justify.setter
  def justify(self, value):
    self.__justify = value
    self.style['justify-content'] = value

  @property
  def align_items(self):
    '''
      stretch (default): stretch to fill the container (still respect min-width/max-width)
      flex-start / start / self-start: items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the flex-direction rules or the writing-mode rules.
      flex-end / end / self-end: items are placed at the end of the cross axis. The difference again is subtle and is about respecting flex-direction rules vs. writing-mode rules.
      center: items are centered in the cross-axis
      baseline: items are aligned such as their baselines align
    '''
    return self.__align_items
  @align_items.setter
  def align_items(self, value):
    self.__align_items = value
    self.style['align-items'] = value

  @property
  def align_content(self):
    '''
      flex-start / start: items packed to the start of the container. The (more supported) flex-start honors the flex-direction while start honors the writing-mode direction.
      flex-end / end: items packed to the end of the container. The (more support) flex-end honors the flex-direction while end honors the writing-mode direction.
      center: items centered in the container
      space-between: items evenly distributed; the first line is at the start of the container while the last one is at the end
      space-around: items evenly distributed with equal space around each line
      space-evenly: items are evenly distributed with equal space around them
      stretch (default): lines stretch to take up the remaining space
    '''
    return self.__align_content
  @align_content.setter
  def align_content(self, value):
    self.__align_content = value
    self.style['align-content'] = value

  @property
  def grow(self):
    return self.__grow
  @grow.setter
  def grow(self, value):
    self.__grow = value
    self.style['flex-grow'] = value

  def __repr__(self):
    return "{" + f"'flat': {repr(self.flat)}, 'color': {repr(self.color)}, 'padding': {repr(self.padding)}, 'elevation': {repr(self.elevation)}, 'flow': {repr(self.flow)}, 'justify': {repr(self.justify)}, 'align_items': {repr(self.align_items)}, 'align_content': {repr(self.align_content)}" + "}"

class Textbox(TEXTAREA, Flex):
  def __init__(self, *l, placeholder='', name='', **kw):
    Flex.__init__(self, *l, **kw)
    
    self.setAttribute('placeholder', placeholder)
    self.setAttribute('name', name)

    self.style['border-bottom'] = f'solid 2px rgba{tint(*(0, 0, 128, 1), self.opacities[6])}'

    self.base_elevation = kw.get('elevation', 0)

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))

    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))

class Input(INPUT, Flex):
  def __init__(self, text='', placeholder='', _list='', name='', _type='', force_list=False, *l, **kw):
    Flex.__init__(self, *l, **kw)
    
    self.setAttribute('value', text)
    self.setAttribute('placeholder', placeholder)
    self.setAttribute('name', name)
    self.setAttribute('type', _type)
    self.setAttribute('list', _list)
    self._list = _list
    self.placeholder = placeholder

    if not kw.get('flat', False):
      self.style['border-bottom'] = f'solid 2px rgba{tint(*(0, 0, 128, 1), self.opacities[6])}'

    self.base_elevation = kw.get('elevation', 0)

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))

    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))

    if force_list:
      def erase(ev):
        if self.value:
          self.placeholder = self.value
        self.value = ''
      def force(ev):
        dataset = doc.querySelector(f'#{self._list}').possibilities
        if not self.value:
          if self.placeholder in dataset:
            self.value = self.placeholder
          else:
            self.value = dataset[0]
        else:
          for opt in dataset:
            if self.value in opt:
              self.value = opt
              break
          else:
            self.value = dataset[0]
      self.bind('focus', erase)
      self.bind('click', erase)
      self.bind('blur', force)
      force(None)

  @property
  def placeholder(self):
    return self.__placeholder
  @placeholder.setter
  def placeholder(self, value):
    self.__placeholder = value
    self.setAttribute('placeholder', value)

class InputOptions(DATALIST):
  def __init__(self, possibilities, *l, **kw):
    self.possibilities = possibilities
    super().__init__(*l, **kw)
    self.update()

  def update(self):
    self.clear()
    for opt in self.possibilities:
      self <= OPTION(value=opt)

  def __repr__(self):
    return "{" + f"'possibilities': {repr(self.possibilities)}" + "}"

class Edge(Flex):
  def __init__(self, *l, **kw):
    super().__init__(*l, **kw, padding='0px')
    self.style['border-radius'] = '0px'
    self.style['margin'] = '0px'

class Menu(Flex):
  def __init__(self, *l, **kw):
    super().__init__(*l, **kw, elevation=8, flow='column wrap')
    self.style['width'] = '300px'

class Card(Flex):
  pass

class Button(Flex):
  def __init__(self, *l, elevation=0, flat=False, raised=False, **kw):
    if raised:
      elevation = 2
    else:
      flat = True

    super().__init__(*l, elevation=elevation, flat=flat, tabindex=0, **kw)

    self.base_elevation = elevation

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 6))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))
    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 6))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))
    self.bind('keyup', self.on_enter)
    
  def on_enter(self, ev):
    if ev.keyCode in (13, 32):
      ev.preventDefault()
      self.click()
      

class Fab(Button):
  def __init__(self, icon, *l, **kw):
    super().__init__(Icon(icon), elevation=6, raised=True, *l, **kw)
    self.style['padding'] = '18px'
    self.style['border-radius'] = '50%'
    self.icon = icon

  @property
  def icon(self):
    return self.__icon
  @icon.setter
  def icon(self, value):
    self.__icon = value
    self.children[0].icon = value

  def __repr__(self):
    return "{" + f"'icon': {repr(self.icon)}" + "}"

class Snack(Card):
  def __init__(self, *l, delay=5, **kw):
    self.delay = delay
    super().__init__(*l, **kw, elevation=6)
    self.style['width'] = '100%'
    self.style['border-radius'] = '0px'
    self.style['position'] = 'fixed'
    self.style['margin'] = '0px'

  def show(self):
    self.style['bottom'] = 0

  def hide(self):
    self.style['bottom'] = -getdim(self).height

  def __repr__(self):
    return "{" + f"'delay': {repr(self.delay)}" + "}"

class Icon(I):
  def __init__(self, icon, *l, **kw):
    super().__init__(Class='material-icons', *l, **kw)
    self.icon = icon

  @property
  def icon(self):
    return self.__icon
  @icon.setter
  def icon(self, value):
    self.__icon = value
    self.innerHTML = value

  def __repr__(self):
    return "{" + f"'icon': {repr(self.icon)}" + "}"


anim = {'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
        'transition': 'all 0.3s'}


def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)

  
# ready the aio tasks
async def main():
  res = await aio.gather(snackbar(), ui())

  for k, v in res.items():
    print(f'{k}: {v}')
  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html
  '''
  
  def __init__(self, *):
    self._set = False
    
  async def wait(self):
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self):
    return self._set
    
  def set(self):
    self._set = True
    
  def clear(self):
    self._set = False
    
aio.Event = Event

class Lock:
  def __init__(self, *):
    self._locked = False

  async def acquire(self):
    while self._locked:
      await aio.sleep(0)
    self._locked = True

  def release(self):
    if not self._locked:
      raise RuntimeError('Lock is already released')
    self._locked = False

  def locked(self):
    return self._locked

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()

aio.Lock = Lock

class Semaphore:
  def __init__(self, value=1, *):
    self._locked = False
    self.count = value
    self.limit = value

  async def acquire(self):
    while self.count < 1:
      await aio.sleep(0)
    self.count -= 1

  def release(self):
    self.count = min(self.count + 1, self.limit)

  def locked(self):
    return self.count == 0

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()
    
aio.Semaphore = Semaphore


# usefull for binding multiple buttons
def parents_of(_tar):
  parents = []
  base = _tar
  while(base):
    parents.append(base)
    base = base.parentNode
    
  return parents
  
class Dimension:
  def __init__(self, bottom, height, left, right, top, width):
    self.bottom = bottom
    self.height = height
    self.left = left
    self.right = right
    self.top = top
    self.width = width
    self.center = (left + (width/2), top + (height/2))
    
  def __repr__(self):
    return "{" + f"'top': {repr(self.top)}, 'bottom': {repr(self.bottom)}, 'left': {repr(self.left)}, 'right': {repr(self.right)}, 'height': {repr(self.height)}, 'width': {repr(self.width)}, 'center': {repr(self.center)}" + "}"

def getdim(el):
  br = el.getBoundingClientRect()
  out = {
          'bottom': br.bottom,
          'height': br.height,
          'left': br.left,
          'right': br.right,
          'top': br.top,
          'width': br.width
          }
  return Dimension(**out)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        pass

    ev = await aio.select_event(doc, 'keyup keydown')
  
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass
    
class Popup:
  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1'
    })

    self.box = DIV(style={
      'position': 'absolute',
      'left': '12.5%',
      'top': '25%',
      'opacity': 0,
      #'width': '75%',
      #'height': '75%',
      'margin': '-16px',
      'transition': 'opacity .3s, top .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'border': 'none',
      #'padding': '12px 18px',
      'font-size': '16px',
      'cursor': 'default',
      'color': 'white',
      #'background-color': '#282828',
      'outline': 'none'
    })

    self.frame <= self.box
    center(self.box)
    self.box.top += 250
    
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.frame, 'click')
      if ev.type == 'cancel' or ev.target == self.frame:
        break
        
    # Try to break all awaiting UI.
    for el in self.box.querySelectorAll('*'):
      aio.cancel_event(el)
      
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    #self.box.style['top'] = '25%'
    self.box.top += 250
    await aio.sleep(.4)

    self.frame.remove()
    
  async def __aenter__(self):
    self._root <= self.frame

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1
    #self.box.style['top'] = '12.5%'
    self.box.top -= 250

    aio.run(self._background())
    
    return self.box
    
  async def __aexit__(self, type, value, traceback):
    aio.cancel_event(self.frame)

async def popup(content):
  frame = DIV(Class='darken', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1'
    })

  box = DIV(content, style={
      'position': 'absolute',
      #'left': '12.5%',
      #'top': '25%',
      'opacity': 0,
      #'width': '75%',
      #'height': '75%',
      'margin': '-16px',
      'transition': 'opacity .3s, top .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'border': 'none',
      #'padding': '12px 18px',
      'font-size': '16px',
      'cursor': 'default',
      'color': 'white',
      #'background-color': '#282828',
      'outline': 'none'
    })

  frame <= box

  doc <= frame
  center(box)
  box.top += 250

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.top -= 250

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.top += 250
  await aio.sleep(.4)

  frame.remove()

snacks = []
async def snackbar():
  while True:
    while snacks:
      val = snacks.pop(0)
      doc <= val
      val.hide()

      await aio.sleep(.05)

      val.show()
      await aio.sleep(val.delay + .3)

      val.hide()

      await aio.sleep(.3)

      val.remove()
      
    await aio.sleep(0)

class Point:
  def __init__(self, x=0, y=0):
    self.x = round(x)
    self.y = round(y)
    
  def __repr__(self):
    return "{" + f"'x': {repr(self.x)}, 'y': {repr(self.y)}" + "}"
    

class Cell:
  def __init__(self, topleft={'x': 0, 'y': 0}, bottomright={'x': 0, 'y': 0}):
    self.__topleft = Point()
    self.__bottomright = Point()
    self.topleft = topleft
    self.bottomright = bottomright

  @property
  def topleft(self):
    return self.__topleft
  @topleft.setter
  def topleft(self, value):
    self.__topleft = value if type(value) is Point else Point(**value)
    self.width = self.bottomright.x - self.topleft.x
    self.height = self.bottomright.y - self.topleft.y
    self.center = Point(self.topleft.x + round(self.width/2.0), self.topleft.y + round(self.height/2.0))
    self.bottomleft = Point(self.topleft.x, self.bottomright.y)
    self.topright = Point(self.bottomright.x, self.topleft.y)

  @property
  def bottomright(self):
    return self.__bottomright
  @bottomright.setter
  def bottomright(self, value):
    self.__bottomright = value if type(value) is Point else Point(**value)
    self.width = self.bottomright.x - self.topleft.x
    self.height = self.bottomright.y - self.topleft.y
    self.center = Point(self.topleft.x + round(self.width/2.0), self.topleft.y + round(self.height/2.0))
    self.bottomleft = Point(self.topleft.x, self.bottomright.y)
    self.topright = Point(self.bottomright.x, self.topleft.y)

  def __repr__(self):
    return "{" + f"'bottomright': {repr(self.bottomright)}, 'bottomleft': {repr(self.bottomleft)}, 'topright': {repr(self.topright)}, 'topleft': {repr(self.topleft)}, 'width': {repr(self.width)}, 'height': {repr(self.height)}, 'center': {repr(self.center)}" + "}"
    
def gmap(grid, col, row, obj, width=0, height=0):
  if col < 0:
    col += len(grid.cols)
  if row < 0:
    row += len(grid.rows)
  obj.top = grid.cells[row][col].topleft.y
  obj.left = grid.cells[row][col].topleft.x

  obj.width = grid.cells[row+height][col+width].bottomright.x - obj.left
  obj.height = grid.cells[row+height][col+width].bottomright.y - obj.top
    
class Gridman:
  def __init__(self, cols=[], rows=[], width=0, height=0, left=0, top=0):
    self.cols = cols
    self.rows = rows
    self.width = width
    self.height = height
    self.left = left
    self.top = top
    self._cbs = {}
    
    self.cells = []
    self.update()
    
  def update(self):
    self.cells.clear()
    self.cells.extend(list() for i in range(len(self.rows)))
    for row in self.cells:
      row.extend(Cell() for i in range(len(self.cols)))
      
    widths = []
    for col in self.cols:
      if col != 'fill':
        if col < 1:
          widths.append(col*self.width)
        else:
          widths.append(col)
      else:
        widths.append('fill')
    
    remainder = max(0, self.width - sum(i for i in widths if i!='fill'))
    buffs = 0
    if 'fill' in widths:
      widths[widths.index('fill')] = remainder
    else:
      buffs = remainder/2
      
    last = buffs + self.left
    lefts = [buffs + self.left]
    for width in widths:
      lefts.append(width + last)
      last += width
      
    heights = []
    for row in self.rows:
      if row != 'fill':
        if row < 1:
          heights.append(row*self.height)
        else:
          heights.append(row)
      else:
        heights.append('fill')
    
    remainder = max(0, self.height - sum(i for i in heights if i!='fill'))
    buffs = 0
    if 'fill' in heights:
      heights[heights.index('fill')] = remainder
    else:
      buffs = remainder/2
      
    last = buffs + self.top
    tops = [buffs + self.top]
    for height in heights:
      tops.append(height + last)
      last += height
      
    for ci, col in enumerate(lefts[:-1]):
      for ri, row in enumerate(tops[:-1]):
        self.cells[ri][ci].topleft = Point(col, row)
        self.cells[ri][ci].bottomright = Point(lefts[ci+1], tops[ri+1])
    self.dispatch('update')
        
  def bind(self, **kwargs):
    for k, v in kwargs.items():
      if k not in self._cbs:
        self._cbs[k] = []
      self._cbs[k].append(v)

  def unbind(self, **kwargs):
    for k, v in kwargs.items():
      self._cbs[k].remove(v)
      if not self._cbs[k]:
        del self._cbs[k]

  def dispatch(self, prop, *l, **kw):
    if getattr(self, f'on_{prop}', None):
      getattr(self, f'on_{prop}')(*l, **kw)
    if prop in self._cbs:
      for cb in self._cbs[prop]:
        cb(self, *l, **kw)

  @property
  def cols(self):
    return self._cols
  @cols.setter
  def cols(self, value):
    if not hasattr(self, "_cols"): self._cols = value
    oldval = self._cols
    self._cols = value
    if oldval != value: 
      self.dispatch("cols", oldval, value)
      self.update()

  @property
  def rows(self):
    return self._rows
  @rows.setter
  def rows(self, value):
    if not hasattr(self, "_rows"): self._rows = value
    oldval = self._rows
    self._rows = value
    if oldval != value: 
      self.dispatch("rows", oldval, value)
      self.update()

  @property
  def width(self):
    return self._width
  @width.setter
  def width(self, value):
    if not hasattr(self, "_width"): self._width = value
    oldval = self._width
    self._width = value
    if oldval != value: 
      self.dispatch("width", oldval, value)
      self.update()

  @property
  def height(self):
    return self._height
  @height.setter
  def height(self, value):
    if not hasattr(self, "_height"): self._height = value
    oldval = self._height
    self._height = value
    if oldval != value: 
      self.dispatch("height", oldval, value)
      self.update()

  @property
  def left(self):
    return self._left
  @left.setter
  def left(self, value):
    if not hasattr(self, "_left"): self._left = value
    oldval = self._left
    self._left = value
    if oldval != value: 
      self.dispatch("left", oldval, value)
      self.update()

  @property
  def top(self):
    return self._top
  @top.setter
  def top(self, value):
    if not hasattr(self, "_top"): self._top = value
    oldval = self._top
    self._top = value
    if oldval != value: 
      self.dispatch("top", oldval, value)
      self.update()

  def __repr__(self):
    return "{" + f"'objs': {repr(self.objs)}, 'cols': {repr(self.cols)}, 'rows': {repr(self.rows)}, 'width': {repr(self.width)}, 'height': {repr(self.height)}, 'left': {repr(self.left)}, 'top': {repr(self.top)}, 'invert_y': {repr(self.invert_y)}" + "}"

aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
