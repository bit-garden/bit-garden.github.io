<html>
<title>Testing board</title>
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import document as doc
from browser import window
from browser.html import *
import traceback

def Try(_callback = None):
  def _try(_func):
    def __try(*args, **kwargs):
      try:
        return _func(*args, **kwargs)
      except Exception as e:
        if _callback:
          if callable(_callback):
            #_callback((_func.__name__, e))
            _callback(traceback.format_exc())
          else:
            print(_callback)
    return __try
  return _try


# storage is like dictionary
#from browser.local_storage import storage


@Try(window.alert)
def main():
  doc <= BUTTON('test', Class='card ripple')
  doc <= BUTTON('test', Class='button ripple')
  doc <= INPUT('test', Class='card input')
  doc <= INPUT('test', Class='button input')
  doc <= INPUT(Class='card input', Type='text', list='browsers')
  dropdown_options = DATALIST(Id='browsers')
  for op in ['apple', 'banana', 'cucumber']:
    dropdown_options <= OPTION(op)
  doc <= dropdown_options
  
  doc <= DIV(make_toggle('test'), style={'width':'200px'})
  doc <= DIV(make_toggle('test', Class='card'), style={'width':'200px'})
  doc <= BUTTON('test', Class='card red_card ripple red_ripple')
  doc <= BUTTON('test', Class='card green_card ripple green_ripple')
  doc <= BUTTON('test', Class='card blue_card ripple blue_ripple')
  doc <= BUTTON('test', Class='card purple_card ripple purple_ripple')
  doc <= BUTTON('test', Class='card orange_card ripple orange_ripple')


# --- start focus
from browser import window
from browser.html import *

from copy import deepcopy
from operator import itemgetter
import itertools
import re
import time

# do not run first pass
# restart timer each call, within wait
# only call last instance
def debounce(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """
  def decorator(fn):
    def debounced(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        if cache is not None:
          tc = cache[:]
          cache.clear()
          fn(*args, cache=tc, **kwargs)
        else:
          fn(*args, **kwargs)
      try:
        window.clearTimeout(debounced.t)
      except(AttributeError):
        pass
      debounced.t = window.setTimeout(call_it, int(wait*1000))
      #debounced.t.start()
    return debounced
  return decorator


# run first pass
# only call last instance
def throttle(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """

  def decorator(fn):
    def throttled(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        throttled._timer = None
        throttled._last_call = time.time()
        if cache is not None:
          tc = cache[:]
          cache.clear()
          return fn(*args, cache=tc, **kwargs)
        else:
          return fn(*args, **kwargs)

      time_since_last_call = time.time() - throttled._last_call
      if time_since_last_call >= wait:
        return call_it()

      if throttled._timer is None:
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()
      else:
        window.clearTimeout(throttled._timer)
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()

    throttled._timer = None
    throttled._last_call = 0

    return throttled

  return decorator

# Sort key for logical number sorting
def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
  return [int(text) if text.isdigit() else text.lower()
          for text in _nsre.split(s)]    

def itemgetter_nat(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return natural_sort_key(obj[item])
  else:
    def g(obj):
      return natural_sort_key(' '.join(str(obj[item]) for item in items))
  return g

# sort by multiple columns
def sort_data(data, *cats, **kwargs):
  return sorted(data, key=itemgetter_nat(*cats), **kwargs)

# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in itertools.groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out

# --- property modifiers

# Returns error if not one of the allowed types
def union(*largs):
  def _union(obj):
    if type(obj) not in largs:
      raise(Exception(f'Union violated with {obj}'))
    else:
      return obj
  return _union

# Same as Union(None, ...)
def optional(*largs):
  return union(None, *largs)

def options(default='', choices=[]):
  def _options(obj):
    if obj in choices:
      return obj
    return default
  return _options

# Returns value locked to min of lower, max of upper
# lower and upper are inclusive
def bounded_number(lower, upper):
  def _bounded_number(num):
    num = union(int, float)(num)
    if num > upper:
      return upper
    if num < lower:
      return lower
    return num
  return _bounded_number

# Returns value wrapped to min of lower, max of upper
# lower is inclusive and upper is exclusive
def wrapped_number(lower, upper):
  diff = abs(upper - lower)
  def _wrapped_number(num):
    num = union(int, float)(num)
    while num >= upper:
      num -= diff
    while num < lower:
      num += diff
    return num
  return _wrapped_number
  
def d2e(_type):
  def _d2e(obj):
    obj = union(list, _type, dict)(obj)
    if type(obj) == list:
      return [type(union(dict, _type)(o)) == _type and o or _type(**o) for o in obj]
    elif type(obj) == _type:
      return obj
    else:
      return _type(**obj)
  return _d2e
  
def length(value):
  def _length(obj):
    return obj[:value]
  return _length

# --- Property

# Call generate_prop(target, prop_name)
# This binds prop_name property with simple getter, setter that calls bound functions
# and on{prop_name} function of the class.
# This also uses the on_prop_name list of functions to constrain the value
#
# Like x = Property(0)
# y = Property(10, union(int, str))
class Property:
  def __init__(self, default_value=None, *on_prop_name):
    self.default_value = default_value
    self.on_prop_name = on_prop_name

  def generate_prop(class_self, self, prop_name, new_default_value = None):
    #def Property(prop_name, on_prop_name = None):
    #if new_default_value is not None:
    #  setattr(self.__class__, f'_{prop_name}', new_default_value)
    #else:
    self.__class__.property_list.append(prop_name)
    setattr(self.__class__, f'_{prop_name}', class_self.default_value)
    if new_default_value is not None:
      for on_prop_fun in class_self.on_prop_name:
        new_default_value = on_prop_fun(new_default_value)
      setattr(self, f'_{prop_name}', new_default_value)
    else:
      setattr(self, f'_{prop_name}', deepcopy(class_self.default_value))

    def _get(self):
      return getattr(self, f'_{prop_name}', class_self.default_value)

    def _set(self, value):
      if getattr(self, f'_{prop_name}') != value:

        old_val = getattr(self, f'_{prop_name}')

        for on_prop_fun in class_self.on_prop_name:
          value = on_prop_fun(value)

        setattr(self, f'_{prop_name}', value)

        if getattr(self, f'on_{prop_name}', None):
          getattr(self, f'on_{prop_name}')(prop=prop_name, value=value, old_val=old_val)

        if prop_name in self.properties:
          for func in self.properties[prop_name]:
            func(self, prop=prop_name, value=value, old_val=old_val)

    setattr(self.__class__, prop_name, property(_get, _set))


# --- Entity

# Base Entity class.
class Entity:
  #property_list = []

  # allows binding at runtime
  #def bind(self, prop_name, func):
  def bind(self, **kwargs):
    for prop_name, func in kwargs.items():
      if prop_name in self.property_list:
        if prop_name not in self.properties:
          self.properties[prop_name] = []
        self.properties[prop_name].append(func)
  def unbind(self, **kwargs):
    for prop_name, func in kwargs.items():
      self.properties[prop_name].remove(func)

  # manually dispatch change
  # used for non reporting types like lists or dicts
  def dispatch(self, prop_name, *largs, **kwargs):
    _on_fun = getattr(self, f'on_{prop_name}', None)
    if _on_fun:
      _on_fun(*largs, **kwargs)
    for cb in self.properties.get(prop_name, []):
      cb(self, *largs, **kwargs)

  def __repr__(self):
    return str(dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')])))

  def __str__(self):
    return str(dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')])))
  
  def __getitem__(self, item):
    return getattr(self, item)

  def __setitem__(self, item, value):
    return setattr(self, item, value)

  def to_dict(self):
    return dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')]))

  def __init__(self, **kwargs):
    self.components = []
    self.properties = {}
    if 'property_list' not in dir(self):
      self.__class__.property_list = []

    for base in reversed(self.__class__.__bases__[1:]):
      if Component in base.__bases__:
        self.components.append(base)
      #base.__init__(self, **kwargs)

    for attr in dir(self.__class__):
      if getattr(self.__class__, attr).__class__ == Property:
        self.properties[attr] = []
        getattr(self.__class__, attr).generate_prop(self, attr, kwargs.get(attr, None))

      if attr in self.property_list:
        setattr(self, attr, kwargs.get(attr, getattr(self.__class__, f'_{attr}')))
        _on_fun = kwargs.get(f'on_{attr}', None)
        if _on_fun:
          self.bind(**{attr: _on_fun})


# --- Components

# Component shell
class Component:
  pass

# --- Engine

class Engine:
  def __init__(self, *systems):
    self.systems = systems
    self.entities = {}

  def tick(self, delta=0):
    for system in self.systems:
      system.tick(delta)

  def add(self, *entities):
    for system in self.systems:
      system.add(*entities)
    for en in entities:
      if en.__class__.__name__ not in self.entities:
        self.entities[en.__class__.__name__] = []
      self.entities[en.__class__.__name__].append(en)

  def remove(self, *entities):
    for system in self.systems:
      system.remove(*entities)
    for en in entities:
      self.entities[en.__class__.__name__].remove(en)

# --- System

class System:
  components = []

  def __init__(self):
    self.entities = []

  def add(self, *entities):
    for en in entities:
      for component in self.components:
        if component in en.components and not en in self.entities:
          self.entities.append(en)
          self.on_add(en)

  def on_add(self, entity):
    pass

  def remove(self, *entities):
    for en in entities:
      if en in self.entities:
        self.entities.remove(en)
        self.on_remove(en)

  def on_remove(self, entity):
    pass

  def tick(self, delta=0):
    pass
    
    
def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out

def default(value):
  def _default(obj):
    return obj or value
  return _default
  
def ig(obj, prop):
  return [i[prop] for i in obj]

class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    if self.code.splitlines()[0].strip().startswith('props ='):
      row_props = self.code.split('\n\n')[0][7:]
      kwargs = eval(row_props)

    class Row(Entity): pass
    self.Row = Row

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    for h in self.headers:
      setattr(self.Row, h, kwargs.get(h, Property('')))
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        self.table.append(self.Row(**dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]))))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n'
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}\n'
    return out


  def run_code(t):
    @debounce(.25, cache=[])
    def print(*l, cache=[]):
      window.console.log('\n'.join([str(i[0][0]) for i in cache]))
    exec(t.code)
    
  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}

# --- end focus
      
def toggle_onoff(ev):
  classes = ev.currentTarget.className.split(' ')
  if 'check-off' in classes:
    classes.remove('check-off')
    classes.append('check-on')
    ev.currentTarget.state='on'
  else:
    classes.remove('check-on')
    classes.append('check-off')
    ev.currentTarget.state='off'
  ev.currentTarget.className = ' '.join(classes)
  
window.toggle_onoff = toggle_onoff

def make_toggle(text='test', _on='ON', _off='OFF', state='off', on_state=None, Class='button'):
  b = BUTTON(
          DIV(text, Class='label') + 
          DIV(_on, Class='on') +
          DIV(_off, Class='off'),
        Class=f'{Class} ripple check-{state}')
  b.bind('click', toggle_onoff)
  if on_state:
    b.bind('click', on_state)
  b.state=state
  return b

main()

</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
