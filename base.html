<html>
<title>Testing board</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
@font-face {
  font-family: Roboto;
  src: url("Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
        color:white;
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}

body{
  background:#000;
  padding:0px;
  margin:0px;
}

input::-webkit-calendar-picker-indicator {
  display: none;
}
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython_aio.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser import aio
from browser.html import *
# storage is like dictionary
#from browser.local_storage import storage


anim = {'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
        'transition': 'all 0.4s'}

opacities = {0:  0, 1: .05, 2: .07, 3: .08, 4: .09, 6: .11, 8: .12, 12: .14, 16: .15, 24: .16}
elevation = {k:f'rgba(255, 255, 255, {v})' for k, v in opacities.items()}

def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  print(eldim)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)

themes = {}
themes['root'] = {
  'background': '#121212',
  'color': '#fff',
  'padding': '0px',
  'margin': '0px',
  'left': 0,
  'right': 0,
  'width': '100%',
  'height': '100%',
  'display': 'inline',
  
  'transform-origin': 'center',
  'transform': 'scale(1)',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
  
  'position': 'fixed',
}

themes['sidebar'] = {
  'background': '#282828',
  'color': '#fff',
  'padding': '0px',
  'margin': '0px',
  'width': '300px',
  'top': '0px',
  'left': '-300px',
  'height': '100%',
  'display': 'inline',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
  
  'position': 'fixed',
}

themes['popup'] = {
  'background': '#121212',
  'color': '#fff',
  'padding': '0px',
  'position': 'fixed',
  'display': 'inline',
}

themes['button'] = {
  'background': elevation[1],
  'color': '#fff',
  'display': 'inline',
  'border': 'none',
  'padding': '12px 18px',
  'font-size': '16px',
  'cursor': 'default',
  'outline': 'none'
}

themes['snack'] = {
  'background': '#282828',
  'color': '#fff',
  'display': 'inline',
  'padding': '12px 18px',
  'font-size': '16px',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
}


def on_sidebar(self, old, value):
  if value:
    #rootdim = getdim(self.root)
    #sc = (rootdim.width-200)/rootdim.width
    #self.root.style['transform'] = f'scale({sc})'
    self.root.left = getdim(self.sidebar).width//2
    self.sidebar.left = 0
  else:
    #self.root.style['transform'] = f'scale(1)'
    self.root.left = 0
    self.sidebar.left = -getdim(self.sidebar).width
    
def on_snack(self, key, value, action):
  print(f'{key}, {value}, {action}')
  
def on_popup(self, key, value, action):
  if self.popups:
    rootdim = getdim(self.root)
    scval = max(rootdim.width, rootdim.height)
    sc = (scval-200)/scval
    self.root.style['transform'] = f'scale({sc})'
  else:
    self.root.style['transform'] = f'scale(1)'

async def ui():
  layout = Layout(root=DIV(style=themes['root']), sidebar=DIV(style=themes['sidebar']))
  layout.bind(sidebar_shown=on_sidebar, snacks_mut=on_snack, popups_mut=on_popup)
  layout.root <= BUTTON('testasdfaf fa fdafsdfas asdf sadfsafsadfasd asfsa fsafsa fasd f', style=themes['button'])
  
  while True:
    ev = await aio.select_event(layout.root, 'mousemove')
    if ev.clientX <= 15 and not layout.sidebar_shown:
      layout.sidebar_shown = True
    elif ev.clientX >= getdim(layout.sidebar).width and layout.sidebar_shown:
      layout.sidebar_shown = False
  
  

  

  
  
# ready the aio tasks
async def main():
  await aio.gather(ui())
  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html#event
  '''
  
  def __init__(self, *) -> None:
    self._set = False
    
  async def wait(self) -> None:
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self) -> bool:
    return self._set
    
  def set(self) -> None:
    self._set = True
    
  def clear(self) -> None:
    self._set = False
    
aio.Event = Event


# usefull for binding multiple buttons
def parents_of(_tar):
  parents = []
  base = _tar
  while(base):
    parents.append(base)
    base = base.parentNode
    
  return parents
  
class Dimension:
  def __init__(self, bottom, height, left, right, top, width):
    self.bottom = bottom
    self.height = height
    self.left = left
    self.right = right
    self.top = top
    self.width = width
    self.center = (left + (width/2), top + (height/2))
    
  def __repr__(self):
    return "{" + f"'top': {repr(self.top)}, 'bottom': {repr(self.bottom)}, 'left': {repr(self.left)}, 'right': {repr(self.right)}, 'height': {repr(self.height)}, 'width': {repr(self.width)}, 'center': {repr(self.center)}" + "}"

def getdim(el):
  br = el.getBoundingClientRect()
  out = {
          'bottom': br.bottom,
          'height': br.height,
          'left': br.left,
          'right': br.right,
          'top': br.top,
          'width': br.width
          }
  return Dimension(**out)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        pass

    ev = await aio.select_event(doc, 'keyup keydown')
  
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass
    
class ObservableList(list):
  # Internal class to observe changes inside a native python list.
  def __init__(self, *largs, obj=None, name=''):
    self.name = name
    self.obj = obj
    super().__init__(*largs)
    
  def __setitem__(self, key, value):
    list.__setitem__(self, key, value)
    self.__onmut__(key, value, 'set')

  def __delitem__(self, key):
    value = self.__getitem__(key)
    list.__delitem__(self, key)
    self.__onmut__(key, value, 'del')

  def __iadd__(self, *largs):
    list.__iadd__(self, *largs)
    self.__onmut__(-1, *largs, 'iadd')
    return self

  def __imul__(self, *largs):
    list.__imul__(self, *largs)
    self.__onmut__(-1, *largs, 'imul')
    return self

  def append(self, *largs):
    list.append(self, *largs)
    self.__onmut__(-1, *largs, 'append')

  def remove(self, *largs):
    list.remove(self, *largs)
    self.__onmut__(-1, *largs, 'remove')

  def insert(self, key, *largs):
    list.insert(self, key, *largs)
    self.__onmut__(key, *largs, 'insert')

  def pop(self, key=-1):
    result = list.pop(self, key)
    self.__onmut__(key, result, 'pop')
    return result

  def extend(self, *largs):
    list.extend(self, *largs)
    self.__onmut__(-1, *largs, 'extend')

  def sort(self, *largs):
    list.sort(self, *largs)
    self.__onmut__(-1, None, 'sort')

  def reverse(self, *largs):
    list.reverse(self, *largs)
    self.__onmut__(-1, None, 'reverse')
    
  def clear(self, *largs):
    list.clear(self, *largs)
    self.__onmut__(-1, None, 'clear')
    
  def __onmut__(self, key, value, event):
    if getattr(self.obj, f'on_{self.name}_{event}', None):
      getattr(self.obj, f'on_{self.name}_{event}')(key, value)
    if getattr(self.obj, f'on_{self.name}_mut', None):
      getattr(self.obj, f'on_{self.name}_mut')(key, value, event)
    if f'{self.name}_{event}' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_{event}']:
        cb(self.obj, key, value)
    if f'{self.name}_mut' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_mut']:
        cb(self.obj, key, value, event)
      
class ObservableDict(dict):
  # Internal class to observe changes inside a native python dict.
  def __init__(self, *largs, obj=None, name=''):
    self.name = name
    self.obj = obj
    super().__init__(*largs)
    
  def __setitem__(self, key, value):
    dict.__setitem__(self, key, value)
    self.__onmut__(key, value, 'set')

  def __delitem__(self, key):
    value = self.__getitem__(key)
    dict.__delitem__(self, key)
    self.__onmut__(key, value, 'del')

  def clear(self, *largs):
    dict.clear(self, *largs)
    self.__onmut__(-1, None, 'clear')

  def pop(self, *largs):
    result = dict.pop(self, *largs)
    self.__onmut__(largs[0], result, 'pop')
    return result

  def popitem(self, *largs):
    result = dict.popitem(self, *largs)
    self.__onmut__(-1, result, 'popitem')
    return result

  def setdefault(self, key, default):
    dict.setdefault(self, key, default)
    self.__onmut__(key, default, 'setdefault')

  def update(self, *largs):
    dict.update(self, *largs)
    self.__onmut__(-1, *largs, 'update')
    
  def __onmut__(self, key, value, event):
    if getattr(self.obj, f'on_{self.name}_{event}', None):
      getattr(self.obj, f'on_{self.name}_{event}')(key, value)
    if getattr(self.obj, f'on_{self.name}_mut', None):
      getattr(self.obj, f'on_{self.name}_mut')(key, value, event)
    if f'{self.name}_{event}' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_{event}']:
        cb(self.obj, key, value)
    if f'{self.name}_mut' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_mut']:
        cb(self.obj, key, value, event)
        
class Layout:
  def __init__(self, root=None, sidebar=None, scale_root=False, notifications=[], snacks=[], popups=[]):
    self.root = root
    self.sidebar = sidebar
    self.scale_root = scale_root
    self.notifications = notifications 
    self.snacks = snacks 
    self.popups = popups 
    self.sidebar_shown = False
    self._cbs = {}
    if self.root:
      doc <= self.root
    if self.sidebar:
      doc <= self.sidebar
      
    window.addEventListener('resize', self.resize);
    self.resize()

  def bind(self, **kwargs):
    for k, v in kwargs.items():
      if k not in self._cbs:
        self._cbs[k] = []
      self._cbs[k].append(v)

  def unbind(self, **kwargs):
    for k, v in kwargs.items():
      self._cbs[k].remove(v)
      if not self._cbs[k]:
        del self._cbs[k]

  def dispatch(self, prop, *l, **kw):
    if getattr(self, f'on_{prop}', None):
      getattr(self, f'on_{prop}')(*l, **kw)
    if prop in self._cbs:
      for cb in self._cbs[prop]:
        cb(self, *l, **kw)
        
  def resize(self, *l, **kw):
    self.dispatch('resize')
  
  @property
  def root(self):
    return self._root
  @root.setter
  def root(self, value):
    if not hasattr(self, "_root"): self._root = value
    oldval = self._root
    self._root = value
    if oldval != value: self.dispatch("root", oldval, value)
    
  @property
  def sidebar(self):
    return self._sidebar
  @sidebar.setter
  def sidebar(self, value):
    if not hasattr(self, "_sidebar"): self._sidebar = value
    oldval = self._sidebar
    self._sidebar = value
    if oldval != value: self.dispatch("sidebar", oldval, value)
    
  @property
  def sidebar_shown(self):
    return self._sidebar_shown
  @sidebar_shown.setter
  def sidebar_shown(self, value):
    if not hasattr(self, "_sidebar_shown"): self._sidebar_shown = value
    oldval = self._sidebar_shown
    self._sidebar_shown = value
    if oldval != value: self.dispatch("sidebar_shown", oldval, value)

  @property
  def notifications(self):
    return self._notifications
  @notifications.setter
  def notifications(self, value):
    if not hasattr(self, "_notifications"): self._notifications = value
    oldval = self._notifications
    self._notifications = ObservableList(value, obj=self, name='notifications')
    if oldval != value: self.dispatch("notifications", oldval, value)

  @property
  def snacks(self):
    return self._snacks
  @snacks.setter
  def snacks(self, value):
    if not hasattr(self, "_snacks"): self._snacks = value
    oldval = self._snacks
    self._snacks = ObservableList(value, obj=self, name='snacks')
    if oldval != value: self.dispatch("snacks", oldval, value)

  @property
  def popups(self):
    return self._popups
  @popups.setter
  def popups(self, value):
    if not hasattr(self, "_popups"): self._popups = value
    oldval = self._popups
    self._popups = ObservableList(value, obj=self, name='popups')
    if oldval != value: self.dispatch("popups", oldval, value)
  
  def __repr__(self):
    return "{" + f"'root': {repr(self.root)}, 'sidebar': {repr(self.sidebar)}, 'scale_root': {repr(self.scale_root)}, 'notifications': {repr(self.notifications)}, 'snacks': {repr(self.snacks)}, 'popups': {repr(self.popups)}" + "}"

aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
