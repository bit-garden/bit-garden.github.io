<html>
<title>Testing board</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<style>
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
        color:white;
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}

body{
  background:#121212;
  padding:0px;
  margin:0px;
}

input::-webkit-calendar-picker-indicator {
  display: none;
}
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython_aio.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser import aio
from browser.html import *
# storage is like dictionary
#from browser.local_storage import storage


async def ui():
  snacks.append('hi')
  async with Popup(doc) as p:
    p <= DIV('test')
    await aio.sleep(1)
  


  
  
def on_resize(self, *l, **kw):
  pass
  # do layout changes with this
  
window.addEventListener('resize', on_resize);

  

anim = {'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
        'transition': 'all 0.3s'}

opacities = {0:  0, 1: .05, 2: .07, 3: .08, 4: .09, 6: .11, 8: .12, 12: .14, 16: .15, 24: .16}
elevation = {k:f'rgba(255, 255, 255, {v})' for k, v in opacities.items()}

def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)

themes = {}
themes['root'] = {
  'background': '#121212',
  'color': '#fff',
  'padding': '0px',
  'margin': '0px',
  'left': 0,
  'right': 0,
  'width': '100%',
  'height': '100%',
  'display': 'inline',
  
  'transform-origin': 'center',
  'transform': 'scale(1)',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
  
  'position': 'fixed',
}

themes['sidebar'] = {
  'background': '#282828',
  'color': '#fff',
  'padding': '0px',
  'margin': '0px',
  'width': '300px',
  'top': '0px',
  'left': '-300px',
  'height': '100%',
  'display': 'inline',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
  
  'position': 'fixed',
}

themes['popup'] = {
  'background': '#121212',
  'color': '#fff',
  'padding': '0px',
  'position': 'fixed',
  'display': 'inline',
}

themes['button'] = {
  'background': elevation[1],
  'color': '#fff',
  'display': 'inline',
  'border': 'none',
  'padding': '12px 18px',
  'font-size': '16px',
  'cursor': 'default',
  'outline': 'none'
}

themes['snack'] = {
  'background': '#282828',
  'color': '#fff',
  'display': 'inline',
  'padding': '12px 18px',
  'font-size': '16px',
  
  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  'transition': 'all 0.3s',
  
  'position': 'fixed',
  'left': 0,
  'width': '100%',
  'box-sizing': 'border-box',
}

themes['card'] = {
  'border': 'none',
  'padding': '12px 18px',
  'font-size': '16px',
  'cursor': 'default',
  'color': 'white',
  'background-color': '#282828',
  'outline': 'none'
}
  
# ready the aio tasks
async def main():
  await aio.gather(snackbar(), ui())
  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html
  '''
  
  def __init__(self, *):
    self._set = False
    
  async def wait(self):
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self):
    return self._set
    
  def set(self):
    self._set = True
    
  def clear(self):
    self._set = False
    
aio.Event = Event

class Lock:
  def __init__(self, *):
    self._locked = False

  async def acquire(self):
    while self._locked:
      await aio.sleep(0)
    self._locked = True

  def release(self):
    if not self._locked:
      raise RuntimeError('Lock is already released')
    self._locked = False

  def locked(self):
    return self._locked

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()

aio.Lock = Lock

class Semaphore:
  def __init__(self, value=1, *):
    self._locked = False
    self.count = value
    self.limit = value

  async def acquire(self):
    while self.count < 1:
      await aio.sleep(0)
    self.count -= 1

  def release(self):
    self.count = min(self.count + 1, self.limit)

  def locked(self):
    return self.count == 0

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()
    
aio.Semaphore = Semaphore


# usefull for binding multiple buttons
def parents_of(_tar):
  parents = []
  base = _tar
  while(base):
    parents.append(base)
    base = base.parentNode
    
  return parents
  
class Dimension:
  def __init__(self, bottom, height, left, right, top, width):
    self.bottom = bottom
    self.height = height
    self.left = left
    self.right = right
    self.top = top
    self.width = width
    self.center = (left + (width/2), top + (height/2))
    
  def __repr__(self):
    return "{" + f"'top': {repr(self.top)}, 'bottom': {repr(self.bottom)}, 'left': {repr(self.left)}, 'right': {repr(self.right)}, 'height': {repr(self.height)}, 'width': {repr(self.width)}, 'center': {repr(self.center)}" + "}"

def getdim(el):
  br = el.getBoundingClientRect()
  out = {
          'bottom': br.bottom,
          'height': br.height,
          'left': br.left,
          'right': br.right,
          'top': br.top,
          'width': br.width
          }
  return Dimension(**out)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        pass

    ev = await aio.select_event(doc, 'keyup keydown')
  
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass
    
class Popup:
  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1'
    })

    self.box = DIV(style={
      'position': 'absolute',
      'left': '12.5%',
      'top': '25%',
      'opacity': 0,
      #'width': '75%',
      #'height': '75%',
      'margin': '-16px',
      'transition': 'opacity .4s, top .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'border': 'none',
      #'padding': '12px 18px',
      'font-size': '16px',
      'cursor': 'default',
      'color': 'white',
      'background-color': '#282828',
      'outline': 'none'
    })

    self.frame <= self.box
    center(self.box)
    self.box.top += 250
    
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.frame, 'click')
      if ev.type == 'cancel' or ev.target == self.frame:
        break
        
    # Try to break all awaiting UI.
    for el in self.box.querySelectorAll('*'):
      aio.cancel_event(el)
      
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    #self.box.style['top'] = '25%'
    self.box.top += 250
    await aio.sleep(.4)

    self.frame.remove()
    
  async def __aenter__(self):
    self._root <= self.frame

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1
    #self.box.style['top'] = '12.5%'
    self.box.top -= 250

    aio.run(self._background())
    
    return self.box
    
  async def __aexit__(self, type, value, traceback):
    aio.cancel_event(self.frame)
    
async def snack(content, delay=5):
  # make element
  _snack = DIV(content,
                style=themes['snack'])
  # attach to doc
  doc <= _snack
  _snack.style['bottom'] = -getdim(_snack).height
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = 0
  # sleep for 5
  await aio.sleep(.3+delay)
  # update pos
  _snack.style['bottom'] = -getdim(_snack).height
  await aio.sleep(.3)
  _snack.remove()
  # return

snacks = []
async def snackbar():
  while True:
    while snacks:
      val = snacks.pop(0)
      await snack(val)
      
    await aio.sleep(0)

aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
