<html>
<title>Testing board</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser.html import *
from types import FunctionType as function # for enforce
import time # for debounce and throttle with statements
# storage is like dictionary
#from browser.local_storage import storage

async def ui():
  window.snacks.append('Hello world')
  async with Popup(doc) as p:
    await aio.sleep(2)

  
  
# ready the aio tasks
async def main():
  await aio.gather(snackbar(), ui(), keybind(), sidebar())
  

  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html#event
  '''
  
  def __init__(self, *) -> None:
    self._set = False
    
  async def wait(self) -> None:
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self) -> bool:
    return self._set
    
  def set(self) -> None:
    self._set = True
    
  def clear(self) -> None:
    self._set = False
    
aio.Event = Event


# usefull for binding multiple buttons
def parents_of(_tar):
  parents = []
  base = _tar
  while(base):
    parents.append(base)
    base = base.parentNode
    
  return parents

  
# --- other UI stuff

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple(*_):
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s', 'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple(*_):
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple(*_):
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple(*_):
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)

def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

def SWITCH(text: str , state: bool = False, Type: str = 'checkbox', Class: str = 'switch', name: str = '') -> LABEL:
  return DIV(LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'}),
    style={'width':'100%'}
  ), style={'display':'flex', 'align-items': 'center'})
  
async def popup(content):
  frame = DIV(Class='darken', style={
    'background': 'rgba(0, 0, 0, 0)',
    'transition': 'background .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    'width': '100%',
    'height': '100%',
    'position': 'fixed',
    'top': '0px',
    'left': '0px',
    'z-index': '1'
  })

  box = DIV(content, Class='card', style={
    'position': 'absolute',
    'left': '12.5%',
    'top': '25%',
    'opacity': 0,
    'width': '75%',
    'height': '75%',
    'margin': '-16px',
    'transition': 'opacity .4s, top .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  })

  frame <= box

  doc <= frame

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.style['top'] = '12.5%'

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.style['top'] = '25%'
  await aio.sleep(.4)

  frame.remove()
  
class Popup:
  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1'
    })

    self.box = DIV(Class='card', style={
      'position': 'absolute',
      'left': '12.5%',
      'top': '25%',
      'opacity': 0,
      'width': '75%',
      'height': '75%',
      'margin': '-16px',
      'transition': 'opacity .4s, top .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    })

    self.frame <= self.box
    
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.frame, 'click')
      if ev.type == 'cancel' or ev.target == self.frame:
        break
        
    # Try to break all awaiting UI.
    for el in self.box.querySelectorAll('*'):
      aio.cancel_event(el)
      
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    self.box.style['top'] = '25%'
    await aio.sleep(.4)

    self.frame.remove()
    
  async def __aenter__(self):
    self._root <= self.frame

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1
    self.box.style['top'] = '12.5%'

    aio.run(self._background())
    
    return self.box
    
  async def __aexit__(self, type, value, traceback):
    aio.cancel_event(self.frame)
    
# General with El that you can be used like with Popup
class El:
  def __init__(self, _root, el):
    self._root = _root
    self.el = el
        
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.el, '')
      if ev.type == 'cancel':
        break
        
    # Try to break all awaiting UI.
    for el in self.el.querySelectorAll('*'):
      aio.cancel_event(el)

    self.el.remove()
    
  def __enter__(self):
    self._root <= self.el

    aio.run(self._background())
    
    return self.el
    
  def __exit__(self, type, value, traceback):
    aio.cancel_event(self.el)
  
async def snack(content, delay=5):
  # make element
  _snack = DIV(content, Class='card',
                style={
                  'position': 'fixed',
                  'z-index': '2',
                  'bottom': '-16px',
                  'left': '50%',
                  'transform': 'translate(-50%, 100%)',
                  'transition': 'transform .4s, bottom .4s',
                  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
                })
  # attach to doc
  doc <= _snack
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = '16px'
  _snack.style['transform'] = 'translate(-50%, 0%)'
  # sleep for 5
  await aio.sleep(.4+delay)
  # update pos
  _snack.style['bottom'] = '-16px'
  _snack.style['transform'] = 'translate(-50%, 100%)'
  await aio.sleep(.4)
  _snack.remove()
  # return

async def snackbar():
  window.snacks = []
  while True:
    while window.snacks:
      val = window.snacks.pop(0)
      await snack(val)
      
    await aio.sleep(0)
    
async def sidebar() -> None:
  hidden = 'card main_sidebar hidden'
  shown = 'card main_sidebar shown'

  with El(doc, SPAN(Class='card main_sidebar hidden')) as box:
    # do stuff
    
    await aio.sleep(.05)
    box.setAttribute('class', shown)
    await aio.sleep(.8)
    box.setAttribute('class', hidden)
    
    watched_events = 'mouseover mouseleave'
    ev = await aio.select_event(box, watched_events)
    while ev.type != 'cancel':
      if ev.type == 'mouseover':
        if ev.target==box:
          box.setAttribute('class', shown)
      elif ev.type == 'mouseleave':
        if ev.target==box:
          box.setAttribute('class', hidden)

      ev = await aio.select_event(box, watched_events)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        if ev.key == 'Escape':
          tar = doc.querySelectorAll('.darken')
          if len(tar):
            aio.cancel_event(tar[-1])

    ev = await aio.select_event(doc, 'keyup keydown')
  
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass

    
class Debounce:
  def __init__(self, fun, limit):
    self.dat = []
    self.limit = limit
    self.last_ran = time.time()
    self.command = fun
    
  def _deferred_fun(self, *l, **kw):
    self.dat.append((l, kw))
    self.last_ran = time.time()
    
  async def db_task(self, handle):
    while handle['running'] == True:
      if self.dat and self.last_ran + self.limit < time.time():
        self.command(self.dat)
        self.dat = []
      await aio.sleep(0)
  
  def __enter__(self):
    self.last_ran = time.time()
    self.task_handle = {'running': True}
    aio.run(self.db_task(self.task_handle))
    
    return self._deferred_fun
    
  def __exit__(self, type, value, traceback):
    # flush command with data
    if self.dat:
      self.command(self.dat)
      self.dat = []
    self.task_handle['running'] = False
    
    
class Throttle:
  def __init__(self, fun, limit):
    self.dat = []
    self.limit = limit
    self.last_ran = time.time()
    self.command = fun
    
  def _deferred_fun(self, *l, **kw):
    if not self.dat:
      self.last_ran = time.time()
    self.dat.append((l, kw))
    
  async def db_task(self, handle):
    while handle['running'] == True:
      if self.dat and self.last_ran + self.limit < time.time():
        self.command(self.dat)
        self.dat = []
      await aio.sleep(0)
  
  def __enter__(self):
    self.last_ran = time.time()
    self.task_handle = {'running': True}
    aio.run(self.db_task(self.task_handle))
    
    return self._deferred_fun
    
  def __exit__(self, type, value, traceback):
    # flush command with data
    if self.dat:
      self.command(self.dat)
      self.dat = []
    self.task_handle['running'] = False




aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
