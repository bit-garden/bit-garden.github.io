<html>
<title>Testing board</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
</style>
<body onload="brython({indexedDB: true})"></body>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">
from browser import document as doc
from browser import window
from browser.html import *
# storage is like dictionary
#from browser.local_storage import storage

async def ui():
  window.snacks.append('Hello world')



  
  
# ready the aio tasks
async def main():
  await aio.gather(snackbar(), ui())
  

  
# --- would be imports
  
# small hacks to be more asyncio like
from browser import aio

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

# --- debounce and throttle
import time

# do not run first pass
# restart timer each call, within wait
# only call last instance
def debounce(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """
  def decorator(fn):
    def debounced(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        if cache is not None:
          tc = cache[:]
          cache.clear()
          fn(*args, cache=tc, **kwargs)
        else:
          fn(*args, **kwargs)
      try:
        window.clearTimeout(debounced.t)
      except(AttributeError):
        pass
      debounced.t = window.setTimeout(call_it, int(wait*1000))
      #debounced.t.start()
    return debounced
  return decorator


# run first pass
# only call last instance
def throttle(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """

  def decorator(fn):
    def throttled(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        throttled._timer = None
        throttled._last_call = time.time()
        if cache is not None:
          tc = cache[:]
          cache.clear()
          return fn(*args, cache=tc, **kwargs)
        else:
          return fn(*args, **kwargs)

      time_since_last_call = time.time() - throttled._last_call
      if time_since_last_call >= wait:
        return call_it()

      if throttled._timer is None:
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()
      else:
        window.clearTimeout(throttled._timer)
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()

    throttled._timer = None
    throttled._last_call = 0

    return throttled

  return decorator
  
# --- other UI stuff

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple():
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s'}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple():
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple():
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple():
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)

def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

def SWITCH(text:str , state: bool = False, Type: str = 'checkbox', Class: str = 'switch', name: str = '') -> LABEL:
  return LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'})
  )
  
async def popup(content):
  frame = DIV(Class='darken', style={
    'background': 'rgba(0, 0, 0, 0)',
    'transition': 'background .4s',
    'width': '100%',
    'height': '100%',
    'position': 'fixed',
    'top': '0px',
    'left': '0px',
    'z-index': '1'
  })

  box = DIV(content, Class='card', style={
    'position': 'absolute',
    'left': '12.5%',
    'top': '25%',
    'opacity': 0,
    'width': '75%',
    'height': '75%',
    'margin': '-16px',
    'transition': 'opacity .4s, top .4s'
  })

  frame <= box

  doc <= frame

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.style['top'] = '12.5%'

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.style['top'] = '25%'
  await aio.sleep(.4)

  frame.remove()
  
async def snack(content, delay=5):
  # make element
  _snack = DIV(content, Class='card',
                style={
                  'position': 'fixed',
                  'z-index': '2',
                  'bottom': '-16px',
                  'left': '50%',
                  'transform': 'translate(-50%, 100%)',
                  'transition': 'transform .4s, bottom .4s'
                })
  # attach to doc
  doc <= _snack
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = '16px'
  _snack.style['transform'] = 'translate(-50%, 0%)'
  # sleep for 5
  await aio.sleep(.4+delay)
  # update pos
  _snack.style['bottom'] = '-16px'
  _snack.style['transform'] = 'translate(-50%, 100%)'
  await aio.sleep(.4)
  _snack.remove()
  # return

async def snackbar():
  window.snacks = []
  while True:
    while window.snacks:
      val = window.snacks.pop(0)
      await snack(val)
      
    await aio.sleep(0)
  

# --- enforce and table

# --- Literal type backport from 3.8 version
# will be used for sanity checking specific posibilities

from typing import *
from typing import _GenericAlias
import typing 

class _LiteralForm(typing._SpecialForm, _root=True):

  def __repr__(self):
    return 'typing_extensions.' + self._name

  def __getitem__(self, parameters):
    return _GenericAlias(self, parameters)

Literal = _LiteralForm('Literal',
            doc="""A type that can be used to indicate to type checkers
            that the corresponding value has a value literally equivalent
            to the provided parameter. For example:
              var: Literal[4] = 4
            The type checker understands that 'var' is literally equal to
            the value 4 and no other value.
            Literal[...] cannot be subclassed. There is no runtime
            checking verifying that the parameter is actually a value
            instead of a type.""")


from dataclasses import dataclass, field

import inspect
import typing
from contextlib import suppress
from functools import wraps

def validate_type(name, type_hint, value):
  """Validates value against type_hint.
  
  This doesn't check in depth for List, Set and so on.
  This additionally treats strings as Any so future typing can be done.
  """
  
  if not isinstance(type_hint, typing._SpecialForm):
    # No check for typing.Any, typing.Union, typing.ClassVar (without parameters)
    is_literal = False # for literal checking
    try:
      actual_type = type_hint.__origin__
    except AttributeError:
      actual_type = type_hint
    if actual_type == Literal:
      is_literal = True
    if isinstance(actual_type, typing._SpecialForm):
      # case of typing.Union[...] or typing.ClassVar[...]
      actual_type = type_hint.__args__

    if type(actual_type) == str:
      return
      
    if is_literal:
      if value not in actual_type:
        raise TypeError('Unexpected value for \'{}\' (expected {} but found {})'.format(name, type_hint, value))

    if not isinstance(value, actual_type):
      raise TypeError('Unexpected type for \'{}\' (expected {} but found {})'.format(name, type_hint, type(value)))

def bind(self, **kw):
  """Bind callbacks to properties."""
  for prop, fun in kw.items():
    if prop not in self._callbacks:
      self._callbacks[prop] = []
    self._callbacks[prop].append(fun)
    
def unbind(self, **kw):
  """Unbind callbacks to properties."""
  for prop, fun in kw.items():
    self._callbacks[prop].remove(fun)
    if not self._callbacks[prop]:
      del self._callbacks[prop]
      
class On_attr:
  """Customer attribute to delegate changes to a property."""
  def __init__(self, type, name, bindable=False):
    self.type = type
    self.name = name
    self.bindable = bindable # for faster check if _callbacks is used

  # set name not working in current brython version

  def __get__(self, instance, owner):
    if not instance: return self
    return instance.__dict__[self.name]

  def __delete__(self, instance):
    del instance.__dict__[self.name]

  def __set__(self, instance, value):
    """Validate type, on_prop_vali, on_prop, then _callbacks."""
    validate_type(self.name, self.type, value)

    curval = instance.__dict__.get(self.name, self)

    instance.__dict__[self.name] = value

    if curval != self:
      if value != curval:
        on_prop = getattr(instance, f'on_{self.name}', None)
        if on_prop:
          on_prop(curval, value)
        if self.bindable:
          if self.name in instance._callbacks:
            for i in instance._callbacks[self.name]:
              i(instance, curval, value)


def enforce_types(callable):
  """Decorator to bind On_attr on annotated properties.
  
  Also attaches bind/unbind if _callbacks dictionary is annotated.
  
  Also checks incoming annotated parameters for __init__ or decorated functions.
  """
  
  spec = inspect.getfullargspec(callable)
  annos = spec.annotations
  annos.pop('return')

  def check_types(*args, **kwargs):
    parameters = dict(zip(spec.args, args))
    parameters.update(kwargs)
    for name, value in parameters.items():
      with suppress(KeyError): # Assume un-annotated parameters can be any type
        type_hint = spec.annotations[name]
        validate_type(name, type_hint, value)

  def decorate(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
      check_types(*args, **kwargs)
      return func(*args, **kwargs)
    return wrapper

  if inspect.isclass(callable):
    callable.__init__ = decorate(callable.__init__)
    bindable = False
    if '_callbacks' in annos:
      bindable = True
      callable.bind = bind
      callable.unbind = unbind
    for k, v in annos.items():
      setattr(callable, k, On_attr(v, k, bindable))
    return callable

  return decorate(callable)


def strip_dict(_dict):
  """Strip out keys with leading _.
  
  This seams more readable to the eye for simply hiding properties compared to field(...)
  """
  
  return {k: v for k, v in _dict.items() if not k.startswith('_')}



def ig(obj, prop):
  return [i[prop] for i in obj]

def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out


base_table_str = '''
from typing import *
from dataclasses import field

@enforce_types
@dataclass
class R:
  _callbacks: dict = field(default_factory=dict)
  _sub_table: str = ''
  pass

  def __getitem__(self, key):
    return self.__dict__[key]

  def __setitem__(self, key, value):
    return setattr(self, key, value)

  def __repr__(self):
    return str(strip_dict(self.__dict__))
  
locals()['R'] = R
'''

def trycast(d, anno):
  for k, v in d.items():
    try:
      validate_type(k, anno[k], v)
    except:
      d[k] = anno[k](v)


# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in itertools.groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out


class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    prop_str = ''
    prop_dict = {}

    row_props = self.code.split('\n\n')[0]
    for i in row_props.splitlines():
      if ':' in i:
        prop_dict[i.split(':')[0]] = i

    for h in self.headers:
      if h not in prop_dict:
        prop_str += f"\n  {h}: Any = ''"
      else:
        prop_str += f"\n  {prop_dict[h]}"

    loc = {}
    exec(base_table_str.replace('pass', prop_str), globals(), loc)

    self.Row = loc['R']
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        _d = {k:v for k, v in zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]) if v != ''}
        trycast(_d, self.Row.__annotations__)
        self.table.append(self.Row(**_d))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n' 
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}'
    return out


  def run_code(t):
    exec(t.code)

  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}


aio.run(main())

</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
