<html>
<title>Testing board</title>
<link rel="shortcut icon" href="rabbit.png">
<link rel="stylesheet" type="text/css" href="lib/theme.css">
<style>
</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

# small hacks to be more asyncio like
from browser import aio, window

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    #name = c.__name__ 
    #if name not in counts:
    #  counts[name] = 0
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'
  triggered = None

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

from browser import document as doc
from browser.html import *

# storage is like dictionary
#from browser.local_storage import storage


async def main():
  doc <= BUTTON('test', Class='card ripple')
  doc <= BUTTON('test', Class='button ripple')
  doc <= INPUT('test', Class='card input')
  doc <= INPUT('test', Class='button input')
  doc <= INPUT(Class='card input', Type='text', list='browsers')
  dropdown_options = DATALIST(Id='browsers')
  for op in ['apple', 'banana', 'cucumber']:
    dropdown_options <= OPTION(op)
  doc <= dropdown_options
  
  doc <= DIV(make_toggle('test'), style={'width':'200px'})
  doc <= DIV(make_toggle('test', Class='card'), style={'width':'200px'})
  doc <= BUTTON('test', Class='card red_card ripple red_ripple')
  doc <= BUTTON('test', Class='card green_card ripple green_ripple')
  doc <= BUTTON('test', Class='card blue_card ripple blue_ripple')
  doc <= BUTTON('test', Class='card purple_card ripple purple_ripple')
  doc <= BUTTON('test', Class='card orange_card ripple orange_ripple')


def toggle_onoff(ev):
  classes = ev.currentTarget.className.split(' ')
  if 'check-off' in classes:
    classes.remove('check-off')
    classes.append('check-on')
    ev.currentTarget.state='on'
  else:
    classes.remove('check-on')
    classes.append('check-off')
    ev.currentTarget.state='off'
  ev.currentTarget.className = ' '.join(classes)
  
window.toggle_onoff = toggle_onoff

def make_toggle(text='test', _on='ON', _off='OFF', state='off', on_state=None, Class='button'):
  b = BUTTON(
          DIV(text, Class='label') + 
          DIV(_on, Class='on') +
          DIV(_off, Class='off'),
        Class=f'{Class} ripple check-{state}')
  b.bind('click', toggle_onoff)
  if on_state:
    b.bind('click', on_state)
  b.state=state
  return b

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple():
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'background 0.4s'}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple():
    hover_sty = {'transition': 'background 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple():
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'background 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple():
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)


aio.run(main())

</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
      	  alert(msg)
	}
      }
      
      console.log=_logger
      console.error=_logger
      console.warning=_logger
      </script>
</html>
