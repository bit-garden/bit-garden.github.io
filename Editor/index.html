<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}
    
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

.CodeMirror, .CodeMirror-gutters{background:#111111 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}
 
 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:14px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;  
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: #111111;
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888
  }
  .CodeMirror-activeline-gutter > .CodeMirror-linenumber {
	    color: white !important;
	      width: auto !important;
	    }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }
  

input::-webkit-calendar-picker-indicator {
  display: none;
}
  
/* Ripple effect */
.ripple {
  background-position: center;
  transition: background 0.4s;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
}
/* hover color need to match */
.ripple:hover {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
.ripple:focus {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
/* pulse color */
.ripple:active {
  background-color: grey;
  background-size: 100%;
  transition: background 0s;
}

/* card style */
.card {
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.red_ripple:hover {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
.red_ripple:focus {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
/* pulse color */
.red_ripple:active {
  background-color: red;
  background-size: 100%;
  transition: background 0s;
}
.red_card{
  background-color: #660000;
}

.green_ripple:hover {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
.green_ripple:focus {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
/* pulse color */
.green_ripple:active {
  background-color: green;
  background-size: 100%;
  transition: background 0s;
}
.green_card{
  background-color: #006600;
}

.blue_ripple:hover {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
.blue_ripple:focus {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
/* pulse color */
.blue_ripple:active {
  background-color: blue;
  background-size: 100%;
  transition: background 0s;
}
.blue_card{
  background-color: #000066;
}

.purple_ripple:hover {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
.purple_ripple:focus {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
/* pulse color */
.purple_ripple:active {
  background-color: purple;
  background-size: 100%;
  transition: background 0s;
}
.purple_card{
  background-color: #660066;
}

.orange_ripple:hover {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
.orange_ripple:focus {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
/* pulse color */
.orange_ripple:active {
  background-color: orange;
  background-size: 100%;
  transition: background 0s;
}
.orange_card{
  background-color: #664400;
}

.button{
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  outline: none;
  background-color:rgba(71,71,71,0);
}

/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  border-radius: 3px;
  padding: 8px 8px;
  margin:6px;
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
  font-family: Mono !important;
}

.input{
  border-bottom: rgba(16,75,121,1) solid 2px;
  padding: 12px 18px 10px 18px;
  transition: border .4s;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
}
.input:focus, .input:hover{
  border-bottom: rgba(33,150,243,1) solid 2px;
}

/* checkbox */

input.switch{
  opacity: 0;
  height:14px;
  width:0px;
}

input.switch+div{
  background:rgba(128,128,128,.33);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  display:inline-block;
  overflow:visible;
  border-radius:12px;
  margin:6px;
  width:36px;
}

input.switch:checked+div div.thumb{
  left:24px;
  background:rgba(33,150,243,1);
}

input.switch:focus+div,
input.switch:focus+div div.thumb{
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.2);
  outline:none;
  box-shadow: 0 0px 8px rgba(33,150,243,1);
}

input.switch+div div.thumb{
  content:'off';
  height:24px;
  transition:all .2s;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
  width:24px;
  background:rgba(16,75,121,1);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  position:relative;
  left:0px;
  margin:-6px;
  border-radius:12px;
}

/* radio */

input.radio{
  opacity: 0;
  height:14px;
  width:0px;
}

input.radio+div{
  background:rgba(128,128,128,.33);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  display:inline-block;
  overflow:visible;
  border-radius:18px;
  width:12px;
  height:12px;
  padding:6px;
  transition:all .2s;
}

input.radio:checked+div div.thumb{
  background:rgba(33,150,243,1);
  width:16px;
  height:16px;
}

input.radio:checked+div{
  padding:4px;
  height:16px;
  width:16px;
}

input.radio:focus+div,
input.radio:focus+div div.thumb{
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.2);
  outline:none;
  box-shadow: 0 0px 8px rgba(33,150,243,1);
}

input.radio+div div.thumb{
  content:'off';
  height:12px;
  transition:all .2s;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
  width:12px;
  background:rgba(16,75,121,1);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  border-radius:12px;
}

.fab {
  border: none;
  border-radius: 999px;
  padding: 18px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.fab-small {
  border: none;
  border-radius: 999px;
  padding: 12px 12px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.main_sidebar{
  overflow: auto;
  background: #222222;
}

.main_sidebar > div.card{
  margin-bottom: 8px;
  background: #333333;
}

.main_sidebar.hidden{
  position: absolute;
  bottom: 0px;
  left: -290px;
  width: 300px;
  height: 100%;
  display: inline;
  box-sizing: border-box;
  transition: all .4s;
  opacity: 0;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
}
  
.main_sidebar.shown{
  position: absolute;
  bottom: 0px;
  left: 0px;
  width: 300px;
  height: 100%;
  display: inline;
  box-sizing: border-box;
  transition: all .3s;
  opacity: 1;
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
}
  
</style>
<script>
// Returns if a value is a string
function isString (value) {
return typeof value === 'string' || value instanceof String;
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};



	  CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
{regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	  
{regex: /#(\S|\s\s).*$/, token: "comments"}, // darklights comments
{regex: /#(\s\S.*|\s*$)/, token: "deco"}, // highlights comments
	  
{regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
{regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
//{regex: /[-+]?[0-9]*\.?[0-9]+/, token: "nums"}, // numbers
//{regex: /(__)(.*?)\1/, token: "under"},
//{regex: /(~~)(.*?)\1/, token: "strike"},
{regex: / \|( |$)/, token: "nums"},
{regex: /^\s*---+/, token: "nums", sol:true},
{regex: /---+$/, token: "nums"},
	  
  ]
});
	  CodeMirror.defineSimpleMode("simplermode", {
  // The start state contains the rules that are intially used
  start: [
{regex: /(\#|\/\/).*$/, token: "comments"}, // darklight comments
  ]
});
</script>
<body onload="brython({indexedDB: false})"></body>
<textarea class='editbox'></textarea>
</body>
<script>
//CodeMirror.Vim.unmap(';')
CodeMirror.Vim.unmap(',')
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map(',/', ':js timediff()', 'normal')
CodeMirror.Vim.map('fd', '<Esc>', 'insert')
CodeMirror.Vim.map('vb','<Esc>T|<C-v>t|','insert')
CodeMirror.Vim.map(',/', '<Esc>/i', 'insert')
CodeMirror.Vim.map(',?', '<Esc>?i', 'insert')
CodeMirror.Vim.map(',a', '<Esc>A', 'insert')
CodeMirror.Vim.map(',i', '<Esc>I', 'insert')
CodeMirror.Vim.map(',l','<Esc>f|la','insert')
CodeMirror.Vim.map(',h','<Esc>2F|la','insert')
CodeMirror.Vim.map(',j','<Esc>F|lja','insert')
CodeMirror.Vim.map(',k','<Esc>F|lka','insert')
CodeMirror.Vim.map(';;','<Esc>:','insert')
CodeMirror.Vim.map('cw','<Esc>lciwi','insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')
CodeMirror.Vim.map(',l','f|ll','normal')
CodeMirror.Vim.map(',h','2F|ll','normal')
CodeMirror.Vim.map(',j','F|ljl','normal')
CodeMirror.Vim.map(',k','F|lkl','normal')
//CodeMirror.Vim.map(';;',':','normal')
CodeMirror.Vim.map(',<Space>', ':noh', 'normal')
//CodeMirror.Vim.map(',e', '@e', 'normal') //Short mapping to e macro
//more maps?
//CodeMirror.Vim.map('<C-t>', "mzyy'tP`zdd", 'normal')
//CodeMirror.Vim.map('Y', '"Ay', 'visual')

//CodeMirror.Vim.map('zv', ":vdo ?---|jmx|/---|kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zv', "[-jmx]-kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zb', ":vblock", 'normal')

CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|l', 'normal')
CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|a', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|l', 'normal')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|a', 'insert')
CodeMirror.Vim.map(',o', ':vdo oi', 'insert')
CodeMirror.Vim.map(',O', ':vdo Oi', 'insert')
CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')
CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')
CodeMirror.Vim.map(',y', ':js sort_by()', 'visual')
CodeMirror.Vim.map(',,', ':align_by', 'visual')
CodeMirror.Vim.map(',;', ':align_by_colin', 'visual')
CodeMirror.Vim.map(',=', ':align_by_equals', 'visual')
CodeMirror.Vim.map(',\\', ':align_by_pipe', 'visual')

CodeMirror.Vim.map(']-', ':vdo :js move_to("---")|_', 'normal')
CodeMirror.Vim.map('[-', ':vdo :js move_to("---", false)|_', 'normal')

//CodeMirror.Vim.map("''", ':vdo :js put(\'"\')|a', 'insert')

//CodeMirror.Vim.map('cb', ':vdo :js put("[\'")|a', 'insert')
//CodeMirror.Vim.map('bc', ':vdo :js put("\']")|a', 'insert')

//CodeMirror.Vim.map('..', ':DoubleD', 'insert')

CodeMirror.Vim.map('gt', ':vdo /--- Cal|/\\[TODAY\\]|zb', 'normal')

CodeMirror.Vim.map(',r', ':js alignRight()', 'visual')
CodeMirror.Vim.map(',l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map(',c', ':js alignCenter()', 'visual')

CodeMirror.Vim.unmap('s', 'visual')
CodeMirror.Vim.map("s'" , ":js surround(\"'\", \"'\")", 'visual')
CodeMirror.Vim.map('s"' , ":js surround('\"' , '\"')" , 'visual')
CodeMirror.Vim.map("s\\", ":js surround('|'  , '|')"  , 'visual')

CodeMirror.Vim.map("sd", ":js surround(\"['\"  , \"']\")"  , 'visual')
CodeMirror.Vim.map("s[", ":js surround('['  , ']')"  , 'visual')
CodeMirror.Vim.map("s{", ":js surround('{'  , '}')"  , 'visual')
CodeMirror.Vim.map("s(", ":js surround('('  , ')')"  , 'visual')

CodeMirror.Vim.map("s_", ":js surround('_'  , '_')"  , 'visual')



  editbox = document.querySelector('.editbox')
  if ('data' in localStorage){
    editbox.value = localStorage.getItem('data')
  }
  cm_editbox = CodeMirror.fromTextArea(editbox,{
              'matchBrackets':     true,
              'autoCloseBrackets': false,
              'lineNumbers':       false,
              "mode":              'simplemode',
              "theme":             "material",
              'tabSize':           2,
              'styleActiveLine':   true,
              'keyMap':            'vim',
              'extraKeys':         {"Ctrl-Space": "autocomplete"}
   })
   function tab_to_space(cm){
    cm.execCommand("insertSoftTab")
  }
  cm_editbox.addKeyMap({'Ctrl-C': false})
  cm_editbox.addKeyMap({'Tab': tab_to_space})
  
  function on_change(cm, _change){
    cm_editbox.save()
    localStorage.setItem('data', editbox.value);
  }
  
  cm_editbox.on('change',on_change)
  
  function ac_hint(cm){
    cm.showHint({'hint': CodeMirror.hint.anyword})
  }
  CodeMirror.commands.autocomplete = ac_hint
  
  function runjs(cm, params){
    eval(params.argString)
  }
  
  CodeMirror.Vim.defineEx("js", null, runjs)

function put(_text, pre=false){
  reg('z', _text)
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  if (!pre)
    vdo('l"zp')
  else
    vdo('l"zP')
}

function _surround(i, l, r){
  if (i.trim().length > 0){
    return l + i + r
  }else{
    return i
  }
}

function surround(l = "'", r = "'"){
vdo('gvy')
yanked = reg('"').split('\n')
yanked = yanked.map((i)=> _surround(i, l, r))
reg('"', yanked.join('\n'))
//reg('"', l + reg('"').trim() + r)
vdo('gvp')
}

function key(_key){
  CodeMirror.Vim.handleKey(cm_editbox, _key, 'macro')
}
CodeMirror.Vim.defineEx("key", null, key)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}
  
function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}
//sort natural order in tables
function itemgetter(keys){
    return function test2(_dict){
        out = ''
        keys.forEach((e)=>out+=_dict[e]+'|')
        return out
    }
}
function sort_dicts(_dicts, _keys){
  keys = itemgetter(_keys)
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  return _dicts.sort((a, b) => collator.compare(keys(a), keys(b)))
}

//testing char skipping, not space skipping exclusively. 
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}

function toclip(dat){
navigator.clipboard.writeText(dat.toString())
  .then(() => {
    console.log(dat.toString() + ' to clip.');
  })
  .catch(err => {
    // This can happen if the user denies clipboard permissions:
    console.error('Could not copy text: ', err);
  });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0
  
  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replaceAll('<bar>', '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)

function vblock(cm, params){
  vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

//function runclip(cm, params){
//  sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0].trim()
//  sel.split('\n').forEach((i)=>{
//    CodeMirror.Vim.handleEx(cm_editbox, i)
//  })
//}
//CodeMirror.Vim.defineEx("runclip", null, runclip)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function timediff(){
vdo('Vy') // > @"
sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
d = new Date()
newtime = [d.getMonth()+1,d.getDate(),d.getFullYear()].join('/') + ' ' + [d.getHours(), d.getMinutes()].join(':')
sel = sel.replace('%c', newtime)

if(sel.includes('%d')){
  vdo('kyy')
  var re_time = /\d+\/\d+\/\d+\ \d+:\d+/
  sel2 = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  last_time = sel2.match(re_time)
  last_time = new Date(last_time)
  diffmin = parseInt((d - last_time) / (1000 * 60)); 
  sel = sel.replace('%d', diffmin)
}
// for days , parseInt((date2 - date1) / (1000 * 60 * 60 * 24)); 
CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel
vdo('gvp') // < @"
}

function make_popup(_dat, _height = '10em'){
  cm_editbox.openDialog('<textarea style="font-family: Mono; white-space: pre;  overflow: auto; outline: none;border:none; background:none; color:white;width:100%; height:'+_height+'">'+_dat+'</textarea><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}

function make_simple_popup(_dat){
  cm_editbox.openDialog('<p style="background:none; color:white;width:100%; height:10em">'+_dat.replaceAll('\n','<br>')+'</p><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}


function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}

function DoubleD(cm, params){
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  if (line.substring(startch+1, startch+3) == "']"){
    vdo('lla')
  }else{
    put("['']")
    vdo('ha')
  }
  //vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  //CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('DoubleD', null, DoubleD)

function DoubleTap(cm, params){
  var pairs = [['"', '"'], ["'", "'"], ['(', ')'], ['[', ']'], ['{', '}']]
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  var character = params.argString.trim()
  var cur_character = line.substring(startch, startch+1)
  pairs.forEach((pair) => {
    if (character == cur_character && character == pair[1] && !line.substring(startch-1, startch).match(/\\/)){
      vdo('la')
    //}else if (character == pair[0] && character == "'" && line.substring(startch-1, startch).match(/\w/)){
    //  put(pair[0])
    //  vdo('la')
    }else if (character == pair[0]){
      put(pair[0])
      put(pair[1])
      vdo('a')
    }else if (character == pair[1]){
      put(pair[1])
      vdo('la')
    }
  })
}
CodeMirror.Vim.defineEx('DoubleTap', null, DoubleTap)

CodeMirror.Vim.map("'", ":DoubleTap '", 'insert')
CodeMirror.Vim.map('"', ':DoubleTap "', 'insert')
CodeMirror.Vim.map("[", ":DoubleTap [", 'insert')
CodeMirror.Vim.map("]", ":DoubleTap ]", 'insert')
CodeMirror.Vim.map("(", ":DoubleTap (", 'insert')
CodeMirror.Vim.map(")", ":DoubleTap )", 'insert')
CodeMirror.Vim.map("{", ":DoubleTap {", 'insert')
CodeMirror.Vim.map("}", ":DoubleTap }", 'insert')
//CodeMirror.Vim.map("''", ":vdo :js put(\"''\")|i", 'insert')
//CodeMirror.Vim.map("((", ":vdo :js put(\"()\")|i", 'insert')
//CodeMirror.Vim.map("[[", ":vdo :js put(\"[]\")|i", 'insert')
//CodeMirror.Vim.map("{{", ":vdo :js put(\"{}\")|i", 'insert')
//CodeMirror.Vim.map('""', ':vdo :js put(\'""\')|i', 'insert')
//CodeMirror.Vim.map("<<", ":vdo :js put(\"<>\")|i", 'insert')

function kpos(cm, params){
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function notes(cm, params){
  make_popup(`^e in normal insert visual
finds between _table_ markers(or visual) and runs as table

,\\ visual
aligns by |
,, ,= visual 
aligns by , or = respectively
,; visual
aligns by :

^j ^k normal
goes up or down to non whitespace character

^y normal visual
sort visual or vip

,y visualblock
sort by visualblock

,l ,c ,r visualblock
align left, center, right

vw insert
select word, then yank word

cw insert
change word or next word

s' s" s[ s\\ s{ s( s_ visual
surrounds by ' " [] | {} () _

,a insert
escape A

,I insert
escape I

vb insert
select between |

zv normal
select between ---

zb normal
select in table section

kj insert normal
auto complete based on file contents

jk fd insert
escape 

,/ ,? insert
search forward or backward and drop back to insert

,h ,j ,k ,l insert normal
jump between | and - respectivly for tables

;; insert normal
command line

,<space>
stop search highlight

]- [- normal
jump to ---

'' insert
place "

# re stuff
(,)(?=(?:[^"]|"[^"]*")*$) # csv: capture unencolsed ',' chars
(\\#|\\/\\/)(\\S|\\s\\s).*$ # Big comment
(\\#|\\/\\/)\\s.*$ # Small comments
\\w?"([^"\\\\]|\\\\.)*("|$) # Double quotes
(?![ \\{\\(\\[])\\w?'([^'\\\\]|\\\\.)*'\\s*(?=[\\)\\],:\\}.$ ])/ # Single quote code
(^| )'([^']|'\\w)*'( |$) # Single quote prose

# non complete calendar events
\| (?!-)\S[^\|]+

# find by surrounding 
(__)(.*?)\\1

# shuffle search
/(?:([dameagrirnbne])(?!.*?\\1)){13}/.exec($0.innerText)
/(?:([trarneicoos])(?!.*?\\1)){11}/.exec($0.innerText)

# quick sanity check on table
class Row(Entity):
  prop = Property()
for i in t._indices: r[i] = Row(**r[i]).to_dict()


`)
}
CodeMirror.Vim.defineEx('notes', null, notes)

</script>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import aio, window
from browser import document as doc
from browser.html import *
import time
from types import FunctionType as function
#import traceback

import _jsre as re

def split(pat, string):
  out = []
  _string = string
  found = re.findall(pat, string)

  while found:
    tar = found.pop(0)
    out.append(_string.split(tar)[0])
    _string = tar.join(_string.split(tar)[1:])
  out.append(_string)
  return out

re.split = split

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event

# usefull for binding multiple buttons
def parents_of(_tar):
  parents = []
  base = _tar
  while(base):
    parents.append(base)
    base = base.parentNode
    
  return parents
  
class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html#event
  '''
  
  def __init__(self, *) -> None:
    self._set = False
    
  async def wait(self) -> None:
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self) -> bool:
    return self._set
    
  def set(self) -> None:
    self._set = True
    
  def clear(self) -> None:
    self._set = False
    
aio.Event = Event

# --- new entity stuff

def enforce(f):
  annos = f.__annotations__
  del annos['return']

  vars = f.__code__.co_varnames

  defs = f.__defaults__ or []
  offset = len(vars) - f.__code__.co_argcount

  #print(defs)
  defs = [v for v in vars[-(len(defs)+offset): -offset]]

  def new_f(*args, **kwds):
    _args = {vars[i]: v for i, v in enumerate(args)}
    _args.update(**kwds)
    for k, v in annos.items():
      if type(v) == tuple:
        v = tuple(type(None) if i is None else i for i in v)
      elif v == None:
        v = type(None)
      if k in _args:
        if type(v) == list:
          if _args[k] not in v:
            raise ValueError(f"Expected values {v} but {k} was given value {_args[k]}.")
        else:
          if not isinstance(_args[k], v):
            raise TypeError(f"Expected type {v} but {k} was given type {type(_args[k])}.")

    return f(*args, **kwds)
  new_f.__name__ = f.__name__
  return new_f

def enforce_class(f):
  annos = f.__annotations__
  #del annos['return']
   
  for k, v in annos.items():
    if type(getattr(f, k)) is not bound:
      setattr(f, k, bound(getattr(f, k), k))

  vars = list(annos.keys())

  defs = [f.__dict__[i] for i in annos if i in f.__dict__]

  #print(defs)
  defs = [v for v in vars[-len(defs):]]

  def new_f(self, *args, **kwds):
    _args = {vars[i]: v for i, v in enumerate(args)}
    _args.update(**kwds)
    setattr(self, '_cbs', {})
    for k, v in annos.items():
      if type(v) == tuple:
        v = tuple(type(None) if i is None else i for i in v)
      elif v == None:
        v = type(None)
      if k in _args:
        if type(v) == list:
          if _args[k] not in v:
            raise ValueError(f"Expected values {v} but {k} was given value {_args[k]}.")
        else:
          if v is not any and not isinstance(_args[k], v):
            raise TypeError(f"Expected type {v} but {k} was given type {type(_args[k])}.")
      elif k not in dir(f):
        raise ValueError(f"Parameter {k} missing.")
      else:
        if type(getattr(f, k).default) is list:
          _args[k] = ObservableList(getattr(f, k).default, obj=self, name=k)
        elif type(getattr(f, k).default) is dict:
          _args[k] = ObservableDict(getattr(f, k).default, obj=self, name=k)
        elif type(getattr(f, k).default) in (set, list, tuple, dict):
          _args[k] = type(getattr(f, k).default)(getattr(f, k).default)
        else:
          _args[k] = getattr(f, k).default
    for k, v in _args.items():
      if k not in annos:
        raise ValueError(f"{k} is not a valid parameter.")
    
    self.__dict__.update(**_args)

    pi = getattr(self, '__post_init__', None)
    if pi:
      pi()

  def bind(self, **kwargs):
    for k, v in kwargs.items():
      if k not in self._cbs:
        self._cbs[k] = []
      self._cbs[k].append(v)

  def unbind(self, **kwargs):
    for k, v in kwargs.items():
      self._cbs[k].remove(v)
      if not self._cbs[k]:
        del self._cbs[k]

  def dispatch(self, prop, *l, **kw):
    if getattr(self, f'on_{prop}', None):
      getattr(self, f'on_{prop}')(*l, **kw)
    if prop in self._cbs:
      for cb in self._cbs[prop]:
        cb(self, *l, **kw)

  f.bind = bind
  f.unbind = unbind
  f.dispatch = dispatch

  f.__init__ = new_f
  if '__repr__' not in f.__dict__:
    def strip_dict(self):
      return str({k: v for k, v in self.__dict__.items() if not k.startswith('_')})
    f.__repr__ = strip_dict
  return f

def dispatch(fun):
  def _dispatch(self, *l, **kw):
    fun(self, *l, **kw)
    self.dispatch(fun.__name__, *l, **kw)
  _dispatch.__name__ = fun.__name__
  return _dispatch
  
class bound:
  """Custom attribute to delegate changes to a property."""
  def __init__(self, default, name=''):
    self.default = default
    self.name = name

  # set name not working in current brython version
  def __set_name__(self, owner, name):
    self.name = name

  def __get__(self, instance, owner):
    if not instance: return self
    return instance.__dict__[self.name]

  def __delete__(self, instance):
    del instance.__dict__[self.name]

  def __set__(self, instance, value):
    curval = instance.__dict__.get(self.name, self)

    instance.__dict__[self.name] = value

    if value != curval:
      if getattr(instance, f'on_{self.name}', None):
        getattr(instance, f'on_{self.name}')(curval, value)
      if self.name in instance._cbs:
        for cb in instance._cbs[self.name]:
          cb(instance, curval, value)

class ObservableList(list):
  # Internal class to observe changes inside a native python list.
  def __init__(self, *largs, obj=None, name=''):
    self.name = name
    self.obj = obj
    super().__init__(*largs)
    
  def __setitem__(self, key, value):
    list.__setitem__(self, key, value)
    self.__onmut__(key, value, 'set')

  def __delitem__(self, key):
    value = self.__getitem__(key)
    list.__delitem__(self, key)
    self.__onmut__(key, value, 'del')

  def __iadd__(self, *largs):
    list.__iadd__(self, *largs)
    self.__onmut__(-1, *largs, 'iadd')
    return self

  def __imul__(self, *largs):
    list.__imul__(self, *largs)
    self.__onmut__(-1, *largs, 'imul')
    return self

  def append(self, *largs):
    list.append(self, *largs)
    self.__onmut__(-1, *largs, 'append')

  def remove(self, *largs):
    list.remove(self, *largs)
    self.__onmut__(-1, *largs, 'remove')

  def insert(self, key, *largs):
    list.insert(self, key, *largs)
    self.__onmut__(key, *largs, 'insert')

  def pop(self, key=-1):
    result = list.pop(self, key)
    self.__onmut__(key, result, 'pop')
    return result

  def extend(self, *largs):
    list.extend(self, *largs)
    self.__onmut__(-1, *largs, 'extend')

  def sort(self, *largs):
    list.sort(self, *largs)
    self.__onmut__(-1, None, 'sort')

  def reverse(self, *largs):
    list.reverse(self, *largs)
    self.__onmut__(-1, None, 'reverse')
    
  def clear(self, *largs):
    list.clear(self, *largs)
    self.__onmut__(-1, None, 'clear')
    
  def __onmut__(self, key, value, event):
    if getattr(self.obj, f'on_{self.name}_{event}', None):
      getattr(self.obj, f'on_{self.name}_{event}')(key, value)
    if getattr(self.obj, f'on_{self.name}_mut', None):
      getattr(self.obj, f'on_{self.name}_mut')(key, value, event)
    if f'{self.name}_{event}' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_{event}']:
        cb(self.obj, key, value)
    if f'{self.name}_mut' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_mut']:
        cb(self.obj, key, value, event)
      
class ObservableDict(dict):
  # Internal class to observe changes inside a native python dict.
  def __init__(self, *largs, obj=None, name=''):
    self.name = name
    self.obj = obj
    super().__init__(*largs)
    
  def __setitem__(self, key, value):
    dict.__setitem__(self, key, value)
    self.__onmut__(key, value, 'set')

  def __delitem__(self, key):
    value = self.__getitem__(key)
    dict.__delitem__(self, key)
    self.__onmut__(key, value, 'del')

  def clear(self, *largs):
    dict.clear(self, *largs)
    self.__onmut__(-1, None, 'clear')

  def pop(self, *largs):
    result = dict.pop(self, *largs)
    self.__onmut__(largs[0], result, 'pop')
    return result

  def popitem(self, *largs):
    result = dict.popitem(self, *largs)
    self.__onmut__(-1, result, 'popitem')
    return result

  def setdefault(self, key, default):
    dict.setdefault(self, key, default)
    self.__onmut__(key, default, 'setdefault')

  def update(self, *largs):
    dict.update(self, *largs)
    self.__onmut__(-1, *largs, 'update')
    
  def __onmut__(self, key, value, event):
    if getattr(self.obj, f'on_{self.name}_{event}', None):
      getattr(self.obj, f'on_{self.name}_{event}')(key, value)
    if getattr(self.obj, f'on_{self.name}_mut', None):
      getattr(self.obj, f'on_{self.name}_mut')(key, value, event)
    if f'{self.name}_{event}' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_{event}']:
        cb(self.obj, key, value)
    if f'{self.name}_mut' in self.obj._cbs:
      for cb in self.obj._cbs[f'{self.name}_mut']:
        cb(self.obj, key, value, event)

@enforce_class
class Engine:
  """Organizes classes to be quickly referenced later.
  
  This takes supplied entities, gets their base classes and makes a dictionary
    referring to all the classes. This is looked up as a dictionary with __getitem__.
  """

  entities: list = []
  components: list = []
  objs: dict = {}

  def __post_init__(self):
    for e in self.entities:
      self.objs[e] = []
      for base in e.__bases__:
        self.objs[base] = []
        self.components.append(base)

  def load(self, data):
    """Load dictionary and create objects as needed."""
    for k,v in self.objs.items():
      if k in self.entities and k.__qualname__ in data:
        for item in data[k.__qualname__]:
          self.add(k(**item))
  
  def __repr__(self):
    return str({e.__qualname__: self.objs[e] for e in self.entities})

  def __getitem__(self, key):
    return self.objs[key]

  def add(self, obj):
    self.objs[obj.__class__].append(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].append(obj)

  def remove(self, obj):
    self.objs[obj.__class__].remove(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].remove(obj)


# --- table stuff

def ig(obj, prop):
  return [i[prop] for i in obj]

def itemgetter(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return obj[item]
  else:
    def g(obj):
      return tuple(obj[item] for item in items)
  return g


class groupby:
  # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
  # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
  def __init__(self, iterable, key=None):
    if key is None:
      key = lambda x: x
    self.keyfunc = key
    self.it = iter(iterable)
    self.tgtkey = self.currkey = self.currvalue = object()
  def __iter__(self):
    return self
  def __next__(self):
    self.id = object()
    while self.currkey == self.tgtkey:
      self.currvalue = next(self.it)  # Exit on StopIteration
      self.currkey = self.keyfunc(self.currvalue)
    self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
  def _grouper(self, tgtkey, id):
    while self.id is id and self.currkey == tgtkey:
      yield self.currvalue
      try:
        self.currvalue = next(self.it)
      except StopIteration:
        return
      self.currkey = self.keyfunc(self.currvalue)

def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out


base_table_str = '''
@enforce_class
class R:
  _sub_table: str = ''
  pass

  def __getitem__(self, key):
    return self.__dict__[key]

  def __setitem__(self, key, value):
    return setattr(self, key, value)
  
locals()['R'] = R
'''

def trycast(d, anno):
  for k, v in d.items():
    if type(anno[k]) == list:
      if v not in anno[k]:
        raise ValueError(f"Expected values {anno[k]} but {k} was given value {v}.")
    else:
      if anno[k] is not any and not isinstance(v, anno[k]):
        d[k] = anno[k](v)


# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out


class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    prop_str = ''
    prop_dict = {}

    row_props = self.code.split('\n\n')[0]
    for i in row_props.splitlines():
      if ':' in i:
        prop_dict[i.split(':')[0]] = i

    for h in self.headers:
      if h not in prop_dict:
        prop_str += f"\n  {h}: any = ''"
      else:
        prop_str += f"\n  {prop_dict[h]}"

    loc = {}
    exec(base_table_str.replace('pass', prop_str), globals(), loc)

    self.Row = loc['R']
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        _d = {k:v for k, v in zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]) if v != ''}
        trycast(_d, self.Row.__annotations__)
        self.table.append(self.Row(**_d))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n' 
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}'
    return out


  def run_code(t):
    exec(t.code)

  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}

# --- end focus

@enforce
def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

@enforce
def SWITCH(text: str , state: bool = False, Type: ['checkbox', 'radio'] = 'checkbox', Class: ['switch', 'radio'] = 'switch', name: str = '') -> LABEL:
  return DIV(LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'}),
    style={'width':'100%'}
  ), style={'display':'flex', 'align-items': 'center'})

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple(*_):
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s','transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple(*_):
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple(*_):
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple(*_):
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)



ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = False
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = True

#def on_down(ev):
#  global ctrl, tables
#  if ev.ctrlKey:
#    ctrl=True
#  else:
#    ctrl=False
#
#  if ev.which == 37 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', False)
#      cm_editbox.setOption('lineWrapping', True)
#      cm_editbox.setOption('readOnly', True)
#  if ev.which == 39 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', True)
#      cm_editbox.setOption('lineWrapping', False)
#      cm_editbox.setOption('readOnly', False)
#  if chr(ev.which)=='G' and ctrl:
#    start = cm_editbox.getCursor(True).line
#    end = cm_editbox.getCursor(False).line
#    if start == end:
#      print(cm_editbox.getCursor().line + 1)
#    else:
#      diff = abs(start-end)
#      print('{}:{}({})'.format(start+1, end+1, diff+1))
#    ev.preventDefault()
#    ev.stopPropagation()



def do_table() -> None:
  try:
    window.vdo("?_table_|jmx|/_table_|kmz'xV'zo")
    tab = Table(cm_editbox.getSelection())
    tab.run_code()
    cm_editbox.replaceSelection(str(tab))
    #window.reg('"', str(tab))
    #window.vdo('gvp')
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())
        
def run_table(cm, params):
  do_table()
window.CodeMirror.Vim.defineEx("do_table", None, run_table)


def do_py() -> None:
  try:
    window.vdo("gv")
    tab = exec(cm_editbox.getSelection())
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())

        
def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)
        
#doc.get(selector='.CodeMirror')[0].bind('keydown', on_down)

def showRelativeLines(cm):
  cm.setOption('lineNumbers', cm.state.vim.visualMode)
  lineNum = cm.getCursor().line + 1;

  
  look_at = int(doc.querySelector('.CodeMirror').scrollHeight/12)
  last_line = cm.lastLine()
  if len(cm_editbox.getSelections()) > 1:
    cur_line = cm_editbox.listSelections()[0].anchor.line
    cur_line_bot = cm_editbox.listSelections()[-1].anchor.line
  else:
    cur_line = cm.getCursor(True).line
    cur_line_bot = cm.getCursor(False).line
  line_range = range(cur_line, cur_line_bot+1)
  up = True
  down = True
  for i in range(look_at):
    if _options['limelight']:
      if cm_editbox.state.vim.visualMode:
        if cur_line-i in line_range:
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        if cur_line+i in line_range:
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
      else:
        #going down
        if cur_line+i <= last_line and down and cm.getLine(cur_line+i).strip():
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        elif cur_line+i <= last_line and i:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          down = False
    
        #going up
        if cur_line-i >= 0 and up and cm.getLine(cur_line-i).strip():
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        elif cur_line-i >= 0 and i:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          up = False
    else:
      cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
      cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
    cm.removeLineClass(cur_line-i, 'gutter', 'CodeMirror-activeline-gutter')
    cm.removeLineClass(cur_line+i, 'gutter', 'CodeMirror-activeline-gutter')
  cm.addLineClass(cur_line, 'gutter', 'CodeMirror-activeline-gutter')
      
  if (cm.getCursor().line == lineNum):
    #cm.addLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    #cm.removeLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    return
    
  
  #cm.getCursor().line = lineNum
  def temp(l):
    if l==lineNum:
      return lineNum
    return abs(lineNum-l)
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', showRelativeLines)

def runpy(cm, params):
  exec(params.argString, _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)

def do_reg(_do = "sum(n)", _reg = '"') -> dict:
  args = _do.split(';')
  
  sel = window.CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
  
  l  = re.split(r'\s+', sel)
  li = re.split(r'\s*\n\s*', sel)
  n  = [float(i) for i in re.findall(r'[-+]?[0-9]*\.?[0-9]+', sel)]
  w  = re.findall(r'\w+', sel)
  
  outs = []
  for i in args:
    outs.append(eval(i))
  res = str(dict(zip(args, outs)))
  print(res)
  if len(outs) == 1:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [str(outs[0])]
  else:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [res]
def runnums(cm, params):
  do_reg(params.argString)
window.CodeMirror.Vim.defineEx("nums", None, runnums)
#_options['nums'] = do_reg
_options['do_reg'] = do_reg

def compare(cm, params):
  new = window.CodeMirror.Vim.getRegisterController().getRegister('a').keyBuffer[0]
  old = window.CodeMirror.Vim.getRegisterController().getRegister('d').keyBuffer[0]
  window.make_popup(render_diff(old, new))
window.CodeMirror.Vim.defineEx("compare", None, compare)
window.CodeMirror.Vim.defineEx("diff", None, compare)

def runup(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)

def rundown(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)

def better_sort():
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in _nsre.split(s)]    
  def do_stuff(dat, ns = False):
    if ns:
      return dat
    sets = re.split(r'\n(\s+)?\n+', dat)
    sets = [s for s in sets if s and s.strip()]
    for i in range(len(sets)):
      lines = sets[i].splitlines()
      for line in range(len(lines)):
        lines[line] = lines[line].rstrip()
      locked = []
      for j in range(len(lines)):
        if lines[j].strip().startswith('#'):
          locked.append((j, lines[j]))
      for j in reversed(locked):
        del lines[j[0]]
      #lines = sorted(lines)#, key = natural_sort_key)
      lines = window.natsort(lines)
      for j in locked:
        lines.insert(j[0], j[1])
      sets[i] = '\n'.join(lines)
    return '\n\n'.join(sets)
  cm_editbox.replaceSelection(do_stuff(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except Exception as e:
    window.make_popup(str(e))
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)

def align_by2(_char = ',', _glue = ''):
  window.vdo('gvo')
  _dat = cm_editbox.getSelection()
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  _dat = cm_editbox.replaceSelection(_out.strip('\n'))
  #window.vdo('gvp')
  #return _out
def run_align_by(cm, params):
  align_by2()
window.CodeMirror.Vim.defineEx("align_by", None, run_align_by)

def run_align_by_colin(cm, params):
  align_by2(':')
window.CodeMirror.Vim.defineEx("align_by_colin", None, run_align_by_colin)

def run_align_by_pipe(cm, params):
  align_by2('|', ' | ')
window.CodeMirror.Vim.defineEx("align_by_pipe", None, run_align_by_pipe)

def run_align_by_equals(cm, params):
  align_by2('=', ' = ')
window.CodeMirror.Vim.defineEx("align_by_equals", None, run_align_by_equals)

#--- async stuff

async def snack(content, delay=5):
  # make element
  _snack = DIV(content, Class='card',
                style={
                  'position': 'fixed',
                  'z-index': '2',
                  'bottom': '-16px',
                  'left': '50%',
                  'transform': 'translate(-50%, 100%)',
                  'transition': 'transform .4s, bottom .4s',
                  'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
                })
  # attach to doc
  doc <= _snack
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = '16px'
  _snack.style['transform'] = 'translate(-50%, 0%)'
  # sleep for 5
  await aio.sleep(.4+delay)
  # update pos
  _snack.style['bottom'] = '-16px'
  _snack.style['transform'] = 'translate(-50%, 100%)'
  await aio.sleep(.4)
  _snack.remove()
  # return

async def snackbar():
  window.snacks = []
  while True:
    while window.snacks:
      val = window.snacks.pop(0)
      await snack(val)
      
    await aio.sleep(1)

async def popup(content):
  frame = DIV(Class='darken', style={
    'background': 'rgba(0, 0, 0, 0)',
    'transition': 'background .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    'width': '100%',
    'height': '100%',
    'position': 'fixed',
    'top': '0px',
    'left': '0px',
    'z-index': '1'
  })

  box = DIV(content, Class='card', style={
    'position': 'absolute',
    'left': '12.5%',
    'top': '25%',
    'opacity': 0,
    'width': '75%',
    'height': '75%',
    'margin': '-16px',
    'transition': 'opacity .4s, top .4s',
    'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  })

  frame <= box

  doc <= frame

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.style['top'] = '12.5%'

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.style['top'] = '25%'
  await aio.sleep(.4)

  frame.remove()

class Popup:
  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1'
    })

    self.box = DIV(Class='card', style={
      'position': 'absolute',
      'left': '12.5%',
      'top': '25%',
      'opacity': 0,
      'width': '75%',
      'height': '75%',
      'margin': '-16px',
      'transition': 'opacity .4s, top .4s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    })

    self.frame <= self.box
    
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.frame, 'click')
      if ev.type == 'cancel' or ev.target == self.frame:
        break
        
    # Try to break all awaiting UI.
    for el in self.box.querySelectorAll('*'):
      aio.cancel_event(el)
      
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    self.box.style['top'] = '25%'
    await aio.sleep(.4)

    self.frame.remove()
    
  async def __aenter__(self):
    self._root <= self.frame

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1
    self.box.style['top'] = '12.5%'

    aio.run(self._background())
    
    return self.box
    
  async def __aexit__(self, type, value, traceback):
    aio.cancel_event(self.frame)

    
# General with El that you can be used like with Popup
class El:
  def __init__(self, _root, el):
    self._root = _root
    self.el = el
        
  async def _background(self):
    # to allow clicks within the popup
    while True:
      ev = await aio.select_event(self.el, '')
      if ev.type == 'cancel':
        break
        
    # Try to break all awaiting UI.
    for el in self.el.querySelectorAll('*'):
      aio.cancel_event(el)

    self.el.remove()
    
  def __enter__(self):
    self._root <= self.el

    aio.run(self._background())
    
    return self.el
    
  def __exit__(self, type, value, traceback):
    aio.cancel_event(self.el)

async def keybind():
  muted_events = ['Meta', 'Shift', 'Control', 'Alt']
  
  aio.cancel_event(doc)
  ev = await aio.select_event(doc, 'keyup keydown')
  while ev.type != 'cancel':
    ctrl = ev.getModifierState('Control')
    alt = ev.getModifierState('Alt')
    shift = ev.getModifierState('Shift')

    if ev.key not in muted_events and type(ev.target) not in (TEXTAREA, INPUT):
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        #print(f'key down {ev.key}')
        if ev.key == 'Escape':	
          tar = doc.querySelectorAll('.darken')
          if len(tar):
            aio.cancel_event(tar[-1])#def on_down(ev):
    if ev.key not in muted_events:
      if ev.type == 'keyup':
        #print(f'key up {ev.key}')
        pass
      elif ev.type == 'keydown':
        if ev.which == 37 and ctrl:
          if not cm_editbox.state.vim.insertMode:
            ev.preventDefault()
            ev.stopPropagation()
            #cm_editbox.setOption('lineNumbers', False)
            cm_editbox.setOption('lineWrapping', True)
            cm_editbox.setOption('readOnly', True)
        if ev.which == 39 and ctrl:
          if not cm_editbox.state.vim.insertMode:
            ev.preventDefault()
            ev.stopPropagation()
            #cm_editbox.setOption('lineNumbers', True)
            cm_editbox.setOption('lineWrapping', False)
            cm_editbox.setOption('readOnly', False)
        if chr(ev.which)=='G' and ctrl:
          ev.preventDefault()
          ev.stopPropagation()
          start = cm_editbox.getCursor(True).line
          end = cm_editbox.getCursor(False).line
          if start == end:
            print(cm_editbox.getCursor().line + 1)
          else:
            diff = abs(start-end)
            print('{}:{}({})'.format(start+1, end+1, diff+1))


    ev = await aio.select_event(doc, 'keyup keydown')

class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass
    
async def sidebar() -> None:
  hidden = 'card main_sidebar hidden'
  shown = 'card main_sidebar shown'

  with El(doc, SPAN(Class='card main_sidebar hidden')) as box:
    # do stuff
    
    await aio.sleep(.05)
    box.setAttribute('class', shown)
    await aio.sleep(.4)
    box.setAttribute('class', hidden)
    
    watched_events = 'mouseover mouseleave'
    ev = await aio.select_event(box, watched_events)
    while ev.type != 'cancel':
      if ev.type == 'mouseover':
        if ev.target==box:
          box.setAttribute('class', shown)
      elif ev.type == 'mouseleave':
        if ev.target==box:
          box.setAttribute('class', hidden)

      ev = await aio.select_event(box, watched_events)
    
class Debounce:
  @enforce
  def __init__(self, fun: function, limit: (int, float)) -> None:
    self.dat = []
    self.limit = limit
    self.last_ran = time.time()
    self.command = fun
    
  def _deferred_fun(self, *l, **kw):
    self.dat.append((l, kw))
    self.last_ran = time.time()
    
  async def db_task(self, handle):
    while handle['running'] == True:
      if self.dat and self.last_ran + self.limit < time.time():
        self.command(self.dat)
        self.dat = []
      await aio.sleep(0)
  
  def __enter__(self):
    self.last_ran = time.time()
    self.task_handle = {'running': True}
    aio.run(self.db_task(self.task_handle))
    
    return self._deferred_fun
    
  def __exit__(self, type, value, traceback):
    # flush command with data
    if self.dat:
      self.command(self.dat)
      self.dat = []
    self.task_handle['running'] = False
    
    
class Throttle:
  def __init__(self, fun, limit):
    self.dat = []
    self.limit = limit
    self.last_ran = time.time()
    self.command = fun
    
  def _deferred_fun(self, *l, **kw):
    if not self.dat:
      self.last_ran = time.time()
    self.dat.append((l, kw))
    
  async def db_task(self, handle):
    while handle['running'] == True:
      if self.dat and self.last_ran + self.limit < time.time():
        self.command(self.dat)
        self.dat = []
      await aio.sleep(0)
  
  def __enter__(self):
    self.last_ran = time.time()
    self.task_handle = {'running': True}
    aio.run(self.db_task(self.task_handle))
    
    return self._deferred_fun
    
  def __exit__(self, type, value, traceback):
    # flush command with data
    if self.dat:
      self.command(self.dat)
      self.dat = []
    self.task_handle['running'] = False

async def main():
  res = await aio.gather(snackbar(), keybind(), sidebar())

aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache" && msg != 'empty stack'){
          cm_editbox.openNotification('<pre>'+msg+'</pre>')
	}
      //cm_editbox.openNotification('<p>'+msg.split('\n').join('<br>')+'</p>')
      }
      
      console.log=_logger
      console.error=make_popup
      console.warning=make_popup
      </script>
</html>
