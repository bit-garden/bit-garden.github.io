<html>
<title>Blackboard</title>
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

.CodeMirror, .CodeMirror-gutters{background:#111111 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;    }

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}
 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:14px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;  
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: #111111;
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888
  }
  .CodeMirror-activeline-gutter > .CodeMirror-linenumber {
	    color: white !important;
	      width: auto !important;
	    }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }
  

input::-webkit-calendar-picker-indicator {
  display: none;
}
  
/* Ripple effect */
.ripple {
  background-position: center;
  transition: background 0.4s;
}
/* hover color need to match */
.ripple:hover {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
.ripple:focus {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
/* pulse color */
.ripple:active {
  background-color: grey;
  background-size: 100%;
  transition: background 0s;
}

/* card style */
.card {
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.red_ripple:hover {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
.red_ripple:focus {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
/* pulse color */
.red_ripple:active {
  background-color: red;
  background-size: 100%;
  transition: background 0s;
}
.red_card{
  background-color: #660000;
}

.green_ripple:hover {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
.green_ripple:focus {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
/* pulse color */
.green_ripple:active {
  background-color: green;
  background-size: 100%;
  transition: background 0s;
}
.green_card{
  background-color: #006600;
}

.blue_ripple:hover {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
.blue_ripple:focus {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
/* pulse color */
.blue_ripple:active {
  background-color: blue;
  background-size: 100%;
  transition: background 0s;
}
.blue_card{
  background-color: #000066;
}

.purple_ripple:hover {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
.purple_ripple:focus {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
/* pulse color */
.purple_ripple:active {
  background-color: purple;
  background-size: 100%;
  transition: background 0s;
}
.purple_card{
  background-color: #660066;
}

.orange_ripple:hover {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
.orange_ripple:focus {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
/* pulse color */
.orange_ripple:active {
  background-color: orange;
  background-size: 100%;
  transition: background 0s;
}
.orange_card{
  background-color: #664400;
}

.button{
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  outline: none;
  background-color:rgba(71,71,71,0);
}

/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  border-radius: 3px;
  padding: 8px 8px;
  margin:6px;
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
  font-family: Mono !important;
}

.input{
  border-bottom: rgba(34,34,34,0) solid 2px;
  padding: 12px 18px 10px 18px;
  transition: border .4s;
}
.input:focus{
  border-bottom: rgba(128,128,128,255) solid 2px;
}

.check-on > .off {
  display:none !important;
}

.check-off > .on {
  display:none !important;
}

.check-on > .on{
  font-weight:bold;
  color:#44ff44;
  float:right;
}

.check-off > .off{
  font-weight:bold;
  color:#ff4444;
  float:right;
}

.check-on > .label, .check-off > .label{
  float:left;
}

.check-on, .check-off{
  width:100%;
}
  
</style>
<script>
// Returns if a value is a string
function isString (value) {
return typeof value === 'string' || value instanceof String;
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};



	  CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
{regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	  
{regex: /#(\S|\s\s).*$/, token: "comments"}, // darklights comments
{regex: /#(\s\S.*|\s*$)/, token: "deco"}, // highlights comments
	  
{regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
{regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
//{regex: /[-+]?[0-9]*\.?[0-9]+/, token: "nums"}, // numbers
//{regex: /(__)(.*?)\1/, token: "under"},
//{regex: /(~~)(.*?)\1/, token: "strike"},
//{regex: /(\||--+|:-|:\|)/, token: "nums"},
	  
  ]
});
	  CodeMirror.defineSimpleMode("simplermode", {
  // The start state contains the rules that are intially used
  start: [
{regex: /(\#|\/\/).*$/, token: "comments"}, // darklight comments
  ]
});
</script>
<body onload="brython()">
<textarea class='editbox'></textarea>
</body>
<script>
//CodeMirror.Vim.unmap(';')
CodeMirror.Vim.unmap(',')
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map(',/', ':js timediff()', 'normal')
CodeMirror.Vim.map('fd', '<Esc>', 'insert')
CodeMirror.Vim.map('vb','<Esc>T|<C-v>t|','insert')
CodeMirror.Vim.map(',/', '<Esc>/i', 'insert')
CodeMirror.Vim.map(',?', '<Esc>?i', 'insert')
CodeMirror.Vim.map(',a', '<Esc>A', 'insert')
CodeMirror.Vim.map(',i', '<Esc>I', 'insert')
CodeMirror.Vim.map(',l','<Esc>f|la','insert')
CodeMirror.Vim.map(',h','<Esc>2F|la','insert')
CodeMirror.Vim.map(',j','<Esc>F|lja','insert')
CodeMirror.Vim.map(',k','<Esc>F|lka','insert')
CodeMirror.Vim.map(';;','<Esc>:','insert')
CodeMirror.Vim.map('cw','<Esc>lciwi','insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')
CodeMirror.Vim.map(',l','f|ll','normal')
CodeMirror.Vim.map(',h','2F|ll','normal')
CodeMirror.Vim.map(',j','F|ljl','normal')
CodeMirror.Vim.map(',k','F|lkl','normal')
//CodeMirror.Vim.map(';;',':','normal')
CodeMirror.Vim.map(',<Space>', ':noh', 'normal')
//CodeMirror.Vim.map(',e', '@e', 'normal') //Short mapping to e macro
//more maps?
//CodeMirror.Vim.map('<C-t>', "mzyy'tP`zdd", 'normal')
//CodeMirror.Vim.map('Y', '"Ay', 'visual')

//CodeMirror.Vim.map('zv', ":vdo ?---|jmx|/---|kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zv', "[-jmx]-kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zb', ":vblock", 'normal')

CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|l', 'normal')
CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|a', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|l', 'normal')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|a', 'insert')
CodeMirror.Vim.map(',o', ':vdo oi', 'insert')
CodeMirror.Vim.map(',O', ':vdo Oi', 'insert')
CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')
CodeMirror.Vim.map('<C-y>', ':vdo vip|:better_sort', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')
CodeMirror.Vim.map(',y', ':js sort_by()', 'visual')
CodeMirror.Vim.map(',,', ':align_by', 'visual')
CodeMirror.Vim.map(',;', ':align_by_colin', 'visual')
CodeMirror.Vim.map(',=', ':align_by_equals', 'visual')
CodeMirror.Vim.map(',\\', ':align_by_pipe', 'visual')

CodeMirror.Vim.map(']-', ':vdo :js move_to("---")|_', 'normal')
CodeMirror.Vim.map('[-', ':vdo :js move_to("---", false)|_', 'normal')

//CodeMirror.Vim.map("''", ':vdo :js put(\'"\')|a', 'insert')

//CodeMirror.Vim.map('cb', ':vdo :js put("[\'")|a', 'insert')
//CodeMirror.Vim.map('bc', ':vdo :js put("\']")|a', 'insert')

//CodeMirror.Vim.map('..', ':DoubleD', 'insert')

CodeMirror.Vim.map('gt', ':vdo /--- Cal|/\\[TODAY\\]|zb', 'normal')

CodeMirror.Vim.map(',r', ':js alignRight()', 'visual')
CodeMirror.Vim.map(',l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map(',c', ':js alignCenter()', 'visual')

CodeMirror.Vim.unmap('s', 'visual')
CodeMirror.Vim.map("s'" , ":js surround(\"'\", \"'\")", 'visual')
CodeMirror.Vim.map('s"' , ":js surround('\"' , '\"')" , 'visual')
CodeMirror.Vim.map("s\\", ":js surround('|'  , '|')"  , 'visual')

CodeMirror.Vim.map("sd", ":js surround(\"['\"  , \"']\")"  , 'visual')
CodeMirror.Vim.map("s[", ":js surround('['  , ']')"  , 'visual')
CodeMirror.Vim.map("s{", ":js surround('{'  , '}')"  , 'visual')
CodeMirror.Vim.map("s(", ":js surround('('  , ')')"  , 'visual')

CodeMirror.Vim.map("s_", ":js surround('_'  , '_')"  , 'visual')



  editbox = document.querySelector('.editbox')
  if ('data' in localStorage){
    editbox.value = localStorage.getItem('data')
  }
  cm_editbox = CodeMirror.fromTextArea(editbox,{
              'matchBrackets':     true,
              'autoCloseBrackets': false,
              'lineNumbers':       false,
              "mode":              'simplemode',
              "theme":             "material",
              'tabSize':           2,
              'styleActiveLine':   true,
              'keyMap':            'vim',
              'extraKeys':         {"Ctrl-Space": "autocomplete"}
   })
   function tab_to_space(cm){
    cm.execCommand("insertSoftTab")
  }
  cm_editbox.addKeyMap({'Ctrl-C': false})
  cm_editbox.addKeyMap({'Tab': tab_to_space})
  
  function on_change(cm, _change){
    cm_editbox.save()
    localStorage.setItem('data', editbox.value);
  }
  
  cm_editbox.on('change',on_change)
  
  function ac_hint(cm){
    cm.showHint({'hint': CodeMirror.hint.anyword})
  }
  CodeMirror.commands.autocomplete = ac_hint
  
  function runjs(cm, params){
    eval(params.argString)
  }
  
  CodeMirror.Vim.defineEx("js", null, runjs)

function put(_text, pre=false){
  reg('z', _text)
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  if (!pre)
    vdo(':js key("<Esc>")|l"zp')
  else
    vdo(':js key("<Esc>")|l"zP')
}

function _surround(i, l, r){
  if (i.trim().length > 0){
    return l + i + r
  }else{
    return i
  }
}

function surround(l = "'", r = "'"){
vdo('gvy')
yanked = reg('"').split('\n')
yanked = yanked.map((i)=> _surround(i, l, r))
reg('"', yanked.join('\n'))
//reg('"', l + reg('"').trim() + r)
vdo('gvp')
}

function key(_key){
  CodeMirror.Vim.handleKey(cm_editbox, _key, 'macro')
}

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}
  
function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}
//sort natural order in tables
function itemgetter(keys){
    return function test2(_dict){
        out = ''
        keys.forEach((e)=>out+=_dict[e]+'|')
        return out
    }
}
function sort_dicts(_dicts, _keys){
  keys = itemgetter(_keys)
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  return _dicts.sort((a, b) => collator.compare(keys(a), keys(b)))
}

//testing char skipping, not space skipping exclusively. 
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}

function toclip(dat){
navigator.clipboard.writeText(dat.toString())
  .then(() => {
    console.log(dat.toString() + ' to clip.');
  })
  .catch(err => {
    // This can happen if the user denies clipboard permissions:
    console.error('Could not copy text: ', err);
  });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0
  
  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replaceAll('<bar>', '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)

function vblock(cm, params){
  vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

//function runclip(cm, params){
//  sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0].trim()
//  sel.split('\n').forEach((i)=>{
//    CodeMirror.Vim.handleEx(cm_editbox, i)
//  })
//}
//CodeMirror.Vim.defineEx("runclip", null, runclip)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function timediff(){
vdo('Vy') // > @"
sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
d = new Date()
newtime = [d.getMonth()+1,d.getDate(),d.getFullYear()].join('/') + ' ' + [d.getHours(), d.getMinutes()].join(':')
sel = sel.replace('%c', newtime)

if(sel.includes('%d')){
  vdo('kyy')
  var re_time = /\d+\/\d+\/\d+\ \d+:\d+/
  sel2 = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  last_time = sel2.match(re_time)
  last_time = new Date(last_time)
  diffmin = parseInt((d - last_time) / (1000 * 60)); 
  sel = sel.replace('%d', diffmin)
}
// for days , parseInt((date2 - date1) / (1000 * 60 * 60 * 24)); 
CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel
vdo('gvp') // < @"
}

function make_popup(_dat, _height = '10em'){
  cm_editbox.openDialog('<textarea style="font-family: Mono; white-space: pre;  overflow: auto; outline: none;border:none; background:none; color:white;width:100%; height:'+_height+'">'+_dat+'</textarea><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}

function make_simple_popup(_dat){
  cm_editbox.openDialog('<p style="background:none; color:white;width:100%; height:10em">'+_dat.replaceAll('\n','<br>')+'</p><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}


function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}

function DoubleD(cm, params){
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  if (line.substring(startch+1, startch+3) == "']"){
    vdo('lla')
  }else{
    put("['']")
    vdo('ha')
  }
  //vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  //CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('DoubleD', null, DoubleD)

function DoubleTap(cm, params){
  var pairs = [['"', '"'], ["'", "'"], ['(', ')'], ['[', ']'], ['{', '}']]
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  var character = params.argString.trim()
  var cur_character = line.substring(startch, startch+1)
  pairs.forEach((pair) => {
    if (character == cur_character && character == pair[1] && !line.substring(startch-1, startch).match(/\\/)){
      vdo('la')
    //}else if (character == pair[0] && character == "'" && line.substring(startch-1, startch).match(/\w/)){
    //  put(pair[0])
    //  vdo('la')
    }else if (character == pair[0]){
      put(pair[0])
      put(pair[1])
      vdo('a')
    }else if (character == pair[1]){
      put(pair[1])
      vdo('la')
    }
  })
}
CodeMirror.Vim.defineEx('DoubleTap', null, DoubleTap)

CodeMirror.Vim.map("'", ":DoubleTap '", 'insert')
CodeMirror.Vim.map('"', ':DoubleTap "', 'insert')
CodeMirror.Vim.map("[", ":DoubleTap [", 'insert')
CodeMirror.Vim.map("]", ":DoubleTap ]", 'insert')
CodeMirror.Vim.map("(", ":DoubleTap (", 'insert')
CodeMirror.Vim.map(")", ":DoubleTap )", 'insert')
CodeMirror.Vim.map("{", ":DoubleTap {", 'insert')
CodeMirror.Vim.map("}", ":DoubleTap }", 'insert')

function kpos(cm, params){
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function notes(cm, params){
  make_popup(`^e in normal insert visual
finds between _table_ markers(or visual) and runs as table

,\\ visual
aligns by |
,, ,= visual 
aligns by , or = respectively
,; visual
aligns by :

^j ^k normal
goes up or down to non whitespace character

^y normal visual
sort visual or vip

,y visualblock
sort by visualblock

,l ,c ,r visualblock
align left, center, right

vw insert
select word, then yank word

cw insert
change word or next word

s' s" s[ s\\ s{ s( s_ visual
surrounds by ' " [] | {} () _

,a insert
escape A

,I insert
escape I

vb insert
select between |

zv normal
select between ---

zb normal
select in table section

kj insert normal
auto complete based on file contents

jk fd insert
escape 

,/ ,? insert
search forward or backward and drop back to insert

,h ,j ,k ,l insert normal
jump between | and - respectivly for tables

;; insert normal
command line

,<space>
stop search highlight

]- [- normal
jump to ---

'' insert
place "

# re stuff
(,)(?=(?:[^"]|"[^"]*")*$) # csv: capture unencolsed ',' chars
(\\#|\\/\\/)(\\S|\\s\\s).*$ # Big comment
(\\#|\\/\\/)\\s.*$ # Small comments
\\w?"([^"\\\\]|\\\\.)*("|$) # Double quotes
(?![ \\{\\(\\[])\\w?'([^'\\\\]|\\\\.)*'\\s*(?=[\\)\\],:\\}.$ ])/ # Single quote code
(^| )'([^']|'\\w)*'( |$) # Single quote prose

# non complete calendar events
\| (?!-)\S[^\|]+

# find by surrounding 
(__)(.*?)\\1

# shuffle search
/(?:([dameagrirnbne])(?!.*?\\1)){13}/.exec($0.innerText)
/(?:([trarneicoos])(?!.*?\\1)){11}/.exec($0.innerText)

# quick sanity check on table
class Row(Entity):
  prop = Property()
for i in t._indices: r[i] = Row(**r[i]).to_dict()


`)
}
CodeMirror.Vim.defineEx('notes', null, notes)

</script>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">
import traceback

def Try(_callback = None):
  def _try(_func):
    def __try(*args, **kwargs):
      try:
        return _func(*args, **kwargs)
      except Exception as e:
        if _callback:
          if callable(_callback):
            #_callback((_func.__name__, e))
            _callback(traceback.format_exc())
          else:
            print(_callback)
    return __try
  return _try
  
# --- start focus
from browser import window
from browser.html import *

from copy import deepcopy
from operator import itemgetter
import itertools
import re
import time

# do not run first pass
# restart timer each call, within wait
# only call last instance
def debounce(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """
  def decorator(fn):
    def debounced(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        if cache is not None:
          tc = cache[:]
          cache.clear()
          fn(*args, cache=tc, **kwargs)
        else:
          fn(*args, **kwargs)
      try:
        window.clearTimeout(debounced.t)
      except(AttributeError):
        pass
      debounced.t = window.setTimeout(call_it, int(wait*1000))
      #debounced.t.start()
    return debounced
  return decorator


# run first pass
# only call last instance
def throttle(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """

  def decorator(fn):
    def throttled(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        throttled._timer = None
        throttled._last_call = time.time()
        if cache is not None:
          tc = cache[:]
          cache.clear()
          return fn(*args, cache=tc, **kwargs)
        else:
          return fn(*args, **kwargs)

      time_since_last_call = time.time() - throttled._last_call
      if time_since_last_call >= wait:
        return call_it()

      if throttled._timer is None:
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()
      else:
        window.clearTimeout(throttled._timer)
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()

    throttled._timer = None
    throttled._last_call = 0

    return throttled

  return decorator

# Sort key for logical number sorting
def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
  return [int(text) if text.isdigit() else text.lower()
          for text in _nsre.split(s)]    

def itemgetter_nat(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return natural_sort_key(obj[item])
  else:
    def g(obj):
      return natural_sort_key(' '.join(str(obj[item]) for item in items))
  return g

# sort by multiple columns
def sort_data(data, *cats, **kwargs):
  return sorted(data, key=itemgetter_nat(*cats), **kwargs)

# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in itertools.groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out

# --- property modifiers

# Returns error if not one of the allowed types
def union(*largs):
  def _union(obj):
    if type(obj) not in largs:
      raise(Exception(f'Union violated with {obj}'))
    else:
      return obj
  return _union

# Same as Union(None, ...)
def optional(*largs):
  return union(None, *largs)

def options(default='', choices=[]):
  def _options(obj):
    if obj in choices:
      return obj
    return default
  return _options

# Returns value locked to min of lower, max of upper
# lower and upper are inclusive
def bounded_number(lower, upper):
  def _bounded_number(num):
    num = union(int, float)(num)
    if num > upper:
      return upper
    if num < lower:
      return lower
    return num
  return _bounded_number

# Returns value wrapped to min of lower, max of upper
# lower is inclusive and upper is exclusive
def wrapped_number(lower, upper):
  diff = abs(upper - lower)
  def _wrapped_number(num):
    num = union(int, float)(num)
    while num >= upper:
      num -= diff
    while num < lower:
      num += diff
    return num
  return _wrapped_number
  
def d2e(_type):
  def _d2e(obj):
    obj = union(list, _type, dict)(obj)
    if type(obj) == list:
      return [type(union(dict, _type)(o)) == _type and o or _type(**o) for o in obj]
    elif type(obj) == _type:
      return obj
    else:
      return _type(**obj)
  return _d2e
  
def length(value):
  def _length(obj):
    return obj[:value]
  return _length

# --- Property

# Call generate_prop(target, prop_name)
# This binds prop_name property with simple getter, setter that calls bound functions
# and on{prop_name} function of the class.
# This also uses the on_prop_name list of functions to constrain the value
#
# Like x = Property(0)
# y = Property(10, union(int, str))
class Property:
  def __init__(self, default_value=None, *on_prop_name):
    self.default_value = default_value
    self.on_prop_name = on_prop_name

  def generate_prop(class_self, self, prop_name, new_default_value = None):
    #def Property(prop_name, on_prop_name = None):
    #if new_default_value is not None:
    #  setattr(self.__class__, f'_{prop_name}', new_default_value)
    #else:
    self.__class__.property_list.append(prop_name)
    setattr(self.__class__, f'_{prop_name}', class_self.default_value)
    if new_default_value is not None:
      for on_prop_fun in class_self.on_prop_name:
        new_default_value = on_prop_fun(new_default_value)
      setattr(self, f'_{prop_name}', new_default_value)
    else:
      setattr(self, f'_{prop_name}', deepcopy(class_self.default_value))

    def _get(self):
      return getattr(self, f'_{prop_name}', class_self.default_value)

    def _set(self, value):
      if getattr(self, f'_{prop_name}') != value:

        old_val = getattr(self, f'_{prop_name}')

        for on_prop_fun in class_self.on_prop_name:
          value = on_prop_fun(value)

        setattr(self, f'_{prop_name}', value)

        if getattr(self, f'on_{prop_name}', None):
          getattr(self, f'on_{prop_name}')(prop=prop_name, value=value, old_val=old_val)

        if prop_name in self.properties:
          for func in self.properties[prop_name]:
            func(self, prop=prop_name, value=value, old_val=old_val)

    setattr(self.__class__, prop_name, property(_get, _set))


# --- Entity

# Base Entity class.
class Entity:
  #property_list = []

  # allows binding at runtime
  #def bind(self, prop_name, func):
  def bind(self, **kwargs):
    for prop_name, func in kwargs.items():
      if prop_name in self.property_list:
        if prop_name not in self.properties:
          self.properties[prop_name] = []
        self.properties[prop_name].append(func)
  def unbind(self, **kwargs):
    for prop_name, func in kwargs.items():
      self.properties[prop_name].remove(func)

  # manually dispatch change
  # used for non reporting types like lists or dicts
  def dispatch(self, prop_name, *largs, **kwargs):
    _on_fun = getattr(self, f'on_{prop_name}', None)
    if _on_fun:
      _on_fun(*largs, **kwargs)
    for cb in self.properties.get(prop_name, []):
      cb(self, *largs, **kwargs)

  def __repr__(self):
    return str(dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')])))

  def __str__(self):
    return str(dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')])))
  
  def __getitem__(self, item):
    return getattr(self, item)

  def __setitem__(self, item, value):
    return setattr(self, item, value)

  def to_dict(self):
    return dict(zip([i for i in self.property_list if not i.startswith('_')], [getattr(self, p) for p in self.property_list if not p.startswith('_')]))

  def __init__(self, **kwargs):
    self.components = []
    self.properties = {}
    if 'property_list' not in dir(self):
      self.__class__.property_list = []

    for base in reversed(self.__class__.__bases__[1:]):
      if Component in base.__bases__:
        self.components.append(base)
      #base.__init__(self, **kwargs)

    for attr in dir(self.__class__):
      if getattr(self.__class__, attr).__class__ == Property:
        self.properties[attr] = []
        getattr(self.__class__, attr).generate_prop(self, attr, kwargs.get(attr, None))

      if attr in self.property_list:
        setattr(self, attr, kwargs.get(attr, getattr(self.__class__, f'_{attr}')))
        _on_fun = kwargs.get(f'on_{attr}', None)
        if _on_fun:
          self.bind(**{attr: _on_fun})


# --- Components

# Component shell
class Component:
  pass

# --- Engine

class Engine:
  def __init__(self, *systems):
    self.systems = systems
    self.entities = {}

  def tick(self, delta=0):
    for system in self.systems:
      system.tick(delta)

  def add(self, *entities):
    for system in self.systems:
      system.add(*entities)
    for en in entities:
      if en.__class__.__name__ not in self.entities:
        self.entities[en.__class__.__name__] = []
      self.entities[en.__class__.__name__].append(en)

  def remove(self, *entities):
    for system in self.systems:
      system.remove(*entities)
    for en in entities:
      self.entities[en.__class__.__name__].remove(en)

# --- System

class System:
  components = []

  def __init__(self):
    self.entities = []

  def add(self, *entities):
    for en in entities:
      for component in self.components:
        if component in en.components and not en in self.entities:
          self.entities.append(en)
          self.on_add(en)

  def on_add(self, entity):
    pass

  def remove(self, *entities):
    for en in entities:
      if en in self.entities:
        self.entities.remove(en)
        self.on_remove(en)

  def on_remove(self, entity):
    pass

  def tick(self, delta=0):
    pass
    
    
def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out

def default(value):
  def _default(obj):
    return obj or value
  return _default
  
def ig(obj, prop):
  return [i[prop] for i in obj]

class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    if self.code.splitlines()[0].strip().startswith('props ='):
      row_props = self.code.split('\n\n')[0][7:]
      kwargs = eval(row_props)

    class Row(Entity): pass
    self.Row = Row

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    for h in self.headers:
      setattr(self.Row, h, kwargs.get(h, Property('')))
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        self.table.append(self.Row(**dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]))))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n'
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}\n'
    return out


  def run_code(t):
    @debounce(.25, cache=[])
    def print(*l, cache=[]):
      window.console.log('\n'.join([str(i[0][0]) for i in cache]))
    exec(t.code)
    
  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}
    

# --- end focus

def toggle_onoff(ev):
  classes = ev.currentTarget.className.split(' ')
  if 'check-off' in classes:
    classes.remove('check-off')
    classes.append('check-on')
    ev.currentTarget.state='on'
  else:
    classes.remove('check-on')
    classes.append('check-off')
    ev.currentTarget.state='off'
  ev.currentTarget.className = ' '.join(classes)
  
window.toggle_onoff = toggle_onoff

def make_toggle(text='test', _on='ON', _off='OFF', state='off', on_state=None, Class='button'):
  b = BUTTON(
          DIV(text, Class='label') + 
          DIV(_on, Class='on') +
          DIV(_off, Class='off'),
        Class=f'{Class} ripple check-{state}')
  b.bind('click', toggle_onoff)
  if on_state:
    b.bind('click', on_state)
  b.state=state
  return b

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple():
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'background 0.4s'}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple():
    hover_sty = {'transition': 'background 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple():
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'background 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple():
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)


from browser import document as doc
import re
ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = False
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = True

def on_down(ev):
  global ctrl, tables
  if ev.ctrlKey:
    ctrl=True
  else:
    ctrl=False

  if ev.which == 37 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      #cm_editbox.setOption('lineNumbers', False)
      cm_editbox.setOption('lineWrapping', True)
      cm_editbox.setOption('readOnly', True)
  if ev.which == 39 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      #cm_editbox.setOption('lineNumbers', True)
      cm_editbox.setOption('lineWrapping', False)
      cm_editbox.setOption('readOnly', False)
  if chr(ev.which)=='G' and ctrl:
    start = cm_editbox.getCursor(True).line
    end = cm_editbox.getCursor(False).line
    if start == end:
      print(cm_editbox.getCursor().line + 1)
    else:
      diff = abs(start-end)
      print('{}:{}({})'.format(start+1, end+1, diff+1))
    ev.preventDefault()
    ev.stopPropagation()


@Try(window.make_popup)
def do_table() -> None:
  def print(*l):
    window.make_popup('\n'.join(l))
  window.vdo("?_table_|jmx|/_table_|kmz'xV'zo")
  tab = Table(cm_editbox.getSelection())
  tab.run_code()
  cm_editbox.replaceSelection(str(tab))
  #window.reg('"', str(tab))
  #window.vdo('gvp')
        
def run_table(cm, params):
  do_table()
window.CodeMirror.Vim.defineEx("do_table", None, run_table)

@Try(window.make_popup)
def do_py() -> None:
  @debounce(.25, cache=[])
  def print(*l, cache=[]):
    window.console.log('\n'.join([str(i[0][0]) for i in cache]))
  window.vdo("gv")
  tab = exec(cm_editbox.getSelection())

        
def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)
        
doc.get(selector='.CodeMirror')[0].bind('keydown', on_down)

def showRelativeLines(cm):
  cm.setOption('lineNumbers', cm.state.vim.visualMode)
  lineNum = cm.getCursor().line + 1;

  
  look_at = int(doc.querySelector('.CodeMirror').scrollHeight/12)
  last_line = cm.lastLine()
  if len(cm_editbox.getSelections()) > 1:
    cur_line = cm_editbox.listSelections()[0].anchor.line
    cur_line_bot = cm_editbox.listSelections()[-1].anchor.line
  else:
    cur_line = cm.getCursor(True).line
    cur_line_bot = cm.getCursor(False).line
  line_range = range(cur_line, cur_line_bot+1)
  up = True
  down = True
  for i in range(look_at):
    if _options['limelight']:
      if cm_editbox.state.vim.visualMode:
        if cur_line-i in line_range:
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        if cur_line+i in line_range:
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
      else:
        #going down
        if cur_line+i <= last_line and down and cm.getLine(cur_line+i).strip():
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        elif cur_line+i <= last_line and i:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          down = False
    
        #going up
        if cur_line-i >= 0 and up and cm.getLine(cur_line-i).strip():
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        elif cur_line-i >= 0 and i:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          up = False
    else:
      cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
      cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
    cm.removeLineClass(cur_line-i, 'gutter', 'CodeMirror-activeline-gutter')
    cm.removeLineClass(cur_line+i, 'gutter', 'CodeMirror-activeline-gutter')
  cm.addLineClass(cur_line, 'gutter', 'CodeMirror-activeline-gutter')
      
  if (cm.getCursor().line == lineNum):
    #cm.addLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    #cm.removeLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    return
    
  
  #cm.getCursor().line = lineNum
  def temp(l):
    if l==lineNum:
      return lineNum
    return abs(lineNum-l)
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', showRelativeLines)

def runpy(cm, params):
  exec(params.argString, _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)

def do_reg(_do = "sum(n)", _reg = '"') -> dict:
  args = _do.split(';')
  
  sel = window.CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
  
  l  = re.split(r'\s+', sel)
  li = re.split(r'\s*\n\s*', sel)
  n  = [float(i) for i in re.findall(r'[-+]?[0-9]*\.?[0-9]+', sel)]
  w  = re.findall(r'\w+', sel)
  
  outs = []
  for i in args:
    outs.append(eval(i))
  res = str(dict(zip(args, outs)))
  print(res)
  if len(outs) == 1:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [str(outs[0])]
  else:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [res]
def runnums(cm, params):
  do_reg(params.argString)
window.CodeMirror.Vim.defineEx("nums", None, runnums)
#_options['nums'] = do_reg
_options['do_reg'] = do_reg

def compare(cm, params):
  new = window.CodeMirror.Vim.getRegisterController().getRegister('a').keyBuffer[0]
  old = window.CodeMirror.Vim.getRegisterController().getRegister('d').keyBuffer[0]
  window.make_popup(render_diff(old, new))
window.CodeMirror.Vim.defineEx("compare", None, compare)
window.CodeMirror.Vim.defineEx("diff", None, compare)

def runup(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)

def rundown(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)

def better_sort():
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in _nsre.split(s)]    
  def do_stuff(dat, ns = False):
    if ns:
      return dat
    sets = re.split(r'\n(\s+)?\n+', dat)
    sets = [s for s in sets if s and s.strip()]
    for i in range(len(sets)):
      lines = sets[i].splitlines()
      for line in range(len(lines)):
        lines[line] = lines[line].rstrip()
      locked = []
      for j in range(len(lines)):
        if lines[j].strip().startswith('#'):
          locked.append((j, lines[j]))
      for j in reversed(locked):
        del lines[j[0]]
      #lines = sorted(lines)#, key = natural_sort_key)
      lines = window.natsort(lines)
      for j in locked:
        lines.insert(j[0], j[1])
      sets[i] = '\n'.join(lines)
    return '\n\n'.join(sets)
  cm_editbox.replaceSelection(do_stuff(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  better_sort()
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)

def align_by2(_char = ',', _glue = ''):
  window.vdo('gvo')
  _dat = cm_editbox.getSelection()
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  _dat = cm_editbox.replaceSelection(_out.strip('\n'))
  #window.vdo('gvp')
  #return _out
def run_align_by(cm, params):
  align_by2()
window.CodeMirror.Vim.defineEx("align_by", None, run_align_by)

def run_align_by_colin(cm, params):
  align_by2(':')
window.CodeMirror.Vim.defineEx("align_by_colin", None, run_align_by_colin)

def run_align_by_pipe(cm, params):
  align_by2('|', ' | ')
window.CodeMirror.Vim.defineEx("align_by_pipe", None, run_align_by_pipe)

def run_align_by_equals(cm, params):
  align_by2('=', ' = ')
window.CodeMirror.Vim.defineEx("align_by_equals", None, run_align_by_equals)

</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache"){
          cm_editbox.openNotification('<pre>'+msg+'</pre>')
	}
      //cm_editbox.openNotification('<p>'+msg.split('\n').join('<br>')+'</p>')
      }
      
      console.log=_logger
      console.error=make_popup
      console.warning=make_popup
      </script>
</html>