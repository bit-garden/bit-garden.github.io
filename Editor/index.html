<html>
<title>Blackboard</title>
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}
    
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

.CodeMirror, .CodeMirror-gutters{background:#111111 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}
 
 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:14px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;  
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: #111111;
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888
  }
  .CodeMirror-activeline-gutter > .CodeMirror-linenumber {
	    color: white !important;
	      width: auto !important;
	    }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }
  

input::-webkit-calendar-picker-indicator {
  display: none;
}
  
/* Ripple effect */
.ripple {
  background-position: center;
  transition: background 0.4s;
}
/* hover color need to match */
.ripple:hover {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
.ripple:focus {
  background: #474747 radial-gradient(circle, transparent 1%, #474747 1%) center/15000%;
}
/* pulse color */
.ripple:active {
  background-color: grey;
  background-size: 100%;
  transition: background 0s;
}

/* card style */
.card {
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.red_ripple:hover {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
.red_ripple:focus {
  background: #990000 radial-gradient(circle, transparent 1%, #990000 1%) center/15000%;
}
/* pulse color */
.red_ripple:active {
  background-color: red;
  background-size: 100%;
  transition: background 0s;
}
.red_card{
  background-color: #660000;
}

.green_ripple:hover {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
.green_ripple:focus {
  background: #009900 radial-gradient(circle, transparent 1%, #009900 1%) center/15000%;
}
/* pulse color */
.green_ripple:active {
  background-color: green;
  background-size: 100%;
  transition: background 0s;
}
.green_card{
  background-color: #006600;
}

.blue_ripple:hover {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
.blue_ripple:focus {
  background: #000099 radial-gradient(circle, transparent 1%, #000099 1%) center/15000%;
}
/* pulse color */
.blue_ripple:active {
  background-color: blue;
  background-size: 100%;
  transition: background 0s;
}
.blue_card{
  background-color: #000066;
}

.purple_ripple:hover {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
.purple_ripple:focus {
  background: #990099 radial-gradient(circle, transparent 1%, #990099 1%) center/15000%;
}
/* pulse color */
.purple_ripple:active {
  background-color: purple;
  background-size: 100%;
  transition: background 0s;
}
.purple_card{
  background-color: #660066;
}

.orange_ripple:hover {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
.orange_ripple:focus {
  background: #996600 radial-gradient(circle, transparent 1%, #996600 1%) center/15000%;
}
/* pulse color */
.orange_ripple:active {
  background-color: orange;
  background-size: 100%;
  transition: background 0s;
}
.orange_card{
  background-color: #664400;
}

.button{
  border: none;
  border-radius: 3px;
  padding: 12px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  outline: none;
  background-color:rgba(71,71,71,0);
}

/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  border-radius: 3px;
  padding: 8px 8px;
  margin:6px;
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
  font-family: Mono !important;
}

.input{
  border-bottom: rgba(16,75,121,1) solid 2px;
  padding: 12px 18px 10px 18px;
  transition: border .4s;
}
.input:focus, .input:hover{
  border-bottom: rgba(33,150,243,1) solid 2px;
}

/* checkbox */

input.switch{
  opacity: 0;
  height:0px;
  width:0px;
}

input.switch+div{
  background:rgba(128,128,128,.5);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  display:inline-block;
  overflow:visible;
  border-radius:12px;
  margin:6px;
  width:36px;
}

input.switch:checked+div div.thumb{
  left:24px;
  background:rgba(33,150,243,1);
}

input.switch:focus+div,
input.switch:focus+div div.thumb{
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.2);
  outline:none;
  box-shadow: 0 0px 8px rgba(33,150,243,1);
}

input.switch+div div.thumb{
  content:'off';
  height:24px;
  transition:all .2s;
  width:24px;
  background:rgba(16,75,121,1);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  position:relative;
  left:0px;
  margin:-6px;
  border-radius:12px;
}

/* radio */

input.radio{
  opacity: 0;
  height:0px;
  width:0px;
}

input.radio+div{
  background:rgba(128,128,128,.5);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  display:inline-block;
  overflow:visible;
  border-radius:18px;
  width:12px;
  height:12px;
  padding:6px;
  transition:all .2s;
}

input.radio:checked+div div.thumb{
  background:rgba(33,150,243,1);
  width:16px;
  height:16px;
}

input.radio:checked+div{
  padding:4px;
  height:16px;
  width:16px;
}

input.radio:focus+div,
input.radio:focus+div div.thumb{
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.2);
  outline:none;
  box-shadow: 0 0px 8px rgba(33,150,243,1);
}

input.radio+div div.thumb{
  content:'off';
  height:12px;
  transition:all .2s;
  width:12px;
  background:rgba(16,75,121,1);
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  border-radius:12px;
}

.fab {
  border: none;
  border-radius: 999px;
  padding: 18px 18px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}

.fab-small {
  border: none;
  border-radius: 999px;
  padding: 12px 12px;
  font-size: 16px;
  cursor: default;
  color: white;
  background-color: #222222;
  box-shadow: 0 4px 8px #000;
  outline: none;
}
  
  
</style>
<script>
// Returns if a value is a string
function isString (value) {
return typeof value === 'string' || value instanceof String;
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};



	  CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
{regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	  
{regex: /#(\S|\s\s).*$/, token: "comments"}, // darklights comments
{regex: /#(\s\S.*|\s*$)/, token: "deco"}, // highlights comments
	  
{regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
{regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
//{regex: /[-+]?[0-9]*\.?[0-9]+/, token: "nums"}, // numbers
//{regex: /(__)(.*?)\1/, token: "under"},
//{regex: /(~~)(.*?)\1/, token: "strike"},
//{regex: /(\||--+|:-|:\|)/, token: "nums"},
	  
  ]
});
	  CodeMirror.defineSimpleMode("simplermode", {
  // The start state contains the rules that are intially used
  start: [
{regex: /(\#|\/\/).*$/, token: "comments"}, // darklight comments
  ]
});
</script>
<body onload="brython()">
<textarea class='editbox'></textarea>
</body>
<script>
//CodeMirror.Vim.unmap(';')
CodeMirror.Vim.unmap(',')
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map(',/', ':js timediff()', 'normal')
CodeMirror.Vim.map('fd', '<Esc>', 'insert')
CodeMirror.Vim.map('vb','<Esc>T|<C-v>t|','insert')
CodeMirror.Vim.map(',/', '<Esc>/i', 'insert')
CodeMirror.Vim.map(',?', '<Esc>?i', 'insert')
CodeMirror.Vim.map(',a', '<Esc>A', 'insert')
CodeMirror.Vim.map(',i', '<Esc>I', 'insert')
CodeMirror.Vim.map(',l','<Esc>f|la','insert')
CodeMirror.Vim.map(',h','<Esc>2F|la','insert')
CodeMirror.Vim.map(',j','<Esc>F|lja','insert')
CodeMirror.Vim.map(',k','<Esc>F|lka','insert')
CodeMirror.Vim.map(';;','<Esc>:','insert')
CodeMirror.Vim.map('cw','<Esc>lciwi','insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')
CodeMirror.Vim.map(',l','f|ll','normal')
CodeMirror.Vim.map(',h','2F|ll','normal')
CodeMirror.Vim.map(',j','F|ljl','normal')
CodeMirror.Vim.map(',k','F|lkl','normal')
//CodeMirror.Vim.map(';;',':','normal')
CodeMirror.Vim.map(',<Space>', ':noh', 'normal')
//CodeMirror.Vim.map(',e', '@e', 'normal') //Short mapping to e macro
//more maps?
//CodeMirror.Vim.map('<C-t>', "mzyy'tP`zdd", 'normal')
//CodeMirror.Vim.map('Y', '"Ay', 'visual')

//CodeMirror.Vim.map('zv', ":vdo ?---|jmx|/---|kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zv', "[-jmx]-kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zb', ":vblock", 'normal')

CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|l', 'normal')
CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|a', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|l', 'normal')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|a', 'insert')
CodeMirror.Vim.map(',o', ':vdo oi', 'insert')
CodeMirror.Vim.map(',O', ':vdo Oi', 'insert')
CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')
CodeMirror.Vim.map('<C-y>', ':vdo vip|:better_sort', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')
CodeMirror.Vim.map(',y', ':js sort_by()', 'visual')
CodeMirror.Vim.map(',,', ':align_by', 'visual')
CodeMirror.Vim.map(',;', ':align_by_colin', 'visual')
CodeMirror.Vim.map(',=', ':align_by_equals', 'visual')
CodeMirror.Vim.map(',\\', ':align_by_pipe', 'visual')

CodeMirror.Vim.map(']-', ':vdo :js move_to("---")|_', 'normal')
CodeMirror.Vim.map('[-', ':vdo :js move_to("---", false)|_', 'normal')

//CodeMirror.Vim.map("''", ':vdo :js put(\'"\')|a', 'insert')

//CodeMirror.Vim.map('cb', ':vdo :js put("[\'")|a', 'insert')
//CodeMirror.Vim.map('bc', ':vdo :js put("\']")|a', 'insert')

//CodeMirror.Vim.map('..', ':DoubleD', 'insert')

CodeMirror.Vim.map('gt', ':vdo /--- Cal|/\\[TODAY\\]|zb', 'normal')

CodeMirror.Vim.map(',r', ':js alignRight()', 'visual')
CodeMirror.Vim.map(',l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map(',c', ':js alignCenter()', 'visual')

CodeMirror.Vim.unmap('s', 'visual')
CodeMirror.Vim.map("s'" , ":js surround(\"'\", \"'\")", 'visual')
CodeMirror.Vim.map('s"' , ":js surround('\"' , '\"')" , 'visual')
CodeMirror.Vim.map("s\\", ":js surround('|'  , '|')"  , 'visual')

CodeMirror.Vim.map("sd", ":js surround(\"['\"  , \"']\")"  , 'visual')
CodeMirror.Vim.map("s[", ":js surround('['  , ']')"  , 'visual')
CodeMirror.Vim.map("s{", ":js surround('{'  , '}')"  , 'visual')
CodeMirror.Vim.map("s(", ":js surround('('  , ')')"  , 'visual')

CodeMirror.Vim.map("s_", ":js surround('_'  , '_')"  , 'visual')



  editbox = document.querySelector('.editbox')
  if ('data' in localStorage){
    editbox.value = localStorage.getItem('data')
  }
  cm_editbox = CodeMirror.fromTextArea(editbox,{
              'matchBrackets':     true,
              'autoCloseBrackets': false,
              'lineNumbers':       false,
              "mode":              'simplemode',
              "theme":             "material",
              'tabSize':           2,
              'styleActiveLine':   true,
              'keyMap':            'vim',
              'extraKeys':         {"Ctrl-Space": "autocomplete"}
   })
   function tab_to_space(cm){
    cm.execCommand("insertSoftTab")
  }
  cm_editbox.addKeyMap({'Ctrl-C': false})
  cm_editbox.addKeyMap({'Tab': tab_to_space})
  
  function on_change(cm, _change){
    cm_editbox.save()
    localStorage.setItem('data', editbox.value);
  }
  
  cm_editbox.on('change',on_change)
  
  function ac_hint(cm){
    cm.showHint({'hint': CodeMirror.hint.anyword})
  }
  CodeMirror.commands.autocomplete = ac_hint
  
  function runjs(cm, params){
    eval(params.argString)
  }
  
  CodeMirror.Vim.defineEx("js", null, runjs)

function put(_text, pre=false){
  reg('z', _text)
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  if (!pre)
    vdo(':js key("<Esc>")|l"zp')
  else
    vdo(':js key("<Esc>")|l"zP')
}

function _surround(i, l, r){
  if (i.trim().length > 0){
    return l + i + r
  }else{
    return i
  }
}

function surround(l = "'", r = "'"){
vdo('gvy')
yanked = reg('"').split('\n')
yanked = yanked.map((i)=> _surround(i, l, r))
reg('"', yanked.join('\n'))
//reg('"', l + reg('"').trim() + r)
vdo('gvp')
}

function key(_key){
  CodeMirror.Vim.handleKey(cm_editbox, _key, 'macro')
}

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}
  
function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}
//sort natural order in tables
function itemgetter(keys){
    return function test2(_dict){
        out = ''
        keys.forEach((e)=>out+=_dict[e]+'|')
        return out
    }
}
function sort_dicts(_dicts, _keys){
  keys = itemgetter(_keys)
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  return _dicts.sort((a, b) => collator.compare(keys(a), keys(b)))
}

//testing char skipping, not space skipping exclusively. 
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}

function toclip(dat){
navigator.clipboard.writeText(dat.toString())
  .then(() => {
    console.log(dat.toString() + ' to clip.');
  })
  .catch(err => {
    // This can happen if the user denies clipboard permissions:
    console.error('Could not copy text: ', err);
  });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0
  
  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replaceAll('<bar>', '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)

function vblock(cm, params){
  vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

//function runclip(cm, params){
//  sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0].trim()
//  sel.split('\n').forEach((i)=>{
//    CodeMirror.Vim.handleEx(cm_editbox, i)
//  })
//}
//CodeMirror.Vim.defineEx("runclip", null, runclip)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function timediff(){
vdo('Vy') // > @"
sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
d = new Date()
newtime = [d.getMonth()+1,d.getDate(),d.getFullYear()].join('/') + ' ' + [d.getHours(), d.getMinutes()].join(':')
sel = sel.replace('%c', newtime)

if(sel.includes('%d')){
  vdo('kyy')
  var re_time = /\d+\/\d+\/\d+\ \d+:\d+/
  sel2 = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  last_time = sel2.match(re_time)
  last_time = new Date(last_time)
  diffmin = parseInt((d - last_time) / (1000 * 60)); 
  sel = sel.replace('%d', diffmin)
}
// for days , parseInt((date2 - date1) / (1000 * 60 * 60 * 24)); 
CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel
vdo('gvp') // < @"
}

function make_popup(_dat, _height = '10em'){
  cm_editbox.openDialog('<textarea style="font-family: Mono; white-space: pre;  overflow: auto; outline: none;border:none; background:none; color:white;width:100%; height:'+_height+'">'+_dat+'</textarea><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}

function make_simple_popup(_dat){
  cm_editbox.openDialog('<p style="background:none; color:white;width:100%; height:10em">'+_dat.replaceAll('\n','<br>')+'</p><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}


function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}

function DoubleD(cm, params){
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  if (line.substring(startch+1, startch+3) == "']"){
    vdo('lla')
  }else{
    put("['']")
    vdo('ha')
  }
  //vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  //CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('DoubleD', null, DoubleD)

function DoubleTap(cm, params){
  var pairs = [['"', '"'], ["'", "'"], ['(', ')'], ['[', ']'], ['{', '}']]
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  var character = params.argString.trim()
  var cur_character = line.substring(startch, startch+1)
  pairs.forEach((pair) => {
    if (character == cur_character && character == pair[1] && !line.substring(startch-1, startch).match(/\\/)){
      vdo('la')
    //}else if (character == pair[0] && character == "'" && line.substring(startch-1, startch).match(/\w/)){
    //  put(pair[0])
    //  vdo('la')
    }else if (character == pair[0]){
      put(pair[0])
      put(pair[1])
      vdo('a')
    }else if (character == pair[1]){
      put(pair[1])
      vdo('la')
    }
  })
}
//CodeMirror.Vim.defineEx('DoubleTap', null, DoubleTap)
//
//CodeMirror.Vim.map("'", ":DoubleTap '", 'insert')
//CodeMirror.Vim.map('"', ':DoubleTap "', 'insert')
//CodeMirror.Vim.map("[", ":DoubleTap [", 'insert')
//CodeMirror.Vim.map("]", ":DoubleTap ]", 'insert')
//CodeMirror.Vim.map("(", ":DoubleTap (", 'insert')
//CodeMirror.Vim.map(")", ":DoubleTap )", 'insert')
//CodeMirror.Vim.map("{", ":DoubleTap {", 'insert')
//CodeMirror.Vim.map("}", ":DoubleTap }", 'insert')
CodeMirror.Vim.map("''", ":vdo :js put(\"''\")|i", 'insert')
CodeMirror.Vim.map("((", ":vdo :js put(\"()\")|i", 'insert')
CodeMirror.Vim.map("[[", ":vdo :js put(\"[]\")|i", 'insert')
CodeMirror.Vim.map("{{", ":vdo :js put(\"{}\")|i", 'insert')
CodeMirror.Vim.map('""', ':vdo :js put(\'""\')|i', 'insert')
CodeMirror.Vim.map("<<", ":vdo :js put(\"<>\")|i", 'insert')

function kpos(cm, params){
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function notes(cm, params){
  make_popup(`^e in normal insert visual
finds between _table_ markers(or visual) and runs as table

,\\ visual
aligns by |
,, ,= visual 
aligns by , or = respectively
,; visual
aligns by :

^j ^k normal
goes up or down to non whitespace character

^y normal visual
sort visual or vip

,y visualblock
sort by visualblock

,l ,c ,r visualblock
align left, center, right

vw insert
select word, then yank word

cw insert
change word or next word

s' s" s[ s\\ s{ s( s_ visual
surrounds by ' " [] | {} () _

,a insert
escape A

,I insert
escape I

vb insert
select between |

zv normal
select between ---

zb normal
select in table section

kj insert normal
auto complete based on file contents

jk fd insert
escape 

,/ ,? insert
search forward or backward and drop back to insert

,h ,j ,k ,l insert normal
jump between | and - respectivly for tables

;; insert normal
command line

,<space>
stop search highlight

]- [- normal
jump to ---

'' insert
place "

# re stuff
(,)(?=(?:[^"]|"[^"]*")*$) # csv: capture unencolsed ',' chars
(\\#|\\/\\/)(\\S|\\s\\s).*$ # Big comment
(\\#|\\/\\/)\\s.*$ # Small comments
\\w?"([^"\\\\]|\\\\.)*("|$) # Double quotes
(?![ \\{\\(\\[])\\w?'([^'\\\\]|\\\\.)*'\\s*(?=[\\)\\],:\\}.$ ])/ # Single quote code
(^| )'([^']|'\\w)*'( |$) # Single quote prose

# non complete calendar events
\| (?!-)\S[^\|]+

# find by surrounding 
(__)(.*?)\\1

# shuffle search
/(?:([dameagrirnbne])(?!.*?\\1)){13}/.exec($0.innerText)
/(?:([trarneicoos])(?!.*?\\1)){11}/.exec($0.innerText)

# quick sanity check on table
class Row(Entity):
  prop = Property()
for i in t._indices: r[i] = Row(**r[i]).to_dict()


`)
}
CodeMirror.Vim.defineEx('notes', null, notes)

</script>
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

# small hacks to be more asyncio like
from browser import aio
import traceback


from browser.html import *
from browser import document as doc

# for table magic
from operator import itemgetter
import itertools

import re


def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

from browser import window

aio.cancel = window.CustomEvent.new('cancel')

async def select_event(el, events):
  events += ' cancel'

  def on_event(ev):
    event['triggered'] = ev
    for e in event['events'].split(' '):
      el.unbind(e, event['on_event'])

  event = {'events': events,
            'triggered': None, # Should be the event that fires when done
            'on_event': on_event}
  
  for e in events.split(' '):
    el.bind(e, on_event)

  while event['triggered'] is None:
    await aio.sleep(0)
    
  return event['triggered']
    
def cancel_event(el):
  el.dispatchEvent(aio.cancel)

aio.select_event = select_event
aio.cancel_event = cancel_event
  
# --- new entity stuff

# --- Literal type backport from 3.8 version
# will be used for sanity checking specific possibilities

from typing import *
from typing import _GenericAlias
import typing 

class _LiteralForm(typing._SpecialForm, _root=True):

  def __repr__(self):
    return 'typing_extensions.' + self._name

  def __getitem__(self, parameters):
    return _GenericAlias(self, parameters)

Literal = _LiteralForm('Literal',
            doc="""A type that can be used to indicate to type checkers
            that the corresponding value has a value literally equivalent
            to the provided parameter. For example:
              var: Literal[4] = 4
            The type checker understands that 'var' is literally equal to
            the value 4 and no other value.
            Literal[...] cannot be subclassed. There is no runtime
            checking verifying that the parameter is actually a value
            instead of a type.""")


from dataclasses import dataclass, field

import inspect
import typing
from contextlib import suppress
from functools import wraps

def validate_type(name, type_hint, value):
  """Validates value against type_hint.
  
  This doesn't check in depth for List, Set and so on.
  This additionally treats strings as Any so future typing can be done.
  """
  
  if not isinstance(type_hint, typing._SpecialForm):
    # No check for typing.Any, typing.Union, typing.ClassVar (without parameters)
    is_literal = False # for literal checking
    try:
      actual_type = type_hint.__origin__
    except AttributeError:
      actual_type = type_hint
    if actual_type == Literal:
      is_literal = True
    if isinstance(actual_type, typing._SpecialForm):
      # case of typing.Union[...] or typing.ClassVar[...]
      actual_type = type_hint.__args__

    if type(actual_type) == str:
      return
      
    if is_literal:
      if value not in actual_type:
        raise TypeError('Unexpected value for \'{}\' (expected {} but found {})'.format(name, type_hint, value))

    elif not isinstance(value, actual_type):
      raise TypeError('Unexpected type for \'{}\' (expected {} but found {})'.format(name, type_hint, type(value)))

def bind(self, **kw):
  """Bind callbacks to properties."""
  for prop, fun in kw.items():
    if prop not in self._callbacks:
      self._callbacks[prop] = []
    self._callbacks[prop].append(fun)
    
def unbind(self, **kw):
  """Unbind callbacks to properties."""
  for prop, fun in kw.items():
    self._callbacks[prop].remove(fun)
    if not self._callbacks[prop]:
      del self._callbacks[prop]
      
class On_attr:
  """Customer attribute to delegate changes to a property."""
  def __init__(self, type, name, bindable=False):
    self.type = type
    self.name = name
    self.bindable = bindable # for faster check if _callbacks is used

  # set name not working in current brython version

  def __get__(self, instance, owner):
    if not instance: return self
    return instance.__dict__[self.name]

  def __delete__(self, instance):
    del instance.__dict__[self.name]

  def __set__(self, instance, value):
    """Validate type, on_prop_vali, on_prop, then _callbacks."""
    validate_type(self.name, self.type, value)

    curval = instance.__dict__.get(self.name, self)

    instance.__dict__[self.name] = value

    if curval != self:
      if value != curval:
        on_prop = getattr(instance, f'on_{self.name}', None)
        if on_prop:
          on_prop(curval, value)
        if self.bindable:
          if self.name in instance._callbacks:
            for i in instance._callbacks[self.name]:
              i(instance, curval, value)


def enforce_types(callable):
  """Decorator to bind On_attr on annotated properties.
  
  Also attaches bind/unbind if _callbacks dictionary is annotated.
  
  Also checks incoming annotated parameters for __init__ or decorated functions.
  """
  
  spec = inspect.getfullargspec(callable)
  annos = spec.annotations
  annos.pop('return')

  def check_types(*args, **kwargs):
    parameters = dict(zip(spec.args, args))
    parameters.update(kwargs)
    for name, value in parameters.items():
      with suppress(KeyError): # Assume un-annotated parameters can be any type
        type_hint = spec.annotations[name]
        validate_type(name, type_hint, value)

  def decorate(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
      check_types(*args, **kwargs)
      return func(*args, **kwargs)
    return wrapper

  if inspect.isclass(callable):
    callable.__init__ = decorate(callable.__init__)
    bindable = False
    if '_callbacks' in annos:
      bindable = True
      callable.bind = bind
      callable.unbind = unbind
    for k, v in annos.items():
      setattr(callable, k, On_attr(v, k, bindable))
    return callable

  return decorate(callable)


def strip_dict(_dict):
  """Strip out keys with leading _.
  
  This seams more readable to the eye for simply hiding properties compared to field(...)
  """
  
  return {k: v for k, v in _dict.items() if not k.startswith('_')}

@dataclass
class Engine:
  """Organizes classes to be quickly referenced later.
  
  This takes supplied entities, gets their base classes and makes a dictionary
    referring to all the classes. This is looked up as a dictionary with __getitem__.
  """
  entities: list = field(default_factory=list)
  components: list = field(default_factory=list)
  objs: dict = field(default_factory=dict)

  def __post_init__(self):
    for e in self.entities:
      self.objs[e] = []
      for base in e.__bases__:
        self.objs[base] = []
        self.components.append(base)

  def load(self, data):
    """Load dictionary and create objects as needed."""
    for k,v in self.objs.items():
      if k in self.entities and k.__name__ in data:
        for item in data[k.__name__]:
          self.add(k(**item))
          
  def __repr__(self):
    """Strip out private properties and print out a evalable nested dictionary."""
    return str({e.__name__: [strip_dict(i.__dict__) for i in self.objs[e]] for e in self.entities})

  def __getitem__(self, key):
    return self.objs[key]

  def add(self, obj):
    self.objs[obj.__class__].append(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].append(obj)

  def remove(self, obj):
    self.objs[obj.__class__].remove(obj)
    for b in obj.__class__.__bases__:
      self.objs[b].remove(obj)
      
# end new entity stuff

# throttle and debounce are left here, but will have async versions nativly
  

import time

# do not run first pass
# restart timer each call, within wait
# only call last instance
def debounce(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """
  def decorator(fn):
    def debounced(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        if cache is not None:
          tc = cache[:]
          cache.clear()
          fn(*args, cache=tc, **kwargs)
        else:
          fn(*args, **kwargs)
      try:
        window.clearTimeout(debounced.t)
      except(AttributeError):
        pass
      debounced.t = window.setTimeout(call_it, int(wait*1000))
      #debounced.t.start()
    return debounced
  return decorator


# run first pass
# only call last instance
def throttle(wait, cache=None):
  """ Decorator that will postpone a functions
    execution until after wait seconds
    have elapsed since the last time it was invoked. """

  def decorator(fn):
    def throttled(*args, **kwargs):
      if cache is not None:
        cache.append([args, kwargs])
      def call_it():
        throttled._timer = None
        throttled._last_call = time.time()
        if cache is not None:
          tc = cache[:]
          cache.clear()
          return fn(*args, cache=tc, **kwargs)
        else:
          return fn(*args, **kwargs)

      time_since_last_call = time.time() - throttled._last_call
      if time_since_last_call >= wait:
        return call_it()

      if throttled._timer is None:
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()
      else:
        window.clearTimeout(throttled._timer)
        throttled._timer = window.setTimeout(call_it, int(wait*1000))
        #throttled._timer.start()

    throttled._timer = None
    throttled._last_call = 0

    return throttled

  return decorator

# Use to get groups of data
def group_data(data, column):
  out = {}
  sorted_data = sorted(data, key=itemgetter(column))
  for key, group in itertools.groupby(sorted_data, key=lambda x:x[column]):
    out[key] = list(group)
  return out
    
def align_by(_dat, _char = ',', _glue = ''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out
  
def ig(obj, prop):
  return [i[prop] for i in obj]

from dataclasses import dataclass, field
from typing import *
import re
  
base_table_str = '''
from typing import *
from dataclasses import field

@enforce_types
@dataclass
class R:
  _callbacks: dict = field(default_factory=dict)
  _sub_table: str = ''
  pass

  def __getitem__(self, key):
    return self.__dict__[key]

  def __setitem__(self, key, value):
    return setattr(self, key, value)

  def __repr__(self):
    return str(strip_dict(self.__dict__))
  
locals()['R'] = R
'''

def trycast(d, anno):
  for k, v in d.items():
    try:
      validate_type(k, anno[k], v)
    except:
      d[k] = anno[k](v)
      
class Table:
  all_items = property(lambda self: self._all_items)
  sub_table = property(lambda self: self.gd['_sub_table'])
  
  def __init__(self, data, **kwargs):
    
    self.code = ''
    if '\n#__code__\n' in data:
      data, self.code = data.split('\n#__code__\n')

    _dat = data.strip().splitlines()
    
    self.title = ''
    if _dat[0].startswith('#'):
      self.title = _dat.pop(0)
      
    self.headers = [i.strip() for i in _dat.pop(0).split('|')]
    self.aligns = _dat.pop(0)
    self.table = []
    self._sub_tables = []
    self._all_items = []
    self.lpad = min(len(i) - len(i.lstrip()) for i in _dat)
    
    prop_str = ''
    prop_dict = {}

    row_props = self.code.split('\n\n')[0]
    for i in row_props.splitlines():
      if ':' in i:
        prop_dict[i.split(':')[0]] = i

    for h in self.headers:
      if h not in prop_dict:
        prop_str += f"\n  {h}: Any = ''"
      else:
        prop_str += f"\n  {prop_dict[h]}"

    loc = {}
    exec(base_table_str.replace('pass', prop_str), globals(), loc)

    self.Row = loc['R']
    
    last_sub_table = ''
    
    while len(_dat):
      if _dat[0].strip().startswith('---'):
        last_sub_table = _dat[0].strip().replace('-', '')
        if last_sub_table not in self._sub_tables:
          self._sub_tables.append(last_sub_table)
        _dat.pop(0)
        
      else:
        #self.table.append(dict(zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')])))
        _d = {k:v for k, v in zip(self.headers, [i.strip() for i in _dat.pop(0).split('|')]) if v != ''}
        trycast(_d, self.Row.__annotations__)
        self.table.append(self.Row(**_d))
        self.table[-1]['_sub_table'] = last_sub_table
        self._all_items.append(self.table[-1])
        if not last_sub_table and '' not in self._sub_tables:
          self._sub_tables.append('')
    
    self.gd = {i: group_data(self.table, i) for i in self.headers+['_sub_table']}
    self.gd['_all_items'] = self._all_items
    
  def __getitem__(self, item):
    return self.gd[item]
    
  def __str__(self):
    out = ''
    if self.title:
      out += f'{self.title}\n'
    
    out += " "*self.lpad + '|'.join(self.headers) + '\n'
    
    out += f'{self.aligns}\n'
    
    for sub_tab in self._sub_tables:
      if sub_tab or (not sub_tab and sub_tab != self._sub_tables[0]):
        out += f'{" "*self.lpad}---{sub_tab}\n' 
      out += '\n'.join([" "*self.lpad + '|'.join([str(i[head]) for head in self.headers]) for i in self.sub_table[sub_tab]])+'\n'
    out = align_by(out, '|', ' | ')
    if self.code:
      out += f'\n#__code__\n{self.code.strip()}'
    return out


  def run_code(t):
    @debounce(.25, cache=[])
    def print(*l, cache=[]):
      window.console.log('\n'.join([str(i[0][0]) for i in cache]))
    exec(t.code)

  def sub_group(self, sub_tab):
    if type(sub_tab) == str:
      return {i: group_data(self.sub_table[sub_tab], i)  for i in self.headers}
    else:
      return {i: group_data(sub_tab, i)  for i in self.headers}
    

# --- end focus

@enforce_types
def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

@enforce_types
def SWITCH(text:str , state: bool = False, Type: Literal['checkbox', 'radio'] = 'checkbox', Class: Literal['switch', 'radio'] = 'switch', name: str = '') -> LABEL:
  return LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'})
  )

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple():
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s'}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple():
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple():
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple():
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)



ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = False
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = True

#def on_down(ev):
#  global ctrl, tables
#  if ev.ctrlKey:
#    ctrl=True
#  else:
#    ctrl=False
#
#  if ev.which == 37 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', False)
#      cm_editbox.setOption('lineWrapping', True)
#      cm_editbox.setOption('readOnly', True)
#  if ev.which == 39 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', True)
#      cm_editbox.setOption('lineWrapping', False)
#      cm_editbox.setOption('readOnly', False)
#  if chr(ev.which)=='G' and ctrl:
#    start = cm_editbox.getCursor(True).line
#    end = cm_editbox.getCursor(False).line
#    if start == end:
#      print(cm_editbox.getCursor().line + 1)
#    else:
#      diff = abs(start-end)
#      print('{}:{}({})'.format(start+1, end+1, diff+1))
#    ev.preventDefault()
#    ev.stopPropagation()



def do_table() -> None:
  try:
    @debounce(.25, cache=[])
    def print(*l, cache=[]):
      window.console.log('\n'.join([str(i[0][0]) for i in cache]))
    window.vdo("?_table_|jmx|/_table_|kmz'xV'zo")
    tab = Table(cm_editbox.getSelection())
    tab.run_code()
    cm_editbox.replaceSelection(str(tab))
    #window.reg('"', str(tab))
    #window.vdo('gvp')
  except:
    window.make_popup(traceback.format_exc())
        
def run_table(cm, params):
  do_table()
window.CodeMirror.Vim.defineEx("do_table", None, run_table)


def do_py() -> None:
  try:
    @debounce(.25, cache=[])
    def print(*l, cache=[]):
      window.console.log('\n'.join([str(i[0][0]) for i in cache]))
    window.vdo("gv")
    tab = exec(cm_editbox.getSelection())
  except:
    window.make_popup(traceback.format_exc())

        
def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)
        
#doc.get(selector='.CodeMirror')[0].bind('keydown', on_down)

def showRelativeLines(cm):
  cm.setOption('lineNumbers', cm.state.vim.visualMode)
  lineNum = cm.getCursor().line + 1;

  
  look_at = int(doc.querySelector('.CodeMirror').scrollHeight/12)
  last_line = cm.lastLine()
  if len(cm_editbox.getSelections()) > 1:
    cur_line = cm_editbox.listSelections()[0].anchor.line
    cur_line_bot = cm_editbox.listSelections()[-1].anchor.line
  else:
    cur_line = cm.getCursor(True).line
    cur_line_bot = cm.getCursor(False).line
  line_range = range(cur_line, cur_line_bot+1)
  up = True
  down = True
  for i in range(look_at):
    if _options['limelight']:
      if cm_editbox.state.vim.visualMode:
        if cur_line-i in line_range:
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        if cur_line+i in line_range:
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
      else:
        #going down
        if cur_line+i <= last_line and down and cm.getLine(cur_line+i).strip():
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        elif cur_line+i <= last_line and i:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          down = False
    
        #going up
        if cur_line-i >= 0 and up and cm.getLine(cur_line-i).strip():
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        elif cur_line-i >= 0 and i:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          up = False
    else:
      cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
      cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
    cm.removeLineClass(cur_line-i, 'gutter', 'CodeMirror-activeline-gutter')
    cm.removeLineClass(cur_line+i, 'gutter', 'CodeMirror-activeline-gutter')
  cm.addLineClass(cur_line, 'gutter', 'CodeMirror-activeline-gutter')
      
  if (cm.getCursor().line == lineNum):
    #cm.addLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    #cm.removeLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    return
    
  
  #cm.getCursor().line = lineNum
  def temp(l):
    if l==lineNum:
      return lineNum
    return abs(lineNum-l)
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', showRelativeLines)

def runpy(cm, params):
  exec(params.argString, _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)

def do_reg(_do = "sum(n)", _reg = '"') -> dict:
  args = _do.split(';')
  
  sel = window.CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
  
  l  = re.split(r'\s+', sel)
  li = re.split(r'\s*\n\s*', sel)
  n  = [float(i) for i in re.findall(r'[-+]?[0-9]*\.?[0-9]+', sel)]
  w  = re.findall(r'\w+', sel)
  
  outs = []
  for i in args:
    outs.append(eval(i))
  res = str(dict(zip(args, outs)))
  print(res)
  if len(outs) == 1:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [str(outs[0])]
  else:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [res]
def runnums(cm, params):
  do_reg(params.argString)
window.CodeMirror.Vim.defineEx("nums", None, runnums)
#_options['nums'] = do_reg
_options['do_reg'] = do_reg

def compare(cm, params):
  new = window.CodeMirror.Vim.getRegisterController().getRegister('a').keyBuffer[0]
  old = window.CodeMirror.Vim.getRegisterController().getRegister('d').keyBuffer[0]
  window.make_popup(render_diff(old, new))
window.CodeMirror.Vim.defineEx("compare", None, compare)
window.CodeMirror.Vim.defineEx("diff", None, compare)

def runup(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)

def rundown(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)

def better_sort():
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in _nsre.split(s)]    
  def do_stuff(dat, ns = False):
    if ns:
      return dat
    sets = re.split(r'\n(\s+)?\n+', dat)
    sets = [s for s in sets if s and s.strip()]
    for i in range(len(sets)):
      lines = sets[i].splitlines()
      for line in range(len(lines)):
        lines[line] = lines[line].rstrip()
      locked = []
      for j in range(len(lines)):
        if lines[j].strip().startswith('#'):
          locked.append((j, lines[j]))
      for j in reversed(locked):
        del lines[j[0]]
      #lines = sorted(lines)#, key = natural_sort_key)
      lines = window.natsort(lines)
      for j in locked:
        lines.insert(j[0], j[1])
      sets[i] = '\n'.join(lines)
    return '\n\n'.join(sets)
  cm_editbox.replaceSelection(do_stuff(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except:
    traceback.print_exc()
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)

def align_by2(_char = ',', _glue = ''):
  window.vdo('gvo')
  _dat = cm_editbox.getSelection()
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  _dat = cm_editbox.replaceSelection(_out.strip('\n'))
  #window.vdo('gvp')
  #return _out
def run_align_by(cm, params):
  align_by2()
window.CodeMirror.Vim.defineEx("align_by", None, run_align_by)

def run_align_by_colin(cm, params):
  align_by2(':')
window.CodeMirror.Vim.defineEx("align_by_colin", None, run_align_by_colin)

def run_align_by_pipe(cm, params):
  align_by2('|', ' | ')
window.CodeMirror.Vim.defineEx("align_by_pipe", None, run_align_by_pipe)

def run_align_by_equals(cm, params):
  align_by2('=', ' = ')
window.CodeMirror.Vim.defineEx("align_by_equals", None, run_align_by_equals)

#--- async stuff

async def snack(content, delay=5):
  # make element
  _snack = DIV(content, Class='card',
                style={
                  'position': 'fixed',
                  'z-index': '2',
                  'bottom': '-16px',
                  'left': '50%',
                  'transform': 'translate(-50%, 100%)',
                  'transition': 'transform .4s, bottom .4s'
                })
  # attach to doc
  doc <= _snack
  await aio.sleep(.05)
  # update pos
  _snack.style['bottom'] = '16px'
  _snack.style['transform'] = 'translate(-50%, 0%)'
  # sleep for 5
  await aio.sleep(.4+delay)
  # update pos
  _snack.style['bottom'] = '-16px'
  _snack.style['transform'] = 'translate(-50%, 100%)'
  await aio.sleep(.4)
  _snack.remove()
  # return

async def snackbar():
  window.snacks = []
  while True:
    while window.snacks:
      val = window.snacks.pop(0)
      await snack(val)
      
    await aio.sleep(0)
    
async def popup(content):
  frame = DIV(Class='darken', style={
    'background': 'rgba(0, 0, 0, 0)',
    'transition': 'background .4s',
    'width': '100%',
    'height': '100%',
    'position': 'fixed',
    'top': '0px',
    'left': '0px',
    'z-index': '1'
  })

  box = DIV(content, Class='card', style={
    'position': 'absolute',
    'left': '12.5%',
    'top': '25%',
    'opacity': 0,
    'width': '75%',
    'height': '75%',
    'margin': '-16px',
    'transition': 'opacity .4s, top .4s'
  })

  frame <= box

  doc <= frame

  await aio.sleep(.05)
  frame.style['background'] = 'rgba(0, 0, 0, .5)'
  box.style['opacity'] = 1
  box.style['top'] = '12.5%'

  # to allow clicks within the popup
  while True:
    ev = await aio.select_event(frame, 'click')
    if ev.type == 'cancel' or ev.target == frame:
      break

  # Try to break all awaiting UI.
  for el in box.querySelectorAll('*'):
    aio.cancel_event(el)

  frame.style['background'] = 'rgba(0, 0, 0, 0)'
  box.style['opacity'] = 0
  box.style['top'] = '25%'
  await aio.sleep(.4)

  frame.remove()
  

#async def main():
#  res = await aio.gather(snackbar())
#  window.make_popup('Snackbar died')
#
#aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache" && msg != 'empty stack'){
          cm_editbox.openNotification('<pre>'+msg+'</pre>')
	}
      //cm_editbox.openNotification('<p>'+msg.split('\n').join('<br>')+'</p>')
      }
      
      console.log=_logger
      console.error=make_popup
      console.warning=make_popup
      </script>
</html>