<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}
    
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

.CodeMirror, .CodeMirror-gutters{background:#111111 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}
 .cm-decorator{color: #ffaaff;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}
 
 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:14px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;  
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: #111111;
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888
  }
  .CodeMirror-activeline-gutter > .CodeMirror-linenumber {
	    color: white !important;
	      width: auto !important;
	    }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }
  

input::-webkit-calendar-picker-indicator {
  display: none;
}

/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  /*border-radius: 3px;*/
  padding: 8px 8px;
  /*margin:6px;*/
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: #222222;
  /*box-shadow: 0 4px 8px #000;*/
  outline: none;
  font-family: Mono !important;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}
  
</style>
<script>
// Returns if a value is a string
function isString (value) {
return typeof value === 'string' || value instanceof String;
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};



	  CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
{regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	  
{regex: /#(\S|\s\s).*$/, token: "comments"}, // darklights comments
{regex: /#(\s\S.*|\s*$)/, token: "deco"}, // highlights comments
{regex: /\s*\@\w+/, token: "decorator"}, // highlights comments
	  
{regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
{regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
//{regex: /[-+]?[0-9]*\.?[0-9]+/, token: "nums"}, // numbers
//{regex: /(__)(.*?)\1/, token: "under"},
//{regex: /(~~)(.*?)\1/, token: "strike"},
{regex: / \|( |$)/, token: "nums"},
{regex: /^\s*---+/, token: "nums", sol:true},
{regex: /---+$/, token: "nums"},
	  
  ]
});
	  CodeMirror.defineSimpleMode("simplermode", {
  // The start state contains the rules that are intially used
  start: [
{regex: /(\#|\/\/).*$/, token: "comments"}, // darklight comments
  ]
});
</script>
<body onload="brython({indexedDB: false})"></body>
<textarea class='editbox'></textarea>
</body>
<script>
//CodeMirror.Vim.unmap(';')
CodeMirror.Vim.unmap(',')
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map(',/', ':js timediff()', 'normal')
CodeMirror.Vim.map('fd', '<Esc>', 'insert')
CodeMirror.Vim.map('vb','<Esc>T|<C-v>t|','insert')
CodeMirror.Vim.map(',/', '<Esc>/i', 'insert')
CodeMirror.Vim.map(',?', '<Esc>?i', 'insert')
CodeMirror.Vim.map(',a', '<Esc>A', 'insert')
CodeMirror.Vim.map(',i', '<Esc>I', 'insert')
CodeMirror.Vim.map(',l','<Esc>f|la','insert')
CodeMirror.Vim.map(',h','<Esc>2F|la','insert')
CodeMirror.Vim.map(',j','<Esc>F|lja','insert')
CodeMirror.Vim.map(',k','<Esc>F|lka','insert')
CodeMirror.Vim.map(';;','<Esc>:','insert')
CodeMirror.Vim.map('cw','<Esc>lciwi','insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')
CodeMirror.Vim.map(',l','f|ll','normal')
CodeMirror.Vim.map(',h','2F|ll','normal')
CodeMirror.Vim.map(',j','F|ljl','normal')
CodeMirror.Vim.map(',k','F|lkl','normal')
//CodeMirror.Vim.map(';;',':','normal')
CodeMirror.Vim.map(',<Space>', ':noh', 'normal')
//CodeMirror.Vim.map(',e', '@e', 'normal') //Short mapping to e macro
//more maps?
//CodeMirror.Vim.map('<C-t>', "mzyy'tP`zdd", 'normal')
//CodeMirror.Vim.map('Y', '"Ay', 'visual')

//CodeMirror.Vim.map('zv', ":vdo ?---|jmx|/---|kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zv', "[-jmx]-kmz'xV'zo", 'normal')
CodeMirror.Vim.map('zb', ":vblock", 'normal')

CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|l', 'normal')
CodeMirror.Vim.map('<C-e>', ':vdo :kpos|:do_table|:rpos|a', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|l', 'normal')
CodeMirror.Vim.map(',e', ':vdo :kpos|vip,\\|:rpos|a', 'insert')
CodeMirror.Vim.map(',o', ':vdo oi', 'insert')
CodeMirror.Vim.map(',O', ':vdo Oi', 'insert')
CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')
CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')
CodeMirror.Vim.map(',y', ':js sort_by()', 'visual')
CodeMirror.Vim.map(',,', ':align_by', 'visual')
CodeMirror.Vim.map(',;', ':align_by_colin', 'visual')
CodeMirror.Vim.map(',=', ':align_by_equals', 'visual')
CodeMirror.Vim.map(',\\', ':align_by_pipe', 'visual')

CodeMirror.Vim.map(']-', ':vdo :js move_to("---")|_', 'normal')
CodeMirror.Vim.map('[-', ':vdo :js move_to("---", false)|_', 'normal')

//CodeMirror.Vim.map("''", ':vdo :js put(\'"\')|a', 'insert')

//CodeMirror.Vim.map('cb', ':vdo :js put("[\'")|a', 'insert')
//CodeMirror.Vim.map('bc', ':vdo :js put("\']")|a', 'insert')

//CodeMirror.Vim.map('..', ':DoubleD', 'insert')

CodeMirror.Vim.map('gt', ':vdo /--- Cal|/\\[TODAY\\]|zb', 'normal')

CodeMirror.Vim.map(',r', ':js alignRight()', 'visual')
CodeMirror.Vim.map(',l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map(',c', ':js alignCenter()', 'visual')

CodeMirror.Vim.unmap('s', 'visual')
CodeMirror.Vim.map("s'" , ":js surround(\"'\", \"'\")", 'visual')
CodeMirror.Vim.map('s"' , ":js surround('\"' , '\"')" , 'visual')
CodeMirror.Vim.map("s\\", ":js surround('|'  , '|')"  , 'visual')

CodeMirror.Vim.map("sd", ":js surround(\"['\"  , \"']\")"  , 'visual')
CodeMirror.Vim.map("s[", ":js surround('['  , ']')"  , 'visual')
CodeMirror.Vim.map("s{", ":js surround('{'  , '}')"  , 'visual')
CodeMirror.Vim.map("s(", ":js surround('('  , ')')"  , 'visual')

CodeMirror.Vim.map("s_", ":js surround('_'  , '_')"  , 'visual')
CodeMirror.Vim.map("s<", ":js surround('<'  , '>')"  , 'visual')



  editbox = document.querySelector('.editbox')
  if ('data' in localStorage){
    editbox.value = localStorage.getItem('data')
  }
  cm_editbox = CodeMirror.fromTextArea(editbox,{
              'matchBrackets':     true,
              'autoCloseBrackets': false,
              'lineNumbers':       false,
              "mode":              'simplemode',
              "theme":             "material",
              'tabSize':           2,
              'styleActiveLine':   true,
              'keyMap':            'vim',
              'extraKeys':         {"Ctrl-Space": "autocomplete"}
   })
   function tab_to_space(cm){
    cm.execCommand("insertSoftTab")
  }
  cm_editbox.addKeyMap({'Ctrl-C': false})
  cm_editbox.addKeyMap({'Tab': tab_to_space})
  
  function on_change(cm, _change){
    cm_editbox.save()
    localStorage.setItem('data', editbox.value);
  }
  
  cm_editbox.on('change',on_change)
  
  function ac_hint(cm){
    cm.showHint({'hint': CodeMirror.hint.anyword})
  }
  CodeMirror.commands.autocomplete = ac_hint
  
  function runjs(cm, params){
    eval(params.argString)
  }
  
  CodeMirror.Vim.defineEx("js", null, runjs)

function put(_text, pre=false){
  reg('z', _text)
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  if (!pre)
    vdo('l"zp')
  else
    vdo('l"zP')
}

function _surround(i, l, r){
  if (i.trim().length > 0){
    return l + i + r
  }else{
    return i
  }
}

function surround(l = "'", r = "'"){
vdo('gvy')
yanked = reg('"').split('\n')
yanked = yanked.map((i)=> _surround(i, l, r))
reg('"', yanked.join('\n'))
//reg('"', l + reg('"').trim() + r)
vdo('gvp')
}

function key(_key){
  CodeMirror.Vim.handleKey(cm_editbox, _key, 'macro')
}
CodeMirror.Vim.defineEx("key", null, key)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}
  
function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}
//sort natural order in tables
function itemgetter(keys){
    return function test2(_dict){
        out = ''
        keys.forEach((e)=>out+=_dict[e]+'|')
        return out
    }
}
function sort_dicts(_dicts, _keys){
  keys = itemgetter(_keys)
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  return _dicts.sort((a, b) => collator.compare(keys(a), keys(b)))
}

//testing char skipping, not space skipping exclusively. 
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}

function toclip(dat){
navigator.clipboard.writeText(dat.toString())
  .then(() => {
    console.log(dat.toString() + ' to clip.');
  })
  .catch(err => {
    // This can happen if the user denies clipboard permissions:
    console.error('Could not copy text: ', err);
  });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0
  
  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replaceAll('<bar>', '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)

function vblock(cm, params){
  vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

//function runclip(cm, params){
//  sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0].trim()
//  sel.split('\n').forEach((i)=>{
//    CodeMirror.Vim.handleEx(cm_editbox, i)
//  })
//}
//CodeMirror.Vim.defineEx("runclip", null, runclip)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}

function timediff(){
vdo('Vy') // > @"
sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
d = new Date()
newtime = [d.getMonth()+1,d.getDate(),d.getFullYear()].join('/') + ' ' + [d.getHours(), d.getMinutes()].join(':')
sel = sel.replace('%c', newtime)

if(sel.includes('%d')){
  vdo('kyy')
  var re_time = /\d+\/\d+\/\d+\ \d+:\d+/
  sel2 = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  last_time = sel2.match(re_time)
  last_time = new Date(last_time)
  diffmin = parseInt((d - last_time) / (1000 * 60)); 
  sel = sel.replace('%d', diffmin)
}
// for days , parseInt((date2 - date1) / (1000 * 60 * 60 * 24)); 
CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel
vdo('gvp') // < @"
}

function make_popup(_dat, _height = '10em'){
  cm_editbox.openDialog('<textarea style="font-family: Mono; white-space: pre;  overflow: auto; outline: none;border:none; background:none; color:white;width:100%; height:'+_height+'">'+_dat+'</textarea><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}

function make_simple_popup(_dat){
  cm_editbox.openDialog('<p style="background:none; color:white;width:100%; height:10em">'+_dat.replaceAll('\n','<br>')+'</p><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}


function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}

function DoubleD(cm, params){
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  if (line.substring(startch+1, startch+3) == "']"){
    vdo('lla')
  }else{
    put("['']")
    vdo('ha')
  }
  //vdo("F<bar>l|:runup|ljmxh|:rundown|kf<bar>hhmz|v`x")
  //CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('DoubleD', null, DoubleD)

function DoubleTap(cm, params){
  var pairs = [['"', '"'], ["'", "'"], ['(', ')'], ['[', ']'], ['{', '}']]
  var allLines = editbox.value.split("\n");
  var start = cm_editbox.getCursor().line
  var startch = cm_editbox.getCursor().ch
  var line = allLines[start]
  var character = params.argString.trim()
  var cur_character = line.substring(startch, startch+1)
  pairs.forEach((pair) => {
    if (character == cur_character && character == pair[1] && !line.substring(startch-1, startch).match(/\\/)){
      vdo('la')
    //}else if (character == pair[0] && character == "'" && line.substring(startch-1, startch).match(/\w/)){
    //  put(pair[0])
    //  vdo('la')
    }else if (character == pair[0]){
      put(pair[0])
      put(pair[1])
      vdo('a')
    }else if (character == pair[1]){
      put(pair[1])
      vdo('la')
    }
  })
}
//CodeMirror.Vim.defineEx('DoubleTap', null, DoubleTap)
//
//CodeMirror.Vim.map("'", ":DoubleTap '", 'insert')
//CodeMirror.Vim.map('"', ':DoubleTap "', 'insert')
//CodeMirror.Vim.map("[", ":DoubleTap [", 'insert')
//CodeMirror.Vim.map("]", ":DoubleTap ]", 'insert')
//CodeMirror.Vim.map("(", ":DoubleTap (", 'insert')
//CodeMirror.Vim.map(")", ":DoubleTap )", 'insert')
//CodeMirror.Vim.map("{", ":DoubleTap {", 'insert')
//CodeMirror.Vim.map("}", ":DoubleTap }", 'insert')
//CodeMirror.Vim.map("''", ":vdo :js put(\"''\")|i", 'insert')
//CodeMirror.Vim.map("((", ":vdo :js put(\"()\")|i", 'insert')
//CodeMirror.Vim.map("[[", ":vdo :js put(\"[]\")|i", 'insert')
//CodeMirror.Vim.map("{{", ":vdo :js put(\"{}\")|i", 'insert')
//CodeMirror.Vim.map('""', ':vdo :js put(\'""\')|i', 'insert')
//CodeMirror.Vim.map("<<", ":vdo :js put(\"<>\")|i", 'insert')

function kpos(cm, params){
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function notes(cm, params){
  make_popup(`^e in normal insert visual
finds between _table_ markers(or visual) and runs as table

,\\ visual
aligns by |
,, ,= visual 
aligns by , or = respectively
,; visual
aligns by :

^j ^k normal
goes up or down to non whitespace character

^y normal visual
sort visual or vip

,y visualblock
sort by visualblock

,l ,c ,r visualblock
align left, center, right

vw insert
select word, then yank word

cw insert
change word or next word

s' s" s[ s\\ s{ s( s_ visual
surrounds by ' " [] | {} () _

,a insert
escape A

,I insert
escape I

vb insert
select between |

zv normal
select between ---

zb normal
select in table section

kj insert normal
auto complete based on file contents

jk fd insert
escape 

,/ ,? insert
search forward or backward and drop back to insert

,h ,j ,k ,l insert normal
jump between | and - respectivly for tables

;; insert normal
command line

,<space>
stop search highlight

]- [- normal
jump to ---

'' insert
place "

# re stuff
(,)(?=(?:[^"]|"[^"]*")*$) # csv: capture unencolsed ',' chars
(\\#|\\/\\/)(\\S|\\s\\s).*$ # Big comment
(\\#|\\/\\/)\\s.*$ # Small comments
\\w?"([^"\\\\]|\\\\.)*("|$) # Double quotes
(?![ \\{\\(\\[])\\w?'([^'\\\\]|\\\\.)*'\\s*(?=[\\)\\],:\\}.$ ])/ # Single quote code
(^| )'([^']|'\\w)*'( |$) # Single quote prose

# non complete calendar events
\| (?!-)\S[^\|]+

# find by surrounding 
(__)(.*?)\\1

# shuffle search
/(?:([dameagrirnbne])(?!.*?\\1)){13}/.exec($0.innerText)
/(?:([trarneicoos])(?!.*?\\1)){11}/.exec($0.innerText)

# quick sanity check on table
class Row(Entity):
  prop = Property()
for i in t._indices: r[i] = Row(**r[i]).to_dict()


`)
}
CodeMirror.Vim.defineEx('notes', null, notes)

</script>
<script src="lib/brython_aio.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import aio, window
from browser import window
from browser import document as doc
from browser.html import *
#import time
#import traceback

import _jsre as re

def split(pat, string):
  out = []
  _string = string
  found = re.findall(pat, string)

  while found:
    tar = found.pop(0)
    out.append(_string.split(tar)[0])
    _string = tar.join(_string.split(tar)[1:])
  out.append(_string)
  return out

re.split = split

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e
    
    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones
  
aio.gather = gather
aio.Task = Task

class Dimension:
  def __init__(self, bottom, height, left, right, top, width):
    self.bottom = bottom
    self.height = height
    self.left = left
    self.right = right
    self.top = top
    self.width = width
    self.center = (left + (width/2), top + (height/2))
    
  def __repr__(self):
    return "{" + f"'top': {repr(self.top)}, 'bottom': {repr(self.bottom)}, 'left': {repr(self.left)}, 'right': {repr(self.right)}, 'height': {repr(self.height)}, 'width': {repr(self.width)}, 'center': {repr(self.center)}" + "}"

def getdim(el):
  br = el.getBoundingClientRect()
  out = {
          'bottom': br.bottom,
          'height': br.height,
          'left': br.left,
          'right': br.right,
          'top': br.top,
          'width': br.width
          }
  return Dimension(**out)
  
class Event:
  ''' 
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html
  '''
  
  def __init__(self, *):
    self._set = False
    
  async def wait(self):
    while not self._set:
      await aio.sleep(0)
      
  def is_set(self):
    return self._set
    
  def set(self):
    self._set = True
    
  def clear(self):
    self._set = False
    
aio.Event = Event

class Lock:
  def __init__(self, *):
    self._locked = False

  async def acquire(self):
    while self._locked:
      await aio.sleep(0)
    self._locked = True

  def release(self):
    if not self._locked:
      raise RuntimeError('Lock is already released')
    self._locked = False

  def locked(self):
    return self._locked

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()

aio.Lock = Lock

class Semaphore:
  def __init__(self, value=1, *):
    self._locked = False
    self.count = value
    self.limit = value

  async def acquire(self):
    while self.count < 1:
      await aio.sleep(0)
    self.count -= 1

  def release(self):
    self.count = min(self.count + 1, self.limit)

  def locked(self):
    return self.count == 0

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()
    
aio.Semaphore = Semaphore

def itemgetter(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return obj[item]
  else:
    def g(obj):
      return tuple(obj[item] for item in items)
  return g


class groupby:
  # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
  # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
  def __init__(self, iterable, key=None):
    if key is None:
      key = lambda x: x
    self.keyfunc = key
    self.it = iter(iterable)
    self.tgtkey = self.currkey = self.currvalue = object()
  def __iter__(self):
    return self
  def __next__(self):
    self.id = object()
    while self.currkey == self.tgtkey:
      self.currvalue = next(self.it)  # Exit on StopIteration
      self.currkey = self.keyfunc(self.currvalue)
    self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
  def _grouper(self, tgtkey, id):
    while self.id is id and self.currkey == tgtkey:
      yield self.currvalue
      try:
        self.currvalue = next(self.it)
      except StopIteration:
        return
      self.currkey = self.keyfunc(self.currvalue)

def label(_dat):
  labs = {}
  for idx, i in enumerate(_dat):
    if i[0].startswith('---'):
      labs[i[0].strip('-')] = idx
  
  return labs
      
def align_by(_dat, _char=',', _glue='', _code=''):
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())



  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  if _code:
    #exec(_code, {'dat': dat, 'Stagger': Stagger, 'Throttle': Throttle, 'align_by': align_by, 'popup': popup, 'Popup': Popup})
    #_tempGlobals = dict(globals())
    #_tempGlobals['dat'] = dat
    #exec(_code, _tempGlobals)
    exec(_code)
    dat = [[str(j) for j in i] for i in dat]
    
  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  return _out

# --- end focus

def ICON(_icon: str) -> I:
  return I(_icon, Class='material-icons')

def SWITCH(text: str , state: bool = False, Type: ['checkbox', 'radio'] = 'checkbox', Class: ['switch', 'radio'] = 'switch', name: str = '') -> LABEL:
  return DIV(LABEL(
    SPAN(text, style={'padding': '16px'})
    + INPUT(Type=Type, Class=Class, name=name, checked=state)
    + DIV(DIV(Class='thumb'), style={'float': 'right'}),
    style={'width':'100%'}
  ), style={'display':'flex', 'align-items': 'center'})

def make_ripple(el, base_color='#222222', hover_color='#474747', pulse_color='grey', no_key=False):
  def prep_ripple(*_):
    base_sty = {'background-color': base_color, 'background-position': 'center', 'transition': 'all 0.4s','transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',}
    for k, v in base_sty.items():
      el.style[k] = v

  def pre_ripple(*_):
    hover_sty = {'transition': 'all 0.4s', 'background': f'{hover_color} radial-gradient(circle, transparent 1%, {hover_color} 1%) center/15000%'}

    for k, v in hover_sty.items():
      el.style[k] = v

  def do_ripple(*_):
    active_sty = {'background-color': pulse_color, 'background-size': '100%', 'transition': 'all 0s'}

    for k, v in active_sty.items():
      el.style[k] = v
    
    window.setTimeout(pre_ripple, 50)

  def _do_ripple(*_):
    pre_ripple()
    window.setTimeout(do_ripple, 400)
    window.setTimeout(pre_ripple, 450)
    window.setTimeout(prep_ripple, 600)
  
  def _key_ripple(ev):
    if ev.key=='Enter' or ev.key==' ':
      do_ripple()
  
  prep_ripple()
  el.bind('mouseover', pre_ripple)
  el.bind('focus', pre_ripple)
  el.bind('mousedown', do_ripple)
  #el.bind('mouseup', pre_ripple)
  el.bind('mouseout', prep_ripple)
  el.bind('blur', prep_ripple)
  
  if not no_key:
    el.bind('keydown', _key_ripple)
  
  return (el, _do_ripple)



ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = True
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = True

#def on_down(ev):
#  global ctrl, tables
#  if ev.ctrlKey:
#    ctrl=True
#  else:
#    ctrl=False
#
#  if ev.which == 37 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', False)
#      cm_editbox.setOption('lineWrapping', True)
#      cm_editbox.setOption('readOnly', True)
#  if ev.which == 39 and ctrl:
#    if not cm_editbox.state.vim.insertMode:
#      ev.preventDefault()
#      ev.stopPropagation()
#      #cm_editbox.setOption('lineNumbers', True)
#      cm_editbox.setOption('lineWrapping', False)
#      cm_editbox.setOption('readOnly', False)
#  if chr(ev.which)=='G' and ctrl:
#    start = cm_editbox.getCursor(True).line
#    end = cm_editbox.getCursor(False).line
#    if start == end:
#      print(cm_editbox.getCursor().line + 1)
#    else:
#      diff = abs(start-end)
#      print('{}:{}({})'.format(start+1, end+1, diff+1))
#    ev.preventDefault()
#    ev.stopPropagation()



def do_table() -> None:
  try:
    window.vdo("?_table_|jmx|/_table_|kmz'xV'zo")
    data = cm_editbox.getSelection()

    code = ''
    if '\n#__code__\n' in data:
      data, code = data.split('\n#__code__\n')

    out = align_by(data, '|', ' | ', code)
    if code:
      out += f'\n#__code__\n{code.strip()}'
    cm_editbox.replaceSelection(out)
    #window.reg('"', str(tab))
    #window.vdo('gvp')
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())
        
def run_table(cm, params):
  do_table()
window.CodeMirror.Vim.defineEx("do_table", None, run_table)


def do_py() -> None:
  try:
    window.vdo("gv")
    tab = exec(cm_editbox.getSelection())
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())

        
def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)

def gen(cmd, sel):
  if 'res' in cmd:
    lpad = ' ' * max(len(i) - len(i.lstrip()) for i in sel)
    sel = [j.strip() for j in sel]
    return '\n'.join(f'{lpad}{eval(i)}' for i in sel)

  if 'enum' in cmd:
    lpad = ' ' * max(len(i) - len(i.lstrip()) for i in sel)
    sel = [j.strip() for j in sel]
    return '\n'.join(f'{lpad}{v} = {k}' for k, v in enumerate(sel))

  if 'genself' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)

    out = '\n'.join(f'{" "*lpad}self.{i.strip()} = {i.strip()}' for i in sel)
    return out
    
  if 'genprop' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad

    out = []
    for i in [j.strip() for j in sel]:
      out.append(f'{lpad}@property\n{lpad}def {i}(self):\n{ipad}return self.__{i}')
      out.append(f'{lpad}@{i}.setter\n{lpad}def {i}(self, value):\n{ipad}self.__{i} = value\n')

    return '\n'.join(out)

  if 'genrepr' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad

    gens = ', '.join([repr(i) + ': {repr(self.' + i + ')}' for i in (j.strip() for j in sel)])
    out = f'{lpad}def __repr__(self):\n{ipad}return "{{" + f"{gens}" + "}}"' 
    return out

  if 'genunpack' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad
    gens = ', '.join(['self.' + i for i in (j.strip() for j in sel)])
    return f'''{lpad}def __iter__(self):
{ipad}yield from ({gens})'''

  if 'genbind' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad

    out = []
    for i in [j.strip() for j in sel]:
      out.append(f'{lpad}@property\n{lpad}def {i}(self):\n{ipad}return self._{i}')
      out.append(f'{lpad}@{i}.setter\n{lpad}def {i}(self, value):\n{ipad}if not hasattr(self, "_{i}"): self._{i} = value\n{ipad}oldval, self._{i} = self._{i}, value\n{ipad}if oldval != value: self.dispatch("{i}", oldval, value)\n')

    return '\n'.join(out)

  if 'dropbind' in cmd:
    return '''
  def bind(self, **kwargs):
    for k, v in kwargs.items():
      if k not in self._cbs:
        self._cbs[k] = []
      self._cbs[k].append(v)

  def unbind(self, **kwargs):
    for k, v in kwargs.items():
      self._cbs[k].remove(v)
      if not self._cbs[k]:
        del self._cbs[k]

  def dispatch(self, prop, *l, **kw):
    if getattr(self, f'on_{prop}', None):
      getattr(self, f'on_{prop}')(prop, *l, **kw)
    if prop in self._cbs:
      for cb in self._cbs[prop]:
        cb(self, prop, *l, **kw)
  '''.strip('\n')

  if 'compare' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad

    sel = [j.strip() for j in sel]
    compsl = ', '.join(f'self.{i}' for i in sel)
    compsr = ', '.join(f'other.{i}' for i in sel)
    return f'''
{lpad}def __eq__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) == ({compsr})
{lpad}  return NotImplemented
{lpad}def __ne__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) != ({compsr})
{lpad}  return NotImplemented
{lpad}def __lt__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) < ({compsr})
{lpad}  return NotImplemented
{lpad}def __le__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) <= ({compsr})
{lpad}  return NotImplemented
{lpad}def __gt__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) > ({compsr})
{lpad}  return NotImplemented
{lpad}def __ge__(self, other):
{lpad}  if other.__class__ is self.__class__:
{lpad}    return ({compsl}) >= ({compsr})
{lpad}  return NotImplemented'''.strip('\n')


  if 'genclass' in cmd:
    lpad = max(len(i) - len(i.lstrip()) for i in sel)
    ipad = lpad + 2

    lpad = ' ' * lpad
    ipad = ' ' * ipad

    cls = sel.pop(0).strip()
    sel = [j.strip() for j in sel]
    selvars = [j.split('=')[0].strip() for j in sel]

    out = [f'{lpad}class {cls}:']
    out.append(f'{ipad}def __init__(self, ' + ', '.join(sel) + '):')

    for i in selvars:
      out.append(f'{ipad}  self.{i} = {i}')

    if 'bind' in cmd:
      out.append(f'{ipad}  self._cbs = {{}}\n')
      out.append(f'''
{lpad}  def bind(self, **kwargs):
{lpad}    for k, v in kwargs.items():
{lpad}      if k not in self._cbs:
{lpad}        self._cbs[k] = []
{lpad}      self._cbs[k].append(v)
{lpad}
{lpad}  def unbind(self, **kwargs):
{lpad}    for k, v in kwargs.items():
{lpad}      self._cbs[k].remove(v)
{lpad}      if not self._cbs[k]:
{lpad}        del self._cbs[k]
{lpad}
{lpad}  def dispatch(self, prop, *l, **kw):
{lpad}    if getattr(self, f'on_{{prop}}', None):
{lpad}      getattr(self, f'on_{{prop}}')(prop, *l, **kw)
{lpad}    if prop in self._cbs:
{lpad}      for cb in self._cbs[prop]:
{lpad}        cb(self, prop, *l, **kw)
  '''.strip('\n'))


    if 'prop' in cmd and 'bind' not in cmd:
      out.append('')
      for i in selvars:
        out.append(f'{lpad}  @property\n{lpad}  def {i}(self):\n{ipad}  return self.__{i}')
        out.append(f'{lpad}  @{i}.setter\n{lpad}  def {i}(self, value):\n{ipad}  self.__{i} = value\n')

    elif 'prop' in cmd:
      for i in selvars:
        out.append(f'{lpad}  @property\n{lpad}  def {i}(self):\n{ipad}  return self._{i}')
        out.append(f'{lpad}  @{i}.setter\n{lpad}  def {i}(self, value):\n{ipad}  if not hasattr(self, "_{i}"): self._{i} = value\n{ipad}  oldval, self._{i} = self._{i}, value\n{ipad}  if oldval != value: self.dispatch("{i}", oldval, value)\n')

    if 'unpack' in cmd:
      gens = ', '.join(['self.' + i for i in (j.strip() for j in selvars)])
      out.append(f'''{lpad}  def __iter__(self):
{lpad}    yield from ({gens})\n''')

    if 'repr' in cmd:
      gens = ', '.join([repr(i) + ': {repr(self.' + i + ')}' for i in selvars])
      out.append(f'{lpad}  def __repr__(self):\n{ipad}  return "{{" + f"{gens}" + "}}"')

    return '\n'.join(out)

def run_gen(cm, params):
  window.vdo('gvo')
  _dat = cm_editbox.getSelection()
  _dat = gen(params.argString.split(' '), _dat.split('\n'))
  cm_editbox.replaceSelection(_dat)
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
window.CodeMirror.Vim.defineEx("gen", None, run_gen)
        
#doc.get(selector='.CodeMirror')[0].bind('keydown', on_down)

def showRelativeLines(cm):
  cm.setOption('lineNumbers', cm.state.vim.visualMode)
  lineNum = cm.getCursor().line + 1;

  
  look_at = int(doc.querySelector('.CodeMirror').scrollHeight/12)
  last_line = cm.lastLine()
  if len(cm_editbox.getSelections()) > 1:
    cur_line = cm_editbox.listSelections()[0].anchor.line
    cur_line_bot = cm_editbox.listSelections()[-1].anchor.line
  else:
    cur_line = cm.getCursor(True).line
    cur_line_bot = cm.getCursor(False).line
  line_range = range(cur_line, cur_line_bot+1)
  up = True
  down = True
  for i in range(look_at):
    if _options['limelight']:
      if cm_editbox.state.vim.visualMode:
        if cur_line-i in line_range:
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        if cur_line+i in line_range:
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        else:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
      else:
        #going down
        if cur_line+i <= last_line and down and cm.getLine(cur_line+i).strip():
          cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        elif cur_line+i <= last_line and i:
          cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          down = False
    
        #going up
        if cur_line-i >= 0 and up and cm.getLine(cur_line-i).strip():
          cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        elif cur_line-i >= 0 and i:
          cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          up = False
    else:
      cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
      cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
    cm.removeLineClass(cur_line-i, 'gutter', 'CodeMirror-activeline-gutter')
    cm.removeLineClass(cur_line+i, 'gutter', 'CodeMirror-activeline-gutter')
  cm.addLineClass(cur_line, 'gutter', 'CodeMirror-activeline-gutter')
      
  if (cm.getCursor().line == lineNum):
    #cm.addLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    #cm.removeLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
    return
    
  
  #cm.getCursor().line = lineNum
  def temp(l):
    if l==lineNum:
      return lineNum
    return abs(lineNum-l)
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', showRelativeLines)

def runpy(cm, params):
  exec(params.argString, _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)

def do_reg(_do = "sum(n)", _reg = '"') -> dict:
  args = _do.split(';')
  
  sel = window.CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
  
  l  = re.split(r'\s+', sel)
  li = re.split(r'\s*\n\s*', sel)
  n  = [float(i) for i in re.findall(r'[-+]?[0-9]*\.?[0-9]+', sel)]
  w  = re.findall(r'\w+', sel)
  
  outs = []
  for i in args:
    outs.append(eval(i))
  res = str(dict(zip(args, outs)))
  print(res)
  if len(outs) == 1:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [str(outs[0])]
  else:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [res]
def runnums(cm, params):
  do_reg(params.argString)
window.CodeMirror.Vim.defineEx("nums", None, runnums)
#_options['nums'] = do_reg
_options['do_reg'] = do_reg

def compare(cm, params):
  new = window.CodeMirror.Vim.getRegisterController().getRegister('a').keyBuffer[0]
  old = window.CodeMirror.Vim.getRegisterController().getRegister('d').keyBuffer[0]
  window.make_popup(render_diff(old, new))
window.CodeMirror.Vim.defineEx("compare", None, compare)
window.CodeMirror.Vim.defineEx("diff", None, compare)

def runup(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)

def rundown(cm, params):
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)

def better_sort():
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in _nsre.split(s)]    
  def do_stuff(dat, ns = False):
    if ns:
      return dat
    sets = re.split(r'\n(\s+)?\n+', dat)
    sets = [s for s in sets if s and s.strip()]
    for i in range(len(sets)):
      lines = sets[i].splitlines()
      for line in range(len(lines)):
        lines[line] = lines[line].rstrip()
      locked = []
      for j in range(len(lines)):
        if lines[j].strip().startswith('#'):
          locked.append((j, lines[j]))
      for j in reversed(locked):
        del lines[j[0]]
      #lines = sorted(lines)#, key = natural_sort_key)
      lines = window.natsort(lines)
      for j in locked:
        lines.insert(j[0], j[1])
      sets[i] = '\n'.join(lines)
    return '\n\n'.join(sets)
  cm_editbox.replaceSelection(do_stuff(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except Exception as e:
    window.make_popup(str(e))
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)

def align_by2(_char = ',', _glue = ''):
  window.vdo('gvo')
  _dat = cm_editbox.getSelection()
  if not _glue:
    _glue = _char + ' '

  dat = [[j.strip() for j in i.split(_char)] for i in _dat.splitlines()]
  title = ''
  if dat[0][0].startswith('#'):
    dat.pop(0)
    title = _dat.splitlines()[0]

  if title:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines()[1:])
  else:
    lpad = min(len(i) - len(i.lstrip()) for i in _dat.splitlines())

  max_len = max(len(i) for i in dat)
  for i in dat:
    if i[0].startswith('---'):
      del i[1:]
      i[0] = i[0].replace('-', '')
      i[0] = '---' + i[0] + '---'
    i.extend(['']*(max_len-len(i)))

  def is_label(item):
    if item.startswith('---'):
      return 0
    else:
      return len(item)
  widths = [max(map(is_label, col)) for col in zip(*dat)]
  total_width = '{:-<' + str(sum(widths) + len(_glue)*(max_len - 1)) + '}'

  if len(dat) > 2:
    for i in range(len(dat[1])):
      if dat[1][i].endswith(':') and dat[1][i].startswith(':'):
        widths[i] = '{:^' + str(widths[i]) + '}'
      elif dat[1][i].endswith(':'):
        widths[i] = '{:>' + str(widths[i]) + '}'
      else:
        widths[i] = '{:<' + str(widths[i]) + '}'
  else:
    widths = ['{:<' + str(i) + '}' for i in widths]


  _out = ''
  if title:
    _out = title + '\n'
  for row in dat:
    if row[0].startswith('---'):
      _out += ' ' * lpad + total_width.format(row[0]) + '\n'
    else:
      _out += ' ' * lpad + _glue.join((width.format(val) for val, width in zip(row, widths))).rstrip() + '\n'
  _dat = cm_editbox.replaceSelection(_out.strip('\n'))
  #window.vdo('gvp')
  #return _out
def run_align_by(cm, params):
  align_by2()
window.CodeMirror.Vim.defineEx("align_by", None, run_align_by)

def run_align_by_colin(cm, params):
  align_by2(':')
window.CodeMirror.Vim.defineEx("align_by_colin", None, run_align_by_colin)

def run_align_by_pipe(cm, params):
  align_by2('|', ' | ')
window.CodeMirror.Vim.defineEx("align_by_pipe", None, run_align_by_pipe)

def run_align_by_equals(cm, params):
  align_by2('=', ' = ')
window.CodeMirror.Vim.defineEx("align_by_equals", None, run_align_by_equals)

#--- async stuff
    

class Popup:
  lock = aio.Lock()

  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', Id='popupbg', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1',
    })

    self.box = DIV(style={
      'position': 'fixed',
      'opacity': 0,
      'transition': 'opacity .3s, top .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'border': 'none',
      'color': 'white',
      'outline': 'none',
      'z-index': '1',
      'max-height': '100%',
      'max-width': '100%',
    })

  async def __aenter__(self):
    await self.lock.acquire()
    self._root <= self.frame
    self._root <= self.box

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1
    
    return self.box
    
  async def __aexit__(self, type, value, traceback):
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    await aio.sleep(.4)

    self.frame.remove()
    self.box.remove()
    self.lock.release()

async def popup(content):
  async with Popup(doc) as p:
    p <= content
    center(p)
    with UIEvent(doc['popupbg'], 'click') as pbg:
      while not pbg:
        await aio.sleep(0)

    
class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate
    
  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()
    
  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate
    
  def __enter__(self):
    return self.stagger
    
  def __exit__(self, *_):
    pass

      
def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)

def tint(r, g, b, a, val):
  '''Tints rgb values to apply 'white' layer to materials'''

  rt = r + (val * (255 - r))
  gt = g + (val * (255 - g))
  bt = b + (val * (255 - b))
  return (rt, gt, bt, a)
  
class Space(DIV):
  def __init__(self, *l, **kw):
    super().__init__(*l, style={'position': 'absolute', 'margin': '0px', 'padding': '0px',
      'display': 'flex',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'transition': 'all 0.3s',
      'box-sizing': 'border-box',}, **kw)

class Flex(DIV):
  opacities = {0:  0, 1: .05, 2: .07, 3: .08, 4: .09, 6: .11, 8: .12, 12: .14, 16: .15, 24: .16}
  shadows = {0: 'none', 
              1: '0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)',
              2: '0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)',
              3: '0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)',
              4: '0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)',
              6: '0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)',
              8: '0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)',
              12: '0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)',
              16: '0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)',
              24: '0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)',}

  def __init__(self, *l, color=(18, 18, 18, 1), padding='12px 18px', elevation=0, flow='row wrap', justify='flex-start', align_items='stretch', align_content='stretch', grow=1, flat=False, style={}, marked=False, **kw):
    base_style = {
      #'position': 'absolute',
      'border': 'none',
      #'margin': '8px',
      #'border-radius': '5px',
      'font-size': '16px',
      'cursor': 'default',
      'color': 'white',
      'outline': 'none',
      #'background': f'rgba{color}',
      'display': 'flex' if not marked else 'block',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'transition': 'all 0.3s',
      'box-sizing': 'border-box',
      'overflow': 'auto',
    }
    base_style.update(style)

    super().__init__(*l, style=base_style, **kw)

    self.__color = color
    self.__elevation = elevation
    self.flat = flat
    self.color = color
    self.padding = padding
    self.elevation = elevation
    self.flow = flow
    self.justify = justify
    self.align_items = align_items
    self.align_content = align_content
    self.grow = grow


  @property
  def color(self):
    return self.__color
  @color.setter
  def color(self, value):
    self.__color = value
    if not self.flat:
      self.style['background'] = f'rgba{tint(*value, self.opacities[self.elevation])}'
    else:
      self.style['background'] = f'rgba(255, 255, 255, {self.opacities[self.elevation]})'

  @property
  def padding(self):
    return self.__padding
  @padding.setter
  def padding(self, value):
    self.__padding = value
    self.style['padding'] = value

  @property
  def elevation(self):
    return self.__elevation
  @elevation.setter
  def elevation(self, value):
    self.__elevation = value
    if not self.flat:
      self.style['background'] = f'rgba{tint(*self.color, self.opacities[value])}'
      #self.style['box-shadow'] = self.shadows[value]
    else:
      self.style['background'] = f'rgba(255, 255, 255, {self.opacities[value]})'

  @property
  def flow(self):
    '''
      row (default): left to right in ltr; right to left in rtl
      row-reverse: right to left in ltr; left to right in rtl
      column: same as row but top to bottom
      column-reverse: same as row-reverse but bottom to top
      nowrap (default): all flex items will be on one line
      wrap: flex items will wrap onto multiple lines, from top to bottom.
      wrap-reverse: flex items will wrap onto multiple lines from bottom to top.
    '''
    return self.__flow
  @flow.setter
  def flow(self, value):
    self.__flow = value
    self.style['flex-flow'] = value

  @property
  def justify(self):
    '''
      flex-start (default): items are packed toward the start of the flex-direction.
      flex-end: items are packed toward the end of the flex-direction.
      start: items are packed toward the start of the writing-mode direction.
      end: items are packed toward the end of the writing-mode direction.
      left: items are packed toward left edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
      right: items are packed toward right edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
      center: items are centered along the line
      space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line
      space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren't equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.
      space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal.
    '''
    return self.__justify
  @justify.setter
  def justify(self, value):
    self.__justify = value
    self.style['justify-content'] = value

  @property
  def align_items(self):
    '''
      stretch (default): stretch to fill the container (still respect min-width/max-width)
      flex-start / start / self-start: items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the flex-direction rules or the writing-mode rules.
      flex-end / end / self-end: items are placed at the end of the cross axis. The difference again is subtle and is about respecting flex-direction rules vs. writing-mode rules.
      center: items are centered in the cross-axis
      baseline: items are aligned such as their baselines align
    '''
    return self.__align_items
  @align_items.setter
  def align_items(self, value):
    self.__align_items = value
    self.style['align-items'] = value

  @property
  def align_content(self):
    '''
      flex-start / start: items packed to the start of the container. The (more supported) flex-start honors the flex-direction while start honors the writing-mode direction.
      flex-end / end: items packed to the end of the container. The (more support) flex-end honors the flex-direction while end honors the writing-mode direction.
      center: items centered in the container
      space-between: items evenly distributed; the first line is at the start of the container while the last one is at the end
      space-around: items evenly distributed with equal space around each line
      space-evenly: items are evenly distributed with equal space around them
      stretch (default): lines stretch to take up the remaining space
    '''
    return self.__align_content
  @align_content.setter
  def align_content(self, value):
    self.__align_content = value
    self.style['align-content'] = value

  @property
  def grow(self):
    return self.__grow
  @grow.setter
  def grow(self, value):
    self.__grow = value
    self.style['flex-grow'] = value

  def __repr__(self):
    return "{" + f"'flat': {repr(self.flat)}, 'color': {repr(self.color)}, 'padding': {repr(self.padding)}, 'elevation': {repr(self.elevation)}, 'flow': {repr(self.flow)}, 'justify': {repr(self.justify)}, 'align_items': {repr(self.align_items)}, 'align_content': {repr(self.align_content)}" + "}"

class Textbox(TEXTAREA, Flex):
  def __init__(self, *l, placeholder='', name='', **kw):
    Flex.__init__(self, *l, **kw)
    
    self.setAttribute('placeholder', placeholder)
    self.setAttribute('name', name)

    self.style['border-bottom'] = f'solid 2px rgba{tint(*(0, 0, 128, 1), self.opacities[6])}'

    self.base_elevation = kw.get('elevation', 0)

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))

    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))

class Input(INPUT, Flex):
  def __init__(self, text='', placeholder='', _list='', name='', _type='', force_list=False, *l, **kw):
    Flex.__init__(self, *l, **kw)
    
    self.setAttribute('value', text)
    self.setAttribute('placeholder', placeholder)
    self.setAttribute('name', name)
    self.setAttribute('type', _type)
    self.setAttribute('list', _list)
    self._list = _list
    self.placeholder = placeholder

    if not kw.get('flat', False):
      self.style['border-bottom'] = f'solid 2px rgba{tint(*(32, 32, 128, 1), self.opacities[6])}'

    self.base_elevation = kw.get('elevation', 0)

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))

    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 2))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))

    if force_list:
      def erase(ev):
        if self.value:
          self.placeholder = self.value
        self.value = ''
      def force(ev):
        dataset = doc.querySelector(f'#{self._list}').possibilities
        if not self.value:
          if self.placeholder in dataset:
            self.value = self.placeholder
          else:
            self.value = dataset[0]
        else:
          for opt in dataset:
            if self.value.lower() in opt.lower():
              self.value = opt
              break
          else:
            self.value = dataset[0]
      self.bind('focus', erase)
      self.bind('click', erase)
      self.bind('blur', force)
      force(None)

  @property
  def placeholder(self):
    return self.__placeholder
  @placeholder.setter
  def placeholder(self, value):
    self.__placeholder = value
    self.setAttribute('placeholder', value)

class InputOptions(DATALIST):
  def __init__(self, possibilities, *l, **kw):
    self.possibilities = possibilities
    super().__init__(*l, **kw)
    self.update()

  def update(self):
    self.clear()
    for opt in self.possibilities:
      self <= OPTION(value=opt)

  def __repr__(self):
    return "{" + f"'possibilities': {repr(self.possibilities)}" + "}"

class Edge(Flex):
  def __init__(self, *l, **kw):
    super().__init__(*l, **kw, padding='0px')
    self.style['border-radius'] = '0px'
    self.style['margin'] = '0px'

class Menu(Flex):
  def __init__(self, *l, **kw):
    super().__init__(*l, **kw, elevation=8, flow='column wrap')
    self.style['width'] = '300px'

class Card(Flex):
  pass

class Label(Card):
  def __init__(self, *l, flow='column', justify='center', flat=True, **kw):
    super().__init__(*l, flow=flow, justify=justify, flat=flat, **kw)

class Button(Flex):
  def __init__(self, *l, elevation=0, flat=False, raised=False, flow='column', justify='center', align_items='center', **kw):
    if raised:
      elevation = 2
    else:
      flat = True

    super().__init__(*l,
         elevation=elevation,
         flat=flat,
         tabindex=0,
         justify=justify,
         flow=flow,
         align_items=align_items,
         **kw)

    self.base_elevation = elevation

    self.bind('mouseenter', lambda ev: setattr(self, 'elevation', self.base_elevation + 6))
    self.bind('mouseleave', lambda ev: setattr(self, 'elevation', self.base_elevation))
    self.bind('focus', lambda ev: setattr(self, 'elevation', self.base_elevation + 6))
    self.bind('blur', lambda ev: setattr(self, 'elevation', self.base_elevation))
    self.bind('keyup', self.on_enter)
    
  def on_enter(self, ev):
    if ev.keyCode in (13, 32):
      ev.preventDefault()
      self.click()
      

class Fab(Button):
  def __init__(self, icon, *l, **kw):
    super().__init__(Icon(icon), elevation=6, raised=True, *l, **kw)
    self.style['padding'] = '18px'
    self.style['border-radius'] = '50%'
    self.icon = icon

  @property
  def icon(self):
    return self.__icon
  @icon.setter
  def icon(self, value):
    self.__icon = value
    self.children[0].icon = value

  def __repr__(self):
    return "{" + f"'icon': {repr(self.icon)}" + "}"

class Snack(Label):
  lock = aio.Lock()

  def __init__(self, *l, delay=5, **kw):
    self.delay = delay
    super().__init__(*l, **kw, elevation=6, flat=False)
    self.style['width'] = '100%'
    self.style['border-radius'] = '0px'
    self.style['position'] = 'fixed'
    self.style['margin'] = '0px'
    self.style['bottom'] = '-48px'
    self.style['height'] = '48px'
    doc <= self
    aio.run(self.show())

  async def show(self):
    await self.lock.acquire()
    await aio.sleep(.05)
    self.style['bottom'] = 0
    await aio.sleep(.3 + self.delay)
    await self.hide()

  async def hide(self):
    self.style['bottom'] = '-48px'
    await aio.sleep(.3)
    self.remove()
    self.lock.release()

  def __repr__(self):
    return "{" + f"'delay': {repr(self.delay)}" + "}"

class Icon(I):
  def __init__(self, icon, *l, **kw):
    super().__init__(Class='material-icons', *l, **kw)
    self.icon = icon

  @property
  def icon(self):
    return self.__icon
  @icon.setter
  def icon(self, value):
    self.__icon = value
    self.innerHTML = value

  def __repr__(self):
    return "{" + f"'icon': {repr(self.icon)}" + "}"
    
def gmap(grid, obj, x, y, endx=None, endy=None):
  if endx is None:
    endx = x
  if endy is None:
    endy = y
  obj.top = grid.cells[x][y].topleft.y
  obj.left = grid.cells[x][y].topleft.x

  obj.width = grid.cells[endx][endy].bottomright.x - obj.left
  obj.height = grid.cells[endx][endy].bottomright.y - obj.top

class Point:

  __slots__ = 'x', 'y'

  def __init__(self, x=0, y=0):
    self.x = round(x)
    self.y = round(y)

  def __iter__(self):
    yield from (self.x, self.y)
    
  def __repr__(self):
    return "{" + f"'x': {repr(self.x)}, 'y': {repr(self.y)}" + "}"
    

class Cell:

  __slots__ = '_Cell__topleft', '_Cell__bottomright', 'width', 'height', 'center', 'bottomleft', 'topright'

  def __init__(self, topleft={'x': 0, 'y': 0}, bottomright={'x': 0, 'y': 0}):
    self.__topleft = Point()
    self.__bottomright = Point()
    self.topleft = topleft
    self.bottomright = bottomright

  @property
  def topleft(self):
    return self.__topleft
  @topleft.setter
  def topleft(self, value):
    self.__topleft = value if type(value) is Point else Point(**value)
    self.width = self.bottomright.x - self.topleft.x
    self.height = self.bottomright.y - self.topleft.y
    self.center = Point(self.topleft.x + round(self.width/2.0), self.topleft.y + round(self.height/2.0))
    self.bottomleft = Point(self.topleft.x, self.bottomright.y)
    self.topright = Point(self.bottomright.x, self.topleft.y)

  @property
  def bottomright(self):
    return self.__bottomright
  @bottomright.setter
  def bottomright(self, value):
    self.__bottomright = value if type(value) is Point else Point(**value)
    self.width = self.bottomright.x - self.topleft.x
    self.height = self.bottomright.y - self.topleft.y
    self.center = Point(self.topleft.x + round(self.width/2.0), self.topleft.y + round(self.height/2.0))
    self.bottomleft = Point(self.topleft.x, self.bottomright.y)
    self.topright = Point(self.bottomright.x, self.topleft.y)

  def __repr__(self):
    return "{" + f"'bottomright': {repr(self.bottomright)}, 'bottomleft': {repr(self.bottomleft)}, 'topright': {repr(self.topright)}, 'topleft': {repr(self.topleft)}, 'width': {repr(self.width)}, 'height': {repr(self.height)}, 'center': {repr(self.center)}" + "}"
    
#def gmap(grid, col, row, obj, width=0, height=0):
#  if col < 0:
#    col += len(grid.cols)
#  if row < 0:
#    row += len(grid.rows)
#  obj.top = grid.cells[row][col].topleft.y
#  obj.left = grid.cells[row][col].topleft.x
#
#  obj.width = grid.cells[row+height][col+width].bottomright.x - obj.left
#  obj.height = grid.cells[row+height][col+width].bottomright.y - obj.top
    
class Gridman:

  __slots__ = 'cols', 'rows', 'width', 'height', 'left', 'top', '_cbs', 'cells'

  def __init__(self, cols=[], rows=[], width=0, height=0, left=0, top=0):
    self.cols = cols
    self.rows = rows
    self.width = width
    self.height = height
    self.left = left
    self.top = top
    self._cbs = {}
    
    self.cells = []
    self.update()
    
  def update(self):
    self.cells.clear()
    self.cells.extend(list() for i in range(len(self.cols)))
    for col in self.cells:
      col.extend(Cell() for i in range(len(self.rows)))
      
    widths = []
    for col in self.cols:
      if col != ...:
        if col < 1:
          widths.append(col*self.width)
        else:
          widths.append(col)
      else:
        widths.append(...)
    
    remainder = max(0, self.width - sum(i for i in widths if i!=...))
    buffs = 0
    if ... in widths:
      widths[widths.index(...)] = remainder
    else:
      buffs = remainder/2
      
    last = buffs + self.left
    lefts = [buffs + self.left]
    for width in widths:
      lefts.append(width + last)
      last += width
      
    heights = []
    for row in self.rows:
      if row != ...:
        if row < 1:
          heights.append(row*self.height)
        else:
          heights.append(row)
      else:
        heights.append(...)
    
    remainder = max(0, self.height - sum(i for i in heights if i!=...))
    buffs = 0
    if ... in heights:
      heights[heights.index(...)] = remainder
    else:
      buffs = remainder/2
      
    last = buffs + self.top
    tops = [buffs + self.top]
    for height in heights:
      tops.append(height + last)
      last += height
      
    for ci, col in enumerate(lefts[:-1]):
      for ri, row in enumerate(tops[:-1]):
        self.cells[ci][ri].topleft = Point(col, row)
        self.cells[ci][ri].bottomright = Point(lefts[ci+1], tops[ri+1])
    self.dispatch('update')
        
  def bind(self, **kwargs):
    for k, v in kwargs.items():
      if k not in self._cbs:
        self._cbs[k] = []
      self._cbs[k].append(v)

  def unbind(self, **kwargs):
    for k, v in kwargs.items():
      self._cbs[k].remove(v)
      if not self._cbs[k]:
        del self._cbs[k]

  def dispatch(self, prop, *l, **kw):
    if getattr(self, f'on_{prop}', None):
      getattr(self, f'on_{prop}')(prop, *l, **kw)
    if prop in self._cbs:
      for cb in self._cbs[prop]:
        cb(self, prop, *l, **kw)

  def __repr__(self):
    return "{" + f"'cols': {repr(self.cols)}, 'rows': {repr(self.rows)}, 'width': {repr(self.width)}, 'height': {repr(self.height)}, 'left': {repr(self.left)}, 'top': {repr(self.top)}" + "}"

class Event:

  __slots__ = 'tar', 'events', 'out'

  def __init__(self, tar, *events):
    self.tar = tar
    self.events = {e: lambda _self, *l, **kw: self.out.append((_self, l, kw)) for e in events}
    self.out = []

  def __enter__(self):
    for k, v in self.events.items():
      self.tar.bind(**{k: v})
    return self.out

  def __exit__(self, *l):
    for k, v in self.events.items():
      self.tar.unbind(**{k: v})
    
class UIEvent:

  __slots__ = 'tar', 'events', 'out'

  def __init__(self, tar, *events):
    self.tar = tar
    self.events = {e: lambda ev: self.out.append(ev) for e in events}
    self.out = []

  def __enter__(self):
    for k, v in self.events.items():
      self.tar.bind(k, v)
    return self.out

  def __exit__(self, *l):
    for k, v in self.events.items():
      self.tar.unbind(k, v)
      
async def _any(_iterable):
  'Await for any(_iterable) to be true'

  while not any(_iterable):
    await aio.sleep(0)

class Any:
  'With version of _any. Auto flushes the lists on exit'

  __slots__ = '_iterable'

  def __init__(self, _iterable):
    self._iterable = _iterable

  async def __aenter__(self):
    await _any(self._iterable)

  async def __aexit__(self, *l):
    for i in self._iterable:
      i.clear()

#async def main():
#  res = await aio.gather(snackbar())
#
#aio.run(main())


</script>
<script>
      var _logger = function(msg){
	if(msg != "using indexedDB for stdlib modules cache" && msg != 'empty stack'){
          cm_editbox.openNotification('<pre>'+msg+'</pre>')
	}
      //cm_editbox.openNotification('<p>'+msg.split('\n').join('<br>')+'</p>')
      }
      
      console.log=_logger
      console.error=make_popup
      console.warning=make_popup
      </script>
</html>
