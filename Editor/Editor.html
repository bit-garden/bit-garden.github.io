<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}

@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

@font-face {
  font-family: Thin;
  src: url("lib/Roboto-Thin.ttf") format("truetype");
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons' !important;
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}


.CodeMirror, .CodeMirror-gutters{background:#000000 !important;}


 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #ffffff;}

 .cm-deco{color: #ffbf00;}
 .cm-decorator{color: #ffaaff;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}

 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:18px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: rgba(0,0,0, 1);
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888;
  font-family: Mono;
  }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }
  


/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  /*border-radius: 3px;*/
  padding: 8px 8px;
  /*margin:6px;*/
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: rgba(0,0,0, 1);
  /*box-shadow: 0 4px 8px #000;*/
  outline: none;
  font-family: Mono !important;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}

.shadow_0 {
  box-shadow: none
}
.shadow_1{
  box-shadow: 0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)
}
.shadow_2{
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)
}
.shadow_3{
  box-shadow: 0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)
}
.shadow_4{
  box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)
}
.shadow_6{
  box-shadow: 0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)
}
.shadow_8{
  box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)
}
.shadow_12{
  box-shadow: 0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)
}
.shadow_16{
  box-shadow: 0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)
}
.shadow_24{
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)
}

dialog {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 0px;
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20);
  box-sizing: border-box;
  font-family: Roboto !important;
}
.card {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 12px 16px;
  box-sizing: border-box;
}

button, textarea, input{
  background: none;
  color: rgba(255,255,255,.87);
  border: none;
  outline: none;
  box-sizing: border-box;
}

.glow_white, .tile_white:hover, .tile_white:focus{
  box-shadow: 0 4px 5px 0 rgba(255, 255, 255, 0.14), 0 1px 10px 0 rgba(255, 255, 255, 0.12), 0 2px 4px -1px rgba(255, 255, 255, 0.20);
  background: rgb(255, 255, 255) !important;
}

.glow_crimson, .tile_crimson:hover, .tile_crimson:focus{
  box-shadow: 0 4px 5px 0 rgba(220, 20, 60, 0.14), 0 1px 10px 0 rgba(220, 20, 60, 0.12), 0 2px 4px -1px rgba(220, 20, 60, 0.20);
  background: rgb(220, 20, 60) !important;
}

.glow_emerald, .tile_emerald:hover, .tile_emerald:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 89, 11, 0.14), 0 1px 10px 0 rgba(0, 89, 11, 0.12), 0 2px 4px -1px rgba(0, 89, 11, 0.20);
  background: rgb(0, 89, 11) !important;
}

.glow_cobalt, .tile_cobalt:hover, .tile_cobalt:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 71, 171, 0.14), 0 1px 10px 0 rgba(0, 71, 171, 0.12), 0 2px 4px -1px rgba(0, 71, 171, 0.20);
  background: rgb(0, 71, 171) !important;
}

.glow_gold, .tile_gold:hover, .tile_gold:focus{
  box-shadow: 0 4px 5px 0 rgba(255, 215, 0, 0.14), 0 1px 10px 0 rgba(255, 215, 0, 0.12), 0 2px 4px -1px rgba(255, 215, 0, 0.20);
  background: rgb(255, 215, 0) !important;
}

.show_over {
  opacity: 0;
}
div:hover > .hide_over,
div:focus > .hide_over {
  opacity: 0;
}
div:hover > .show_over,
div:focus > .show_over {
  opacity: 1;
}

.animate { 
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
  transition: all 0.3s;
}

.warn{
  border-bottom: 1px solid #B00020;
}

::placeholder {
  color: rgba(255,255,255,.6);
}

.separator {
    display: flex;
    align-items: center;
    text-align: center;
    color: rgba(255,255,255,.50);
}
.separator::before, .separator::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid rgba(255,255,255,.50);
}
.separator::before {
    margin-right: .25em;
}
.separator::after {
    margin-left: .25em;
}


.wiggle {
  animation-name: wiggle;
  animation-duration: 6s;
  animation-iteration-count: infinite;
}

@keyframes wiggle {
  0% {
    transform: rotate(0deg);
  }
  2% {
    transform: rotate(-10deg);
  }
  4% {
    transform: rotate(8deg);
  }
  6% {
    transform: rotate(-5deg);
  }
  8% {
    transform: rotate(-2deg);
  }
  10% {
    transform: rotate(0deg);
  }
}

</style>
<script>
CodeMirror.defineSimpleMode("simplemode", {
  start: [
    {regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote

    {regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:;\}.$ ?])/, token: "variables"}, // single quote strings code
    {regex: /(^| )'([^']|'\w)*'( |$)/, token: "variables"}, // single quote strings speech
    
    
    //{regex: /(\/\/\/|##).*$/, token: "strings"}, // darklights comments
    //{regex: /(#|\/\/)[^\/#]?.*$/, token: "comments"}, // darklights comments
    {regex: /(#|\/\/).*$/, token: "comments"}, // darklights comments
    //{regex: /\d\d\/\d\d \d\d:\d\d/, token: 'strings'}, // timestamps
    //{regex: / \|( |$)/, token: 'nums'},
  ]
});
</script>

<body onload="brython({indexedDB: false})">
  <textarea class='editbox'></textarea>
</body>
<script>

// jk to escape, kj to auto complete, vw to select and copy current word
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('<C-p>', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map('<C-n>', ':js cm_editbox.showHint()', 'insert')

// put 2 spaces instead of tab char
CodeMirror.Vim.map('<Tab>', ':insertSoftTab', 'insert')

// remove search higlights
CodeMirror.Vim.map('<Tab><Space>', ':noh', 'normal')

CodeMirror.Vim.map('<F5>', ':timestamp', 'insert')
CodeMirror.Vim.map('<F5>', ':timestamp', 'normal')

// Tab e to align table or selection
CodeMirror.Vim.map('<Tab>e', ':vdo :kpos|vip|:align|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>e', ':vdo :align', 'visual')

/*
// ctrl + e to run file or selection
CodeMirror.Vim.map('<C-e>', ':run_file', 'normal')
CodeMirror.Vim.map('<C-e>', ':run_file', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')

CodeMirror.Vim.map('<Tab><C-e>', ':run_shard', 'normal')
CodeMirror.Vim.map('<Tab>v', ':visual_shard', 'normal')




// Transpose table for easy column-wise edits
CodeMirror.Vim.map('<Tab>t', ':vdo :kpos|vip|:do_tp|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>t', ':vdo :do_tp', 'visual')

// natural sorting
CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')

// sort by selection
CodeMirror.Vim.map('<Tab>y', ':js sort_by()', 'visual')

// Save command, TODO
//CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'normal')
//CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'insert')

// Align text selections
CodeMirror.Vim.map('<Tab>r', ':js alignRight()', 'visual')
CodeMirror.Vim.map('<Tab>l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map('<Tab>c', ':js alignCenter()', 'visual')

CodeMirror.Vim.map('{}', ':bracespace {}', 'insert')
CodeMirror.Vim.map('[]', ':bracespace []', 'insert')

CodeMirror.Vim.unmap('S', 'visual')
CodeMirror.Vim.map('S(', ':surround ()', 'visual')
CodeMirror.Vim.map('S)', ':surround ()', 'visual')
CodeMirror.Vim.map('S[', ':surround []', 'visual')
CodeMirror.Vim.map('S]', ':surround []', 'visual')
CodeMirror.Vim.map('S{', ':surround {}', 'visual')
CodeMirror.Vim.map('S}', ':surround {}', 'visual')

CodeMirror.Vim.map("S'", ":surround ''", 'visual')
CodeMirror.Vim.map('S"', ':surround ""', 'visual')

CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')

// quick select column in pipe table
CodeMirror.Vim.map('zv', ':vblock', 'normal')

CodeMirror.Vim.map('(', ':double_tap ()', 'insert')
CodeMirror.Vim.map(')', ':double_tap )', 'insert')
CodeMirror.Vim.map('{', ':double_tap {}', 'insert')
CodeMirror.Vim.map('}', ':double_tap }', 'insert')
CodeMirror.Vim.map('[', ':double_tap []', 'insert')
CodeMirror.Vim.map(']', ':double_tap ]', 'insert')
CodeMirror.Vim.map('"', ':double_tap "', 'insert')
//CodeMirror.Vim.map("'", ":double_tap '", 'insert')
//
CodeMirror.Vim.map("<BS>", ":undouble_tap", 'insert')

CodeMirror.Vim.map('<F5>', ':timestamp', 'insert')
CodeMirror.Vim.map('<F5>', ':timestamp', 'normal')*/


editbox = document.querySelector('.editbox')
if ('data' in localStorage){
  editbox.value = localStorage.getItem('data')
}else{
  editbox.value = 'No local storage found'
}
cm_editbox = CodeMirror.fromTextArea(editbox,{
            'matchBrackets':     true,
            'autoCloseBrackets': false,
            'lineNumbers':       false,
            "mode":              'simplemode',
            "theme":             "material",
            'tabSize':           2,
            'styleActiveLine':   true,
            'keyMap':            'vim',
            'extraKeys':         {"Ctrl-Space": "autocomplete"}
 })
 function tab_to_space(cm){
  cm_editbox.execCommand("insertSoftTab")
}
cm_editbox.addKeyMap({'Ctrl-C': false})
CodeMirror.Vim.defineEx("insertSoftTab", null, tab_to_space)
//cm_editbox.addKeyMap({'Tab': tab_to_space})

var just_completed = false

function on_change(cm, _change){
  cm_editbox.save()
  c = cm_editbox.getCursor()
  c = {line: c.line, ch: c.ch}
  if(c.ch)
    c.ch -= 1
  word = cm_editbox.findWordAt(c); word = cm_editbox.getRange(word.anchor, word.head).trim();
  if(cm_editbox.state.vim.insertMode && word.match(/\w\w$/) && !just_completed) {
    cm_editbox.showHint()
  }
  else{
    cm_editbox.closeHint()
    just_completed = false
    }
  localStorage.setItem('data', editbox.value.replace(/ +$/mgi, ""));
}

cm_editbox.on('change',on_change)

function ac_hint(cm){
  cm.showHint({'hint': CodeMirror.hint.anyword})
}
CodeMirror.commands.autocomplete = ac_hint


//------------------------------------
function runjs(cm, params){
  eval(params.argString)
}
CodeMirror.Vim.defineEx("js", null, runjs)

function run_align(cm, params){
  vdo('gv')
  data = cm_editbox.getSelection()
  out = align(table(comma2pipe(data.replaceAll('\t', '|'))))
  vdo('gv')
  cm_editbox.replaceSelection(out.trim())
}
CodeMirror.Vim.defineEx("align", null, run_align)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}

function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}

function toclip(dat){
  navigator.clipboard.writeText(dat.toString())
    .then(() => {
      console.log(dat.toString() + ' to clip.');
    })
    .catch(err => {
      // This can happen if the user denies clipboard permissions:
      console.error('Could not copy text: ', err);
    });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replace(/\<bar\>/g, '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)
CodeMirror.Vim.defineEx("normal", null, runvdo)

function kpos(cm, params){
  window.lastscroll = cm_editbox.getScrollInfo()
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
  cm_editbox.scrollTo(window.lastscroll.left, window.lastscroll.top)
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function timestamp(cm, params){
  d = new Date()
  s = `${d.getMonth()}/${d.getDay()} ${d.getHours()}:${d.getMinutes()}`
  insertTextAtCursor(cm_editbox, s)
}
CodeMirror.Vim.defineEx('timestamp', null, timestamp)

/*function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0

  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}



function vblock(cm, params){
  cm_editbox.save()
  char_at = cm_editbox.getCursor().ch + 1
  vdo("?^\\s*(\/\/<bar>#<bar>$)|j")
  line1 = cm.getCursor().line + 1
  vdo("/^\\s*(\/\/<bar>#<bar>$)|k")
  line2 = cm.getCursor().line + 1
  vdo(line2 + "gg" + char_at + "<bar>t<bar>v" + line1 + "gg" + char_at + "<bar>T<bar>")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}



function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}


//testing char skipping, not space skipping exclusively.
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^ ]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}








// py to js ports
const zip = (arr1, arr2) => arr1.map((k, i) => [k, arr2[i]]);

function matrix(s, delim='|'){
  return s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));
}

function matrix2(s, delim='|'){
  var out = s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));

  var width = out[0].length;

  return out.map((i) => [...i, ...(Array.apply(null, Array(width-i.length)).map(function() { return '' }))]);
}

*/



/*def align(t):
  widths = {k: len(k) for k in t[0].keys()}
  keys = sorted([i for i in widths.keys() if i])

  for i in t:
    for k, v in i.items():
      cur = len(v)
      if cur > widths[k]: widths[k] = cur

  return ' | '.join(idx.ljust(widths[idx]) for idx in keys).rstrip() + '\n' + \
    '\n'.join(' | '.join(row[idx].ljust(widths[idx])
    for idx in keys).rstrip()
      for row in t)*/

/*function align(l){
  head = Object.keys(l[0]);
  widths = {};
  for(const i of head)
    widths[i] = i.length;
    
  rights = {};
  for (const i of head)
    rights[i] = i.endsWith(':');
  
  keys = head.filter((i)=> i.length);
  
  for(const i of l){
    for (const k of keys){
      cur = i[k].length;
      if (cur > widths[k])
        widths[k] = cur;
    }
  }

  return keys.map((idx) => rights[idx]? idx.padStart(widths[idx]): idx.padEnd(widths[idx])).join(' | ').trimEnd()+'\n' + l.map(
    (row) => keys.map((idx) => rights[idx]? row[idx].padStart(widths[idx]): row[idx].padEnd(widths[idx])).join(' | ').trimEnd()).join('\n');
}*/

function uuid4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

function insertTextAtCursor(editor, text) {
    var doc = editor.getDoc();
    var cursor = doc.getCursor();
    doc.replaceRange(text, cursor);
}

function table(s, delim='|'){
  var out = s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));
  var width = out[0].length;
  var l = out.map((i) => {
    i = i.splice(0, width)
    return [...i, ...(Array.apply(null, Array(width-i.length)).map(function() { return '' }))]
  });
  var keys = l.shift();

  l = l.map((values) => keys.reduce((acc, k, i) => (acc[k.toString()] = values[i], acc), new Map()));

  return l;
}

function align(l){
  head = Object.keys(l[0]);
  widths = {};
  for(const i of head)
    widths[i] = i.length;

  keys = head.filter((i)=> i.length);
  
  for(const i of l){
    for (const k of keys){
      cur = i[k].length;
      if (cur > widths[k])
        widths[k] = cur;
    }
  }

  return keys.map((idx) => idx.padEnd(widths[idx])).join(' | ').trimEnd()+'\n' + l.map(
    (row) => keys.map((idx) => row[idx].padEnd(widths[idx])).join(' | ').trimEnd()).join('\n');
}


function alignCsv(l){
  wide = l[0].length;
  
  widths = [];
  for(i=0; i < wide; i++){
    widths.push(0);
  }
  
  for (const row of l){
    for (j=0; j < wide; j++){
      cur = row[j].length;
      if (cur > widths[j])
        widths[j] = cur
    }
  }
  
  return l.map((row) => widths.map((w, idx) => row[idx].padEnd(w)).join(', ')).join('\n');
}

function comma2pipe(s){
  return s.split(/(,)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).join('|');
}

function splitCsv(s){
  return s.trim().split('\n').map((j) => j.split(/(,)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim()));
}

function splitPipe(s){
  return s.trim().split('\n').map((j) => j.split(/(\|)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim()));
}

function csv2tab(s){
  return s.trim().split('\n').map((j) => j.split(/(,)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim())).map((i) => i.join('\t')).join('\n');
}

</script>
</html>
