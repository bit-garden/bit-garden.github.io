<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}

@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

@font-face {
  font-family: Thin;
  src: url("lib/Roboto-Thin.ttf") format("truetype");
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons' !important;
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}


.CodeMirror, .CodeMirror-gutters{background:#000000 !important;}


 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}
 .cm-decorator{color: #ffaaff;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}

 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:18px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: rgba(0,0,0, 1);
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888;
  font-family: Mono;
  }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }


/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  /*border-radius: 3px;*/
  padding: 8px 8px;
  /*margin:6px;*/
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: rgba(0,0,0, 1);
  /*box-shadow: 0 4px 8px #000;*/
  outline: none;
  font-family: Mono !important;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}

pre, code, pre > * {
        font-family: Mono;
}

.shadow_0 {
  box-shadow: none
}
.shadow_1{
  box-shadow: 0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)
}
.shadow_2{
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)
}
.shadow_3{
  box-shadow: 0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)
}
.shadow_4{
  box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)
}
.shadow_6{
  box-shadow: 0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)
}
.shadow_8{
  box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)
}
.shadow_12{
  box-shadow: 0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)
}
.shadow_16{
  box-shadow: 0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)
}
.shadow_24{
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)
}

dialog {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 0px;
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20);
  box-sizing: border-box;
  font-family: Roboto !important;
}
.card {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 12px 16px;
  box-sizing: border-box;
}

button, textarea, input{
  background: none;
  color: rgba(255,255,255,.87);
  border: none;
  border-bottom: 1px solid rgb(222, 222, 222);
  outline: none;
  box-sizing: border-box;
}

.glow_white, .tile_white:hover, .tile_white:focus{
  box-shadow: 0 4px 5px 0 rgba(255, 255, 255, 0.14), 0 1px 10px 0 rgba(255, 255, 255, 0.12), 0 2px 4px -1px rgba(255, 255, 255, 0.20);
  background: rgb(255, 255, 255) !important;
}

.glow_crimson, .tile_crimson:hover, .tile_crimson:focus{
  box-shadow: 0 4px 5px 0 rgba(220, 20, 60, 0.14), 0 1px 10px 0 rgba(220, 20, 60, 0.12), 0 2px 4px -1px rgba(220, 20, 60, 0.20);
  background: rgb(220, 20, 60) !important;
}

.glow_emerald, .tile_emerald:hover, .tile_emerald:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 89, 11, 0.14), 0 1px 10px 0 rgba(0, 89, 11, 0.12), 0 2px 4px -1px rgba(0, 89, 11, 0.20);
  background: rgb(0, 89, 11) !important;
}

.glow_cobalt, .tile_cobalt:hover, .tile_cobalt:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 71, 171, 0.14), 0 1px 10px 0 rgba(0, 71, 171, 0.12), 0 2px 4px -1px rgba(0, 71, 171, 0.20);
  background: rgb(0, 71, 171) !important;
}

.glow_gold, .tile_gold:hover, .tile_gold:focus{
  box-shadow: 0 4px 5px 0 rgba(255, 215, 0, 0.14), 0 1px 10px 0 rgba(255, 215, 0, 0.12), 0 2px 4px -1px rgba(255, 215, 0, 0.20);
  background: rgb(255, 215, 0) !important;
}

.show_over {
  opacity: 0;
}
div:hover > .hide_over,
div:focus > .hide_over {
  opacity: 0;
}
div:hover > .show_over,
div:focus > .show_over {
  opacity: 1;
}

.animate { 
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
  transition: all 0.3s;
}

.warn{
  border-bottom: 1px solid #B00020;
}

::placeholder {
  color: rgba(255,255,255,.6);
}

.separator {
    display: flex;
    align-items: center;
    text-align: center;
    color: rgba(255,255,255,.50);
}
.separator::before, .separator::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid rgba(255,255,255,.50);
}
.separator::before {
    margin-right: .25em;
}
.separator::after {
    margin-left: .25em;
}


.wiggle {
  animation-name: wiggle;
  animation-duration: 6s;
  animation-iteration-count: infinite;
}

@keyframes wiggle {
  0% {
    transform: rotate(0deg);
  }
  2% {
    transform: rotate(-10deg);
  }
  4% {
    transform: rotate(8deg);
  }
  6% {
    transform: rotate(-5deg);
  }
  8% {
    transform: rotate(-2deg);
  }
  10% {
    transform: rotate(0deg);
  }
}

</style>
<script>
CodeMirror.defineSimpleMode("simplemode", {
  start: [
    {regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	
    {regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
    {regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
    
    {regex: /#.*$/, token: "comments"}, // darklights comments
    {regex: / \|( |$)/, token: 'nums'},
    {regex: /q(\/|\|)/, token: 'comments'},
  ]
});
</script>

<body onload="brython({indexedDB: false})">
  <textarea class='editbox'></textarea>
</body>
<script>

// jk to escape, kj to auto complete, vw to select and copy current word
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('<C-p>', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map('<C-n>', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')

// ctrl + e to run file or selection
CodeMirror.Vim.map('<C-e>', ':run_file', 'normal')
CodeMirror.Vim.map('<C-e>', ':run_file', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')

CodeMirror.Vim.map('<Tab><C-e>', ':run_shard', 'normal')
CodeMirror.Vim.map('<Tab>v', ':visual_shard', 'normal')

// Tab e to align table or selection
CodeMirror.Vim.map('<Tab>e', ':vdo :kpos|vip|:align|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>e', ':vdo :align', 'visual')

// put 2 spaces instead of tab char
CodeMirror.Vim.map('<Tab>', ':insertSoftTab', 'insert')

// Transpose table for easy column-wise edits
CodeMirror.Vim.map('<Tab>t', ':vdo :kpos|vip|:do_tp|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>t', ':vdo :do_tp', 'visual')

// natural sorting
CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')

// sort by selection
CodeMirror.Vim.map('<Tab>y', ':js sort_by()', 'visual')

// remove search higlights
CodeMirror.Vim.map('<Tab><Space>', ':noh', 'normal')

// Save command, TODO
//CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'normal')
//CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'insert')

// Align text selections
CodeMirror.Vim.map('<Tab>r', ':js alignRight()', 'visual')
CodeMirror.Vim.map('<Tab>l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map('<Tab>c', ':js alignCenter()', 'visual')

CodeMirror.Vim.map('{}', ':bracespace {}', 'insert')
//CodeMirror.Vim.map('[]', ':bracespace []', 'insert')

CodeMirror.Vim.unmap('s', 'visual')
CodeMirror.Vim.map('s(', ':surround ()', 'visual')
CodeMirror.Vim.map('s)', ':surround ()', 'visual')
CodeMirror.Vim.map('s[', ':surround []', 'visual')
CodeMirror.Vim.map('s]', ':surround []', 'visual')
CodeMirror.Vim.map('s{', ':surround {}', 'visual')
CodeMirror.Vim.map('s}', ':surround {}', 'visual')

CodeMirror.Vim.map("s'", ":surround ''", 'visual')
CodeMirror.Vim.map('s"', ':surround ""', 'visual')

CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')

// quick select column in pipe table
CodeMirror.Vim.map('zv', ':vblock', 'normal')



editbox = document.querySelector('.editbox')
if ('data' in localStorage){
  editbox.value = localStorage.getItem('data')
}else{
  editbox.value = 'No local storage found'
}
cm_editbox = CodeMirror.fromTextArea(editbox,{
            'matchBrackets':     true,
            'autoCloseBrackets': false,
            'lineNumbers':       true,
            "mode":              'simplemode',
            "theme":             "material",
            'tabSize':           2,
            'styleActiveLine':   true,
            'keyMap':            'vim',
            'extraKeys':         {"Ctrl-Space": "autocomplete"}
 })
 function tab_to_space(cm){
  cm_editbox.execCommand("insertSoftTab")
}
cm_editbox.addKeyMap({'Ctrl-C': false})
CodeMirror.Vim.defineEx("insertSoftTab", null, tab_to_space)
//cm_editbox.addKeyMap({'Tab': tab_to_space})

var just_completed = false

function on_change(cm, _change){
  cm_editbox.save()
  c = cm_editbox.getCursor()
  c = {line: c.line, ch: c.ch}
  if(c.ch)
    c.ch -= 1
  word = cm_editbox.findWordAt(c); word = cm_editbox.getRange(word.anchor, word.head).trim();
  if(cm_editbox.state.vim.insertMode && word.match(/\w\w$/) && !just_completed)
    cm_editbox.showHint()
  else{
    cm_editbox.closeHint()
    just_completed = false
    }
  localStorage.setItem('data', editbox.value.replace(/ +$/mgi, ""));
}

cm_editbox.on('change',on_change)

function ac_hint(cm){
  cm.showHint({'hint': CodeMirror.hint.anyword})
}
CodeMirror.commands.autocomplete = ac_hint

function runjs(cm, params){
  eval(params.argString)
}

CodeMirror.Vim.defineEx("js", null, runjs)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}

function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}

function toclip(dat){
  navigator.clipboard.writeText(dat.toString())
    .then(() => {
      console.log(dat.toString() + ' to clip.');
    })
    .catch(err => {
      // This can happen if the user denies clipboard permissions:
      console.error('Could not copy text: ', err);
    });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0

  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replace(/\<bar\>/g, '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)
CodeMirror.Vim.defineEx("normal", null, runvdo)

function vblock(cm, params){
  cm_editbox.save()
  char_at = cm_editbox.getCursor().ch + 1
  vdo("?^\\s*(#<bar>$)|j")
  line1 = cm.getCursor().line + 1
  vdo("/^\\s*(#<bar>$)|k")
  line2 = cm.getCursor().line + 1
  vdo(line2 + "gg" + char_at + "<bar>t<bar>v" + line1 + "gg" + char_at + "<bar>T<bar>")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}



function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}


//testing char skipping, not space skipping exclusively.
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^ ]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}


function kpos(cm, params){
  window.lastscroll = cm_editbox.getScrollInfo()
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
  cm_editbox.scrollTo(window.lastscroll.left, window.lastscroll.top)
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function uuid4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

function insertTextAtCursor(editor, text) {
    var doc = editor.getDoc();
    var cursor = doc.getCursor();
    doc.replaceRange(text, cursor);
}



// py to js ports
const zip = (arr1, arr2) => arr1.map((k, i) => [k, arr2[i]]);

function matrix(s, delim='|'){
  return s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));
}

function matrix2(s, delim='|'){
  var out = s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));

  var width = out[0].length;

  return out.map((i) => [...i, ...(Array.apply(null, Array(width-i.length)).map(function() { return '' }))]);
}

function table(s, delim='|'){
  var out = s.trim().split('\n').map((i) => i.split(delim).map((j) => j.trim()));
  var width = out[0].length;
  var l = out.map((i) => {
    i = i.splice(0, width)
    return [...i, ...(Array.apply(null, Array(width-i.length)).map(function() { return '' }))]
  });
  var keys = l.shift();

  l = l.map((values) => keys.reduce((acc, k, i) => (acc[k] = values[i], acc), {}));

  return l;
}

/*def align(t):
  widths = {k: len(k) for k in t[0].keys()}
  keys = sorted([i for i in widths.keys() if i])

  for i in t:
    for k, v in i.items():
      cur = len(v)
      if cur > widths[k]: widths[k] = cur

  return ' | '.join(idx.ljust(widths[idx]) for idx in keys).rstrip() + '\n' + \
    '\n'.join(' | '.join(row[idx].ljust(widths[idx])
    for idx in keys).rstrip()
      for row in t)*/

function align(l){
  head = Object.keys(l[0]);
  widths = {};
  for(const i of head)
    widths[i] = i.length;
    
  rights = {};
  for (const i of head)
    rights[i] = i.endsWith(':');
  
  keys = head.filter((i)=> i.length);
  
  for(const i of l){
    for (const k of keys){
      cur = i[k].length;
      if (cur > widths[k])
        widths[k] = cur;
    }
  }

  return keys.map((idx) => rights[idx]? idx.padStart(widths[idx]): idx.padEnd(widths[idx])).join(' | ').trimEnd()+'\n' + l.map(
    (row) => keys.map((idx) => rights[idx]? row[idx].padStart(widths[idx]): row[idx].padEnd(widths[idx])).join(' | ').trimEnd()).join('\n');
}
/*function align(l){
  widths = l[0].map((i) => 0);
  width = l[0].length;

  for (const i of l){
    for (j = 0; j < width; j++){
      i[j] = `${i[j]}`;
      if (i[j].length > widths[j])
        widths[j] = i[j].length;
    }
  }
  
  var aligns = l[0].map((i) => i.endsWith(':'));
  
  for (const i of l){
    for (j = 0; j < width; j++) {
      i[j] = aligns[j] ? i[j].padStart(widths[j]) : i[j].padEnd(widths[j]);
    }
  }
  
  return l.map((i) => i.join(' | ')).join('\n');
}*/


function splitCsv(s){
  return s.trim().split('\n').map((j) => j.split(/(,)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim()));
}

function splitPipe(s){
  return s.trim().split('\n').map((j) => j.split(/(\|)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim()));
}

function csv2tab(s){
  return s.trim().split('\n').map((j) => j.split(/(,)(?=(?:[^"]|"[^"]*")*$)/).filter((i, idx) => idx%2==0).map((i) => i.trim())).map((i) => i.join('\t')).join('\n');
}

</script>
<!--<script src="lib/brython_aio.js"></script>-->
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import window
from browser import aio as asyncio
from browser import document as doc
from browser.html import *
import time

input = window.prompt

def groupBy(l, key):
  gb = {}
  for i in l: gb.setdefault(key(i), []).append(i)
  return gb

def chunkBy(l, key):
  last_key = k = None
  last_group = []

  for i in l:
    k = key(i)
    if k == last_key:
      last_group.append(i)
    else:
      if len(last_group) > 0: yield [last_key, last_group]
      last_key = k
      last_group = [i]

  if len(last_group) > 0: yield [last_key, last_group]

def chunk(l, n):
  for i in range(len(l)//n):
    yield l[n*i: n*(i+1)]
  if len(l) % n != 0:
    yield l[-n+1:]
  
# dart style implementations
def fold(l, v, f):
  for i in l: v = f(v, i)
  return v
  
def reduce(l, f):
  return fold(_:=iter(l), next(_), f)


def struct(name, args, verbose=False):
  sargs = '\n'.join(f'    self.{i} = {i}' for i in args)
  iters = ', '.join(f'self.{i}' for i in args)
  
  slot_template = f"""
class {name}:
  __slots__ = {repr(tuple(args))}
  def __init__(self, {', '.join(args)}):
{sargs}
    
  def __iter__(self):
    yield from ({iters})
""".strip()
  
  if verbose:
    return slot_template
  
  local = {}
  exec(slot_template, local)
  return local[name]
  
def structs(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection().strip().splitlines()
  
  out = [struct(i.split(' ')[0], i.split(' ')[1:], verbose=True) for i in data]
    
  window.vdo('gv')
  cm_editbox.replaceSelection('\n\n'.join(out))
window.CodeMirror.Vim.defineEx("struct", None, structs)


def dstruct(name, args):
  sargs = ', '.join(f'this.{i}' for i in args)
  cargs = '\n'.join(f'  var {i};' for i in args)
  strargs = ', '.join(f'{i}: ${i}' for i in args)
  
  slot_template = f"""
class {name} {{
{cargs}

  {name}({sargs});
  
  toString () => '{name}({strargs})';
}}
""".strip()
  
  return slot_template
  
def dstructs(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection().strip().splitlines()
  
  out = [dstruct(i.split(' ')[0], i.split(' ')[1:]) for i in data]
    
  window.vdo('gv')
  cm_editbox.replaceSelection('\n\n'.join(out))
window.CodeMirror.Vim.defineEx("dstruct", None, dstructs)

def tint(val, r, g, b, *_):
  # Tints rgb values to apply 'light'

  rt = r + (val * (255 - r))
  gt = g + (val * (255 - g))
  bt = b + (val * (255 - b))
  return (rt, gt, bt, *_)

def shade(val, r, g, b, *_):
  # Tints rgb values to apply 'dark' 

  rt = r - r*val 
  gt = g - g*val 
  bt = b - b*val 
  return (rt, gt, bt, *_)


def is_dark(r, g, b, *_):
  # determine color too dark
  # HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
  hsp =  0.299 * r**2 + 0.587 * g**2 + 0.114 * b**2
  return 127.5 >= hsp**(1/2.0)

def hilo(a, b, c):
  # used in compliment function

  if c < b: b, c = c, b
  if b < a: a, b = b, a
  if c < b: b, c = c, b
  return a + c

def complement(r, g, b, *_):
  # return complement color
  k = hilo(r, g, b)
  return tuple(*(k - u for u in (r, g, b)), *_)
 
def matrix(s, delim='|'):
  return [[j.strip() for j in i.split(delim)] for i in s.strip().splitlines()]
  
def matrix2(s, delim='|'):
  out = [[j.strip() for j in i.split(delim)] for i in s.strip().splitlines()]
  width = len(out[0])
  return [[*i, *(['']*(width-len(i)))] for i in out]
 
def table(s, delim='|'):
  out = [[j.strip() for j in i.split(delim)] for i in s.strip().splitlines()]
  width = len(out[0])
  out = [[*i, *(['']*(width-len(i)))] for i in out]
  return [dict(zip(out[0], i)) for i in out[1:]]
      
def align(l):
  wide = len(l[0])
  widths = [0 for i in range(wide)]
  rights = [i.endswith(':') for i in l[0]]

  for row in l:
    for col in range(wide):
      cur = len(row[col])
      if cur > widths[col]: widths[col] = cur
      
  return '\n'.join(' | '.join(
    row[col].rjust(widths[col]) if rights[col] else row[col].ljust(widths[col])
      for col in range(wide)).rstrip() for row in l)
      
class Listenable:
  def __init__(self): self._listeners = []
  
  def add(self, f): self._listeners.append(f)
  def remove(self, f): self._listeners.remove(f)
  def dispose(self): self._listeners.clear()
  
  @property
  def hasListeners(self): return self._listeners == []
  
  def notify(self):
    for l in self._listeners[:]: l()

async def aloop(update, step=1/30):
  t = time.time()
  now = t
  running = True

  while running:
    await asyncio.sleep(t - now)
    now = time.time()
    while t < now:
      t += step
      if update() is False:
        running = False
        break
    
def system(signature, f):
  def _system(es, delta = 0):
    for entity in es:
      if set(entity.keys()) >= signature:
        f(entity, delta)
  return _system

# --- end focus


ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = False
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = None
_options['relative_number'] = True

def runup(cm, params):
  cm_editbox.save()
  tar = window.findMatches(cm_editbox.getTextArea().value, cm_editbox.getCursor().ch, cm_editbox.getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)
def rundown(cm, params):
  cm_editbox.save()
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)


def overscroll(cm):
  def temp(l):
    if _options['relative_number']:
      return abs(cm.getCursor().line + 1 - l)
    else:
      return l
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', overscroll)




_options['_line_numbers'] = True
def line_numbers(state=False):
  cm_editbox.setOption('lineNumbers', state)
  _options['_line_numbers'] = state

_options['line_numbers'] = line_numbers

def on_down(ev):
  global ctrl, tables
  if ev.ctrlKey:
    ctrl=True
  else:
    ctrl=False

  if ev.which == 37 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', False)
      cm_editbox.setOption('lineWrapping', True)
      cm_editbox.setOption('readOnly', True)
  if ev.which == 39 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', True)
      cm_editbox.setOption('lineWrapping', False)
      cm_editbox.setOption('readOnly', False)
  if chr(ev.which)=='G' and ctrl:
    start = cm_editbox.getCursor(True).line
    end = cm_editbox.getCursor(False).line
    if start == end:
      window.alert(f'{cm_editbox.getCursor().line + 1}, {cm_editbox.getCursor().ch + 1}')
    else:
      diff = abs(start-end)
      window.alert('{}:{}({})'.format(start+1, end+1, diff+1))
    ev.preventDefault()
    ev.stopPropagation()

window.bind('keydown', on_down)

def do_py() -> None:
  try:
    print_red = []
    def print(*objects, sep=' ', end='\n'):
      print_red.append(sep.join(str(o) for o in objects) + end)
    class Q:
      def __call__(self, arg):
        if callable(arg):
          def f(*l, **kw):
            _ret = arg(*l, **kw)
            args = ', '.join(j for j in (', '.join(repr(i) for i in l), ', '.join(f'{k}={v!r}' for k, v in kw.items())) if j)
            print(f'{arg.__qualname__}({args}) -> {_ret}')
            return _ret
            
          f.__name__ = arg.__name__
          f.__qualname__ = arg.__qualname__
          return f
        print(arg)
        return arg
        
      def __or__(self, arg):
        print(arg)
        return arg
      
      __truediv__ = __div__ = __or__
      
    q = Q()
    window.vdo("gv")
    data = cm_editbox.getSelection()
    exec(data)
    if print_red:
      out = '\n'.join([data, ''.join(print_red)])
      window.vdo("gv")
      cm_editbox.replaceSelection(out.strip('\n'))
  except Exception as e:
    import traceback
    print_red += [i+'\n' for i in traceback.format_exc().splitlines()]
    out = '\n'.join([data, ''.join(print_red)])
    window.vdo("gv")
    cm_editbox.replaceSelection(out.strip('\n'))

def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)

def run_file(cm, params):
  try:
    exec(cm_editbox.getValue())
  except Exception as e:
    import traceback
    print(traceback.format_exc())
window.CodeMirror.Vim.defineEx("run_file", None, run_file)

def run_shard(*l, **kw):
  visual_shard(*l, **kw)
  window.setTimeout(do_py, 0)
window.CodeMirror.Vim.defineEx("run_shard", None, run_shard)

def visual_shard(*l, **kw):
  cm_editbox.save()
  cur_line = cm_editbox.getCursor().line
  look_ahead = editbox.value.splitlines()[cur_line:]
  look_behind = editbox.value.splitlines()[: cur_line]
  start, end = 0, 0

  count = 0
  for idx, i in enumerate(look_ahead):
    if not i.strip():
      count += 1
    else:
      count = 0
    if count > 1:
      end = idx+cur_line - 1
      break
      
  count = 0
  #for idx, i in enumerate([*reversed(look_behind)]):
  for idx, i in enumerate(list(reversed(look_behind))):
    if not i.strip():
      count += 1
    else:
      count = 0
    if count > 1:
      start = cur_line - idx + 1
      break
  window.vdo(f'{start+1}ggV{end}gg')
  #print(editbox.value.splitlines()[start:end])
window.CodeMirror.Vim.defineEx("visual_shard", None, visual_shard)


def runpy(cm, params):
  #g = globals()
  #g.update(_options)
  exec(params.argString, globals(), _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)


# i don't remember what's going on here.
def better_sort():
  #import re
  import _jsre as re
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else re.sub(r'\s\s+', ' ', text.strip().lower())
            for text in _nsre.split(s)]

  def if_comment(i):
    if i.lstrip().startswith('#'):
      return i
    if i.strip() == '':
      return ''
    return False

  def better_sort(s):
    gb = chunkBy(s.splitlines(), key=if_comment)
    gb = [list(v) for k, v in gb]
    #gb = '\n'.join('\n'.join(sorted(i, key=natural_sort_key)) for i in gb)
    gb = '\n'.join('\n'.join(window.natsort(i)) for i in gb)
    return(gb)

  cm_editbox.replaceSelection(better_sort(dat))

  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except Exception as e:
    print(e)
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)

def run_align(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection()
  try:
    out = align(matrix2(data))

    window.vdo('gv')
    cm_editbox.replaceSelection(out.strip('\n'))
  except:
    pass
window.CodeMirror.Vim.defineEx("align", None, run_align)

def caps(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection()
  try:
    out = data.title()

    window.vdo('gv')
    cm_editbox.replaceSelection(out.strip('\n'))
    window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
    window.vdo('yy')
  except:
    pass
window.CodeMirror.Vim.defineEx("caps", None, caps)




def bracespace(cm, params):
  chars = params.argString.strip()
  window.insertTextAtCursor(cm, chars[0])
  window.CodeMirror.Vim.exitInsertMode(cm_editbox)
  window.vdo('o')
  window.CodeMirror.Vim.exitInsertMode(cm_editbox)
  window.vdo('o')
  window.insertTextAtCursor(cm, chars[1])
  window.CodeMirror.Vim.exitInsertMode(cm_editbox)
  window.vdo('ka')
  window.insertTextAtCursor(cm, '  ')
window.CodeMirror.Vim.defineEx("bracespace", None, bracespace)


def run_surround(cm, params):
  try:
    chars = params.argString.strip()
    window.vdo("gv")
    data = cm_editbox.getSelection()
    if chars=='q':
      out = f'q({data})'
    else:
      out = f'{chars[0]}{data}{chars[1]}'
    cm_editbox.replaceSelection(out.strip('\n'))
    window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  except Exception as e:
    import traceback
    asyncio.run(popup(traceback.format_exc()))
window.CodeMirror.Vim.defineEx("surround", None, run_surround)

# simple html stuff

def popup(root, width='auto', height='auto'):
  if isinstance(root, (tuple, list, str, int, float, set, dict)):
    root = DIV(root)
  d = DIALOG(root)
  root.style['width'] = width
  root.style['height'] = height
      
  def on_click(ev):
    d.remove()
    cm_editbox.focus()
  d.bind('close', on_click)
    
  doc <= d
  
  d.showModal()
  
  return d
      
def bind(el, **kw):
  for k, v in kw.items():
    el.bind(k, v)
  return el
    
</script>
</html>
