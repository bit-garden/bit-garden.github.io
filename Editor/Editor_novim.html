<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}

* {
        font-family: Mono !important;
}

.CodeMirror, .CodeMirror-gutters{background:#000000 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}
 .cm-decorator{color: #ffaaff;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}

 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:18px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: rgba(18,18,18, 1);
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888;
  font-family: Mono;
  }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }


/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  /*border-radius: 3px;*/
  padding: 8px 8px;
  /*margin:6px;*/
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: rgba(18,18,18, 1);
  /*box-shadow: 0 4px 8px #000;*/
  outline: none;
  font-family: Mono !important;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}

pre, code, pre > * {
        font-family: Mono;
}


dialog {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 0px;
  box-shadow: 0 0 40px rgba(0,0,0,0.1), 0 0 10px rgba(0,0,0,0.25);
}
.card {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 12px 16px;
  box-shadow: 0 0 40px rgba(0,0,0,0.1), 0 0 10px rgba(0,0,0,0.25);
}

button, textarea, input{
  background: none;
  color: rgba(255,255,255,.87);
  border: none;
  border-bottom: 2px solid #00ccff;
  outline: none;
}

button{
  font-weight: bold;
  padding: 12px 16px;
}

.warn{
  border-bottom: 2px solid #B00020;
}


</style>
<script>
CodeMirror.defineSimpleMode("simplemode", {
  start: [
    {regex: /\w?"([^"\\]|\\.)*("|$)/, token: "variables"}, // Double quote
	
    {regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
    {regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
    
    {regex: /#.*$/, token: "comments"}, // darklights comments
    {regex: / \|( |$)/, token: 'nums'},
  ]
});
</script>

<body onload="brython({indexedDB: false})">
  <textarea class='editbox'></textarea>
</body>
<script>

// jk to escape, kj to auto complete, vw to select and copy current word
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')

// ctrl + e to run file or selection
CodeMirror.Vim.map('<C-e>', ':run_file', 'normal')
CodeMirror.Vim.map('<C-e>', ':run_file', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')

// Tab e to align table or selection
CodeMirror.Vim.map('<Tab>e', ':vdo :kpos|vip|:align|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>e', ':vdo :align', 'visual')

// put 2 spaces instead of tab char
CodeMirror.Vim.map('<Tab>', ':insertSoftTab', 'insert')

// Transpose table for easy column-wise edits
CodeMirror.Vim.map('<Tab>t', ':vdo :kpos|vip|:do_tp|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>t', ':vdo :do_tp', 'visual')

// natural sorting
CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')

// sort by selection
CodeMirror.Vim.map('<Tab>y', ':js sort_by()', 'visual')

// remove search higlights
CodeMirror.Vim.map('<Tab><Space>', ':noh', 'normal')

// Save command, TODO
CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'normal')
CodeMirror.Vim.map('ZA', ':py save_me.append(1)', 'insert')

// Align text selections
CodeMirror.Vim.map('<Tab>r', ':js alignRight()', 'visual')
CodeMirror.Vim.map('<Tab>l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map('<Tab>c', ':js alignCenter()', 'visual')

// quick select column in pipe table
CodeMirror.Vim.map('zv', ':vblock', 'normal')


editbox = document.querySelector('.editbox')
//if ('data' in localStorage){
//  editbox.value = localStorage.getItem('data')
//}
cm_editbox = CodeMirror.fromTextArea(editbox,{
            'matchBrackets':     true,
            'autoCloseBrackets': false,
            'lineNumbers':       true,
            "mode":              'simplemode',
            "theme":             "material",
            'tabSize':           2,
            'styleActiveLine':   true,
            //'keyMap':            'vim',
            'extraKeys':         {"Ctrl-Space": "autocomplete"}
 })
 function tab_to_space(cm){
  cm_editbox.execCommand("insertSoftTab")
}
cm_editbox.addKeyMap({'Ctrl-C': false})
CodeMirror.Vim.defineEx("insertSoftTab", null, tab_to_space)
//cm_editbox.addKeyMap({'Tab': tab_to_space})

//function on_change(cm, _change){
//  cm_editbox.save()
//  localStorage.setItem('data', editbox.value.replace(/ +$/mgi, ""));
//}
//
//cm_editbox.on('change',on_change)

function ac_hint(cm){
  cm.showHint({'hint': CodeMirror.hint.anyword})
}
CodeMirror.commands.autocomplete = ac_hint

function runjs(cm, params){
  eval(params.argString)
}

CodeMirror.Vim.defineEx("js", null, runjs)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}

function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}

function toclip(dat){
  navigator.clipboard.writeText(dat.toString())
    .then(() => {
      console.log(dat.toString() + ' to clip.');
    })
    .catch(err => {
      // This can happen if the user denies clipboard permissions:
      console.error('Could not copy text: ', err);
    });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0

  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replace(/\<bar\>/g, '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)
CodeMirror.Vim.defineEx("normal", null, runvdo)

function vblock(cm, params){
  cm_editbox.save()
  char_at = cm_editbox.getCursor().ch + 1
  vdo("?^\\s*(#<bar>$)|j")
  line1 = cm.getCursor().line + 1
  vdo("/^\\s*(#<bar>$)|k")
  line2 = cm.getCursor().line + 1
  vdo(line2 + "gg" + char_at + "<bar>t<bar>v" + line1 + "gg" + char_at + "<bar>T<bar>")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}



function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}


//testing char skipping, not space skipping exclusively.
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}


function kpos(cm, params){
  window.lastscroll = cm_editbox.getScrollInfo()
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
  cm_editbox.scrollTo(window.lastscroll.left, window.lastscroll.top)
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function uuid4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

</script>
<!--<script src="lib/brython_aio.js"></script>-->
<script src="lib/brython.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import window, aio
from browser import document as doc
from browser.html import *
import time

from javascript import RegExp, String
def dsplit(s, char=','):
  re = RegExp.new(r'(' + char + r')(?=(?:[^"]|"[^"]*")*$)')
  return ([j.strip() for idx, j in enumerate(String.new(i).split(re)) if not idx % 2]
      for i in s.splitlines() if i.strip())


# TODO
class timer:
  def __init__(self, mark='', func=print):
    self.func = func
    self.mark = mark

  def __enter__(self):
    self.start = time.time()
    return self

  def __exit__(self, *l):
    self.func(f'{self.mark} {time.time() - self.start}')

# TODO
class fopen():
  def __init__(self, new_file=False):
    if new_file:
      self.opts = {
        'type': 'saveFile',
        'accepts': [{
          'description': 'Text file',
          'extensions': ['txt'],
          'mimeTypes': ['text/plain'],
        }],
      }
    else:
      self.opts = {}

  async def __aenter__(self):
    if self.opts:
      self.fileHandle = await window.chooseFileSystemEntries(self.opts)
    else:
      self.fileHandle = await window.chooseFileSystemEntries()
    self.file = await self.fileHandle.getFile()
    self.text = await self.file.text()

    return self

  async def write(self, content):
    writer = await self.fileHandle.createWriter()
    await writer.truncate(0)
    await writer.write(0, content)

    await writer.close()

  async def __aexit__(self, *l):
    pass


def slot(name, *components, verbose=False):
  'Slot class generator. Similar to named tuple, but mutable.'
  if isinstance(components[0], str):
    components = [*components]
    slots = components.pop(0)
    defaults = components
    args = tuple(slots.split(' '))
    largs = ', '.join(args[:-len(defaults)] if defaults else args)
  else:
    base = {}
    for c in components:
      base.update(c)

    args = tuple(base.keys())
    defaults = tuple(base.values())
    largs = ', '.join(args[:-len(defaults)] if defaults else args)

  # Gather list of collections
  collections = {k: repr(v) for k, v in zip(args[-len(defaults):], defaults)
      if type(v) in (list, tuple, dict, set)}

  # Set default signature.
  kwargs = ', '.join(f'{k}={repr(None if k in collections else v)}' for k, v in zip(args[-len(defaults):], defaults))
  all_args = ', '.join(i for i in [largs, kwargs] if i)

  # Self setters.
  sargs = '\n    '.join(f'self.{k} = {v}' for k, v in zip(args, (f'{collections[i]} if {i} is None else {i}' if i in collections else i for i in args)))


  slot_template = f'''
class {name}:
  __slots__ = {repr(args)}
  def __init__(self,
      {all_args}):
    {sargs}

'''.strip()
  # Verbosity to print out generated code.
  if verbose:
    return slot_template

  local = {}
  exec(slot_template, local)
  return local[name]

# pure python versions for faster load
def itemgetter(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return obj[item]
  else:
    def g(obj):
      return tuple(obj[item] for item in items)
  return g

class groupby:
  # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
  # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
  def __init__(self, iterable, key=None):
    if key is None:
      key = lambda x: x
    self.keyfunc = key
    self.it = iter(iterable)
    self.tgtkey = self.currkey = self.currvalue = object()
  def __iter__(self):
    return self
  def __next__(self):
    self.id = object()
    while self.currkey == self.tgtkey:
      self.currvalue = next(self.it)  # Exit on StopIteration
      self.currkey = self.keyfunc(self.currvalue)
    self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
  def _grouper(self, tgtkey, id):
    while self.id is id and self.currkey == tgtkey:
      yield self.currvalue
      try:
        self.currvalue = next(self.it)
      except StopIteration:
        return
      self.currkey = self.keyfunc(self.currvalue)

def repeat(object, times=None):
  # repeat(10, 3) --> 10 10 10
  if times is None:
    while True:
      yield object
  else:
    for i in range(times):
      yield object

def zip_longest(*args, fillvalue=None):
  # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
  iterators = [iter(it) for it in args]
  num_active = len(iterators)
  if not num_active:
    return
  while True:
    values = []
    for i, it in enumerate(iterators):
      try:
        value = next(it)
      except StopIteration:
        num_active -= 1
        if not num_active:
          return
        iterators[i] = repeat(fillvalue)
        value = fillvalue
      values.append(value)
    yield tuple(values)

def partial(func, *args, **keywords):
  def newfunc(*fargs, **fkeywords):
    newkeywords = {**keywords, **fkeywords}
    return func(*args, *fargs, **newkeywords)
  newfunc.func = func
  newfunc.args = args
  newfunc.keywords = keywords
  return newfunc
  
def permutations(iterable, r=None):
  # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
  # permutations(range(3)) --> 012 021 102 120 201 210
  pool = tuple(iterable)
  n = len(pool)
  r = n if r is None else r
  if r > n:
    return
  indices = list(range(n))
  cycles = list(range(n, n-r, -1))
  yield tuple(pool[i] for i in indices[:r])
  while n:
    for i in reversed(range(r)):
      cycles[i] -= 1
      if cycles[i] == 0:
        indices[i:] = indices[i+1:] + indices[i:i+1]
        cycles[i] = n - i
      else:
        j = cycles[i]
        indices[i], indices[-j] = indices[-j], indices[i]
        yield tuple(pool[i] for i in indices[:r])
        break
    else:
      return
      
def chain(*iterables):
  # chain('ABC', 'DEF') --> A B C D E F
  for it in iterables:
    for element in it:
      yield element


def grouper(iterable, n, fillvalue=None):
  "Collect data into fixed-length chunks or blocks"
  # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
  args = [iter(iterable)] * n
  return zip_longest(*args, fillvalue=fillvalue)

def sub_group(dat):
  gb = groupby(dat, key=lambda i: i[0][0])
  gb = ((k, (*v,)) for k, v in gb)
  for k, v in gb:
    subs = ', '.join(f"{'/'.join(lcast(i.pop(0)[1:], str))}" for i in v)
    zips = (f"({', '.join(lcast(i, str))})" for i in zip(*v))
    yield [f'{k} ({subs})', *zips]
  
def is_num(_in):
  try:
    float(_in)
    return True
  except:
    return False

def align(*d):
  d = [[*i] for i in zip_longest(*(x for x in d for x in x), fillvalue='')]
  for col in d:
    l = max(len(f'{i}') for i in col)
    col[:] = [f'{i}'.rjust(l) if is_num(i) else f'{i}'.ljust(l) for i in col]
  return '\n'.join(' | '.join(i).rstrip() for i in zip(*d))

# --- end focus


ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = True
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['relative_number'] = True


def overscroll(cm):
  def temp(l):
    if _options['relative_number']:
      return abs(cm.getCursor().line + 1 - l)
    else:
      return l
  cm.setOption('lineNumberFormatter', temp);
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', overscroll)


_options['_line_numbers'] = True
def line_numbers(state=False):
  cm_editbox.setOption('lineNumbers', state)
  _options['_line_numbers'] = state

_options['line_numbers'] = line_numbers

def on_down(ev):
  global ctrl, tables
  if ev.ctrlKey:
    ctrl=True
  else:
    ctrl=False

  if ev.which == 37 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', False)
      cm_editbox.setOption('lineWrapping', True)
      cm_editbox.setOption('readOnly', True)
  if ev.which == 39 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', True)
      cm_editbox.setOption('lineWrapping', False)
      cm_editbox.setOption('readOnly', False)
  if chr(ev.which)=='G' and ctrl:
    start = cm_editbox.getCursor(True).line
    end = cm_editbox.getCursor(False).line
    if start == end:
      window.alert(f'{cm_editbox.getCursor().line + 1}, {cm_editbox.getCursor().ch + 1}')
    else:
      diff = abs(start-end)
      window.alert('{}:{}({})'.format(start+1, end+1, diff+1))
    ev.preventDefault()
    ev.stopPropagation()
  if chr(ev.which)=='Q' and ctrl:
    data = cm_editbox.getSelection()
    out = align(dsplit(data, '\|'))
    cm_editbox.replaceSelection(out.strip('\n'))
    ev.preventDefault()
    ev.stopPropagation()
  if chr(ev.which)=='S' and ctrl:
    save_me.append(1)
    ev.preventDefault()
    ev.stopPropagation()
  if chr(ev.which)=='O' and ctrl:
    aio.run(auto_saver())
    ev.preventDefault()
    ev.stopPropagation()
  if chr(ev.which)=='E' and ctrl:
    data = cm_editbox.getSelection()
    if data.strip():
      try:
        print_red = []
        def print(*objects, sep=' ', end='\n'):
          print_red.append(sep.join(str(o) for o in objects) + end)
        data = cm_editbox.getSelection()
        exec(data)
        if print_red:
          out = '\n'.join([data, ''.join(print_red)])
          cm_editbox.replaceSelection(out.strip('\n'))
      except Exception as e:
        import traceback
        print_red = traceback.format_exc().splitlines()
        out = '\n'.join([data, '\n'.join(print_red)])
        cm_editbox.replaceSelection(out.strip('\n'))
    else:
      try:
        exec(cm_editbox.getValue())
      except Exception as e:
        import traceback
        print(traceback.format_exc())
    ev.preventDefault()
    ev.stopPropagation()
window.bind('keydown', on_down)

def do_py() -> None:
  try:
    print_red = []
    def print(*objects, sep=' ', end='\n'):
      print_red.append(sep.join(str(o) for o in objects) + end)
    window.vdo("gv")
    data = cm_editbox.getSelection()
    exec(data)
    if print_red:
      out = '\n'.join([data, ''.join(print_red)])
      window.vdo("gv")
      cm_editbox.replaceSelection(out.strip('\n'))
  except Exception as e:
    import traceback
    print_red = traceback.format_exc().splitlines()
    out = '\n'.join([data, '\n'.join(print_red)])
    window.vdo("gv")
    cm_editbox.replaceSelection(out.strip('\n'))

def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)

def run_file(cm, params):
  try:
    exec(cm_editbox.getValue())
  except Exception as e:
    import traceback
    print(traceback.format_exc())
window.CodeMirror.Vim.defineEx("run_file", None, run_file)

def do_tp() -> None:
  try:
    window.vdo("gvo")
    data = cm_editbox.getSelection()
    data = list(list(i) for i in zip_longest(*dsplit(data, '\|')))
    out = align(data)
    cm_editbox.replaceSelection(out.strip('\n'))
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())

def run_tp(cm, params):
  do_tp()
window.CodeMirror.Vim.defineEx("do_tp", None, run_tp)

def runpy(cm, params):
  #g = globals()
  #g.update(_options)
  exec(params.argString, globals(), _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)

def better_sort():
  #import re
  import _jsre as re
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else re.sub(r'\s\s+', ' ', text.strip().lower())
            for text in _nsre.split(s)]

  def if_comment(i):
    if i.lstrip().startswith('#'):
      return i
    if i.strip() == '':
      return ''
    return False

  def better_sort(s):
    gb = groupby(s.splitlines(), key=if_comment)
    gb = [list(v) for k, v in gb]
    #gb = '\n'.join('\n'.join(sorted(i, key=natural_sort_key)) for i in gb)
    gb = '\n'.join('\n'.join(window.natsort(i)) for i in gb)
    return(gb)

  cm_editbox.replaceSelection(better_sort(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except Exception as e:
    print(e)
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)


def run_align(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection()
  out = align(dsplit(data, '\|'))
  window.vdo('gv')
  cm_editbox.replaceSelection(out.strip('\n'))
window.CodeMirror.Vim.defineEx("align", None, run_align)




#--- async stuff

def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)

save_me = []
loaded = False
_options['save_me'] = save_me

def save_on_blur(*l, **kw):
  if loaded:
    save_me.append(2)

window.onblur = save_on_blur

async def auto_saver():
  global loaded
  async with fopen() as f:
    cm_editbox.setValue(f.text)
    loaded = True
    while True:
      while not save_me:
        await aio.sleep(.1)
      cm_editbox.save()
      await f.write(editbox.value)
      if 1 in save_me:
        window.alert('saved')
      save_me.clear()
      print('Saved')

def _e(cm, params):
  aio.run(auto_saver())
window.CodeMirror.Vim.defineEx("e", None, _e)
window.CodeMirror.Vim.defineEx("edit", None, _e)

#async def main():
#  res = await aio.gather(auto_saver())
#  window.alert(str(res))
#
#aio.run(main())


async def popup(*l, **kw):
  d = DIALOG(*l, **kw)
  doc <= d
  d.showModal()
  while d.open:
    await asyncio.sleep(.5)
  d.remove()
  return d
  
class Popup:
  def __init__(self):
    self.d = DIALOG()
    doc <= self.d
  
  def __enter__(self):
    self.d.showModal()
    return self.d
    
  def __exit__(self, *l):
    self.d.open = False
    self.d.remove()
    
class El:
  def __init__(self, el, parent=None):
    self.el = el
    if parent:
      parent <= self.el
  
  def __enter__(self):
    return self.el
    
  def __exit__(self, *l):
    self.el.remove()

# import from notes file
def grid_to_tracks(cols=[], rows=[], width=0, height=0, offx=0, offy=0):
  # generates values to align a grid layout
  _width = width
  _cols = [0]
  for c in cols:
    if c == ...:
      _cols.append(c)
    elif c < 1:
      _cols.append(_width - width + _width * c)
      width -= _width * c
    else:
      _cols.append(_width - width + c)
      width -= c
      
  _height = height
  _rows = [0]
  for c in rows:
    if c == ...:
      _rows.append(c)
    elif c < 1:
      _rows.append(_height - height + _height * c)
      height -= _height * c
    else:
      _rows.append(_height - height + c)
      height -= c
  
  if ... in _cols:
    idx = _cols.index(...)
    _cols[idx:idx+1] = [_cols[idx-1]]
    _cols[idx:] = [i+width for i in _cols[idx:]]
    width = 0
    
  if ... in _rows:
    idx = _rows.index(...)
    _rows[idx:idx+1] = [_rows[idx-1]]
    _rows[idx:] = [i+height for i in _rows[idx:]]
    height = 0
  
  # optionally round
  _cols = [round(i+offx+width//2) for i in _cols]
  _rows = [round(i+offy+height//2) for i in _rows]
      
  return _cols, _rows


def grid_to_dims(grid, x=0, y=0, ex=None, ey=None):
  # uses a grid layout to return x,y/w,h values
  columns, rows = grid
  if ex is None:
    ex = x
  if ey is None:
    ey = y

  #return {'x': columns[:-1][x], 'y': rows[:-1][y],
  #    'w': columns[1:][ex] - columns[:-1][x],
  #    'h': rows[1:][ey] - rows[:-1][y]}
  return columns[:-1][x], rows[:-1][y],\
      columns[1:][ex] - columns[:-1][x],\
      rows[1:][ey] - rows[:-1][y]
# dark material height to tint
opacities = {0: 0,
     1: .05,
     2: .07,
     3: .08,
     4: .09,
     6: .11,
     8: .12,
     12: .14,
     16: .15,
     24: .16}
font_opacities = {'high': .87, 'medium': .6, 'disabled': .38}
font_error = (176, 0, 32, 1) #B00020

def tint(val, r, g, b, *_):
  # Tints rgb values to apply 'light'

  rt = r + (val * (255 - r))
  gt = g + (val * (255 - g))
  bt = b + (val * (255 - b))
  return (rt, gt, bt, *_)

def shade(val, r, g, b, *_):
  # Tints rgb values to apply 'dark' 

  rt = r - r*val 
  gt = g - g*val 
  bt = b - b*val 
  return (rt, gt, bt, *_)


def is_dark(r, g, b, *_):
  # determine color too dark
  # HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
  hsp =  0.299 * r**2 + 0.587 * g**2 + 0.114 * b**2
  return 127.5 >= hsp**(1/2.0)

def hilo(a, b, c):
  # used in compliment function

  if c < b: b, c = c, b
  if b < a: a, b = b, a
  if c < b: b, c = c, b
  return a + c

def complement(r, g, b, *_):
  # return complement color
  k = hilo(r, g, b)
  return (*(k - u for u in (r, g, b)), *_)

#decode hex to tuple
#tuple(bytes.fromhex("aabbccaa"))

callbacks = {}

def bind(*events):
  def _bind(f):
    for e in events:
      callbacks[e].append(f)
    return f
  return _bind

def unbind(f, *events):
  for e in events:
    callbacks[e].remove(f)

def emit(event, *l, **kw):
  for c in callbacks[event]:
    c(event, *l, **kw)

# list tools
def push(l, x):
  """Pushes item of l in direction 1 space. None is considered empty."""

  changes = []

  if ~(first_empty:=lindex(l, None, x)):
    del l[first_empty]
    changes = l[x: first_empty]
    l[x: first_empty] = [None] + l[x: first_empty]

  if not changes and ~(first_empty:=rindex(l, None, x)):
    del l[first_empty]
    changes = l[first_empty: x]
    l[first_empty: x] = l[first_empty: x] + [None]

  return changes

def rindex(l, val, start=None):
  # index from right
  for i in range(start or len(l)-1, -1, -1):
    if l[i] is val:
      return i
  return -1
def lindex(l, val, start=0):
  # index from left
  for i in range(start, len(l)):
    if l[i] is val:
      return i
  return -1

def parse(pat, s):
  if pat.startswith('[]'):
    pat = ' ' + pat
    s = ' ' + s
  ends = False
  if pat.endswith('[]'): ends = True
  pat = pat.split('[]')
  out = []
  for idx, p in enumerate(pat):
    if ends and idx == len(pat)-1:
      out.append(s)
    else:
      _s = s.partition(p)
      out.append(_s[0])
      s = _s[2]
  return out[1:]

def lcast(l, *kinds):
  if len(kinds) == 1:
    return (kinds[0](i) for i in l)
  return (k(i) for k, i in zip(kinds, l))



</script>
</html>
