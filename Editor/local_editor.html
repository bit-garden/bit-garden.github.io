<html>
<title>Blackboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png">
    <script src='lib/codemirror.js'></script>
  <link rel="stylesheet" href="lib/dialog.css">
	<link rel="stylesheet" href="lib/show-hint.css">

<script src='lib/simple.js'></script>
<link rel="stylesheet" href="lib/material.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="lib/anyword-hint.js"></script>
<script src="lib/dialog.js"></script>
<script src="lib/jump-to-line.js"></script>
<script src="lib/matchbrackets.js"></script>
<script src="lib/overlay.js"></script>
<script src="lib/search.js"></script>
<script src="lib/searchcursor.js"></script>
<script src="lib/show-hint.js"></script>
<script src="lib/vim.js"></script>

    <style>
@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}

@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Thin.ttf") format("truetype");
}
@font-face {
  font-family: Roboto;
  src: url("lib/Roboto-Regular.ttf") format("truetype");
}

* {
        font-family: Roboto;
}

.CodeMirror, .CodeMirror-gutters{background:#000000 !important;}

 .cm-strike{color: #888888;}
 .cm-under{text-decoration: underline;}
 .cm-comments{color: #888888;    }
 .cm-strings{color: #aaffaa;}
 .cm-variables{color: #aaffff;}

 .cm-deco{color: #ffbf00;}
 .cm-decorator{color: #ffaaff;}

 .cm-nums{color: #ffaaaa;}

 .cm-numss{color: #afafff;}

 .CodeMirror, .CodeMirror * {font-family: Mono !important;}

      .editbox + .CodeMirror{
        font-family: Mono !important;
        height:auto;
        line-height:18px;
        font-size:14px;
        z-index:0;
      }
      body{padding:0px;margin:0px;}
  .CodeMirror-activeline > span, .CodeMirror-activeline > span > span{
	     color: #888888 !important;
	}
  .CodeMirror-scrollbar-filler{display:none !important;}
  .CodeMirror-hscrollbar, .CodeMirror-vscrollbar{
  overflow:hidden;
  }
  .CodeMirror-hints{
  background: #000000;
  color:white;
  overflow:hidden;
  }
  .CodeMirror-hint{
  color:#888888;
  font-family: Mono;
  }
  .CodeMirror-linenumber{
  color:#888888 !important;
  }


input::-webkit-calendar-picker-indicator {
  display: none;
}

/* card style */
.codemirror-hints, .codemirror-dialog {
  border: none;
  /*border-radius: 3px;*/
  padding: 8px 8px;
  /*margin:6px;*/
  font-size: 14px;
  cursor: default;
  color: white;
  background-color: #000000;
  /*box-shadow: 0 4px 8px #000;*/
  outline: none;
  font-family: Mono !important;
}

::-webkit-scrollbar {
    width: 0px;  /* Remove scrollbar space */
    background: transparent;  /* Optional: just make scrollbar invisible */
}


@font-face {
  font-family: Roboto-mono;
  src: url("lib/RobotoMono-Light.ttf") format("truetype");
}
pre, code, pre > * {
        font-family: Roboto-mono;
}
h1, h2, h3, h4{
  font-weight: normal;
}


hr {
  border: 0;
  height: 1px;
  background-image: -webkit-linear-gradient(left, rgba(128, 128, 128, 0), rgba(128, 128, 128, .32), rgba(128, 128, 128, 0));
  background-image: -moz-linear-gradient(left, rgba(128, 128, 128, 0), rgba(128, 128, 128, .32), rgba(128, 128, 128, 0));
  background-image: -ms-linear-gradient(left, rgba(128, 128, 128, 0), rgba(128, 128, 128, .32), rgba(128, 128, 128, 0));
  background-image: -o-linear-gradient(left, rgba(128, 128, 128, 0), rgba(128, 128, 128, .32), rgba(128, 128, 128, 0));
  background-image: linear-gradient(left, rgba(128, 128, 128, 0), rgba(128, 128, 128, .32), rgba(128, 128, 128, 0));
}

</style>
<script>
// Returns if a value is a string
function isString (value) {
return typeof value === 'string' || value instanceof String;
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};



	  CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
{regex: /\w?"([^"\\]|\\.)*("|$)/, token: "strings"}, // Double quote
	
//{regex: /#(\S|\s\s).*$/, token: "comments"}, // darklights comments
//{regex: /#(\s\S.*|\s*$)/, token: "deco"}, // highlights comments
{regex: /#.*$/, token: "comments"}, // darklights comments
//{regex: /\s*\@\w+/, token: "decorator"}, // highlights comments
	
{regex: /(?![ \{\(\[])\w?'([^'\\]|\\.)*'\s*(?=[\)\],:\}.$ ?])/, token: "strings"}, // single quote strings code
{regex: /(^| )'([^']|'\w)*'( |$)/, token: "strings"}, // single quote strings speech
//{regex: /[-+]?[0-9]*\.?[0-9]+/, token: "nums"}, // numbers
//{regex: /(__)(.*?)\1/, token: "under"},
//{regex: /(~~)(.*?)\1/, token: "strike"},
//{regex: / \|( |$)/, token: "nums"},
  ]
});
	  CodeMirror.defineSimpleMode("simplermode", {
  // The start state contains the rules that are intially used
  start: [
{regex: /#.*$/, token: "comments"}, // darklights comments
  ]
});
</script>
<body onload="brython({indexedDB: false})"></body>
<textarea class='editbox'></textarea>
</body>
<script>
CodeMirror.Vim.map('jk', '<Esc>', 'insert')
CodeMirror.Vim.map('<C-e>', ':js null', 'normal')
CodeMirror.Vim.map('kj', ':js cm_editbox.showHint()', 'insert')
CodeMirror.Vim.map('vw', '<Esc>viwygv', 'insert')

//CodeMirror.Vim.map('<C-e>', ':vdo :kpos|vi[|:do_py|:rpos|l', 'normal')
//CodeMirror.Vim.map('<C-e>', ':vdo :kpos|vi[|:do_py|:rpos|a', 'insert')
CodeMirror.Vim.map('<C-e>', ':run_file', 'normal')
CodeMirror.Vim.map('<C-e>', ':run_file', 'insert')
CodeMirror.Vim.map('<C-e>', ':do_py', 'visual')

CodeMirror.Vim.map('<Tab>e', ':vdo :kpos|vip|:align|:rpos|l', 'normal')
//CodeMirror.Vim.map('<Tab>e', ':vdo :kpos|vip|:align|:rpos|a', 'insert')
CodeMirror.Vim.map('<Tab>e', ':vdo :align', 'visual')

CodeMirror.Vim.map('<Tab>', ':insertSoftTab', 'insert')

CodeMirror.Vim.map('<Tab>t', ':vdo :kpos|vip|:do_tp|:rpos|l', 'normal')
CodeMirror.Vim.map('<Tab>t', ':vdo :do_tp', 'visual')

CodeMirror.Vim.map('<C-y>', ':vdo l|:kpos|vip|:better_sort|:rpos', 'normal')
CodeMirror.Vim.map('<C-y>', ':better_sort', 'visual')
CodeMirror.Vim.map('<Tab>y', ':js sort_by()', 'visual')

CodeMirror.Vim.map('<Tab><Space>', ':noh', 'normal')
CodeMirror.Vim.map('ZA', ':py save_me.append(True)', 'normal')
CodeMirror.Vim.map('ZA', ':py save_me.append(True)', 'insert')

CodeMirror.Vim.map('<C-k>', ':runup', 'normal')
CodeMirror.Vim.map('<C-j>', ':rundown', 'normal')

CodeMirror.Vim.map('<Tab>r', ':js alignRight()', 'visual')
CodeMirror.Vim.map('<Tab>l', ':js alignLeft()', 'visual')
CodeMirror.Vim.map('<Tab>c', ':js alignCenter()', 'visual')

CodeMirror.Vim.map('zv', ':vblock', 'normal')



  editbox = document.querySelector('.editbox')
  //if ('data' in localStorage){
  //  editbox.value = localStorage.getItem('data')
  //}
  cm_editbox = CodeMirror.fromTextArea(editbox,{
              'matchBrackets':     true,
              'autoCloseBrackets': false,
              'lineNumbers':       true,
              "mode":              'simplemode',
              "theme":             "material",
              'tabSize':           2,
              'styleActiveLine':   true,
              'keyMap':            'vim',
              'extraKeys':         {"Ctrl-Space": "autocomplete"}
   })
   function tab_to_space(cm){
    cm_editbox.execCommand("insertSoftTab")
  }
  cm_editbox.addKeyMap({'Ctrl-C': false})
  CodeMirror.Vim.defineEx("insertSoftTab", null, tab_to_space)
  //cm_editbox.addKeyMap({'Tab': tab_to_space})

  //function on_change(cm, _change){
  //  cm_editbox.save()
  //  localStorage.setItem('data', editbox.value.replace(/ +$/mgi, ""));
  //}
  //
  //cm_editbox.on('change',on_change)

  function ac_hint(cm){
    cm.showHint({'hint': CodeMirror.hint.anyword})
  }
  CodeMirror.commands.autocomplete = ac_hint

  function runjs(cm, params){
    eval(params.argString)
  }

  CodeMirror.Vim.defineEx("js", null, runjs)

function put(_text, pre=false){
  reg('z', _text)
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  if (!pre)
    vdo('l"zp')
  else
    vdo('l"zP')
}

function key(_key){
  CodeMirror.Vim.handleKey(cm_editbox, _key, 'macro')
}
CodeMirror.Vim.defineEx("key", null, key)

function reg(_reg, _new = null){
  if(_new != null){
    CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0] = _new
  }
  return CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]
}

function natsort(arr){ // ignores excessive spacing
  //arr = arr.map((i)=>i.trim().replace(/\s\s+/g, ' '))
  //arr.foreach((i)=>i=i.split().join(' '))
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  //(a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' '))
  return arr.sort((a, b) => collator.compare(a.trim().replace(/\s\s+/g, ' '), b.trim().replace(/\s\s+/g, ' ')))
}
//sort natural order in tables
function itemgetter(keys){
    return function test2(_dict){
        out = ''
        keys.forEach((e)=>out+=_dict[e]+'|')
        return out
    }
}
function sort_dicts(_dicts, _keys){
  keys = itemgetter(_keys)
  var collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});
  return _dicts.sort((a, b) => collator.compare(keys(a), keys(b)))
}



function toclip(dat){
navigator.clipboard.writeText(dat.toString())
  .then(() => {
    console.log(dat.toString() + ' to clip.');
  })
  .catch(err => {
    // This can happen if the user denies clipboard permissions:
    console.error('Could not copy text: ', err);
  });
}

function fromclip(){
dat = ''
navigator.clipboard.readText()
  .then(text => {
    dat = text
  })
  .catch(err => {
    dat = err
  });
  return dat
}

function move_to(tar, _forward = true) {
  var matchingLines = [];
  var matchingChars = [];
  var allLines      = editbox.value.split("\n");
  var pattern       = RegExp(tar)
  var start         = cm_editbox.getCursor().line
  var startch       = cm_editbox.getCursor().ch
  var last          = 0
  var lastch        = 0

  for (var i = 0; i < allLines.length; i++) {
    //match = allLines[i].match(pattern)
    match = pattern.exec(allLines[i])
    if (match) {
      if (i < start){
        matchingLines = [i]
        matchingChars = [match.index]
      }
      if (i >= start){
        matchingLines.push(last);
        matchingChars.push(lastch)
      }
      if (i > start){
        matchingLines.push(i);
        matchingChars.push(match.index)
        break;
      }
      else
        last = i
        lastch = match.index
    }
  }
  //console.log(matchingLines)
  if (_forward){
    cm_editbox.setCursor({'line':matchingLines[matchingLines.length-1], 'ch': matchingChars[matchingChars.length-1]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[matchingLines.length-1];
    }
  else{
    cm_editbox.setCursor({'line':matchingLines[0], 'ch': matchingChars[0]}) // , 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
    //vdo('_')
    //return matchingLines[0];
  }
}

// better function for doing macros
// handles ' |' seperators
// handles ? and / and : actions along with keys
// only matches first instance at ? and /
  // use look arounds to get further in the line with multiple instances
function vdo(_keys, _type='macro'){
  //console.log('"' + _keys + '"')
  CodeMirror.Vim.exitInsertMode(cm_editbox)
  __keys = _keys.trimLeft().split('|')
  __keys.forEach((block)=>{
    block = block.replaceAll('<bar>', '|')
    if(block.startsWith(':')){
      //do ex
      // test js vdo('jjjj |:js alert("hi")')
      CodeMirror.Vim.handleEx(cm_editbox, block.slice(1))
      //add / move_to and ? leads
    }else if(block.startsWith('/')){
      move_to(block.slice(1))
    }else if(block.startsWith('?')){
      move_to(block.slice(1), false)
    }else{
      //normal vdo
      block.split('').forEach((i)=>{
        CodeMirror.Vim.handleKey(cm_editbox, i, _type)
      })
    }
  })
}
function runvdo(cm, params){
  vdo(params.argString)
}
CodeMirror.Vim.defineEx("vdo", null, runvdo)
CodeMirror.Vim.defineEx("normal", null, runvdo)

function vblock(cm, params){
  cm_editbox.save()
  char_at = cm_editbox.getCursor().ch + 1
  vdo("?^\\s*(#<bar>$)|j")
  line1 = cm.getCursor().line + 1
  vdo("/^\\s*(#<bar>$)|k")
  line2 = cm.getCursor().line + 1
  vdo(line2 + "gg" + char_at + "<bar>t<bar>v" + line1 + "gg" + char_at + "<bar>T<bar>")
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
}
CodeMirror.Vim.defineEx('vblock', null, vblock)

function alignRight(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padStart(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignLeft(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      return i.trim().padEnd(width, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}
function alignCenter(){
    vdo('gvy')
    sel = CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
    sel = sel.split('\n')
    width = sel[0].length
    sel = sel.map((i)=>{
      base = width - i.trim().length
      left = Math.floor(base/2)
      right = base - left
      return ''.padEnd(left, ' ') + i.trim() + ''.padStart(right, ' ');
    })
    CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = sel.join('\n')
    vdo('gvp')
}



function make_popup(_dat, _height = '10em'){
  cm_editbox.openDialog('<textarea style="font-family: Mono; white-space: pre;  overflow: auto; outline: none;border:none; background:none; color:white;width:100%; height:'+_height+'">'+_dat+'</textarea><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}

function make_simple_popup(_dat){
  cm_editbox.openDialog('<p style="background:none; color:white;width:100%; height:10em">'+_dat.replaceAll('\n','<br>')+'</p><br><button style="background:none; border:none; outline:none; color:white; font-size:14px;width:100%; font-weight:bold;">Done</button>', null, {'closeOnBlur': false})
}


function sort_by(){
  vdo('gvy')
  t = window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0]
  t = t.split('\n')
  t = t.join(' \n')+' '
  window.CodeMirror.Vim.getRegisterController().getRegister('"').keyBuffer[0] = t
  w = t.split('\n')[0].length - 1
  h = t.split('\n').length - 1
  vdo('0PV' + h.toString() + 'j|:better_sort')
  CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
  vdo(h.toString() + 'k0')
  CodeMirror.Vim.handleKey(cm_editbox, '<C-v>', 'macro')
  vdo(h.toString() + 'j' + w.toString() + 'lx')
}


//testing char skipping, not space skipping exclusively.
function findMatches(text, tar, start=1) {
  var matchingLines = [];
  var allLines = text.split("\n");
  //console.log(allLines[start].charAt(tar))
  var character = allLines[start].charAt(tar)
	var pattern = RegExp("(?<=^.{"+tar+"})\[^"+character+"]")
	var last = 0
    for (var i = 0; i < allLines.length; i++) {
        if (allLines[i].match(pattern)) {
			if (i >= start)
              matchingLines.push(last);
			if (i > start){
			  matchingLines.push(i);
			  break;}
			else
			  last = i
        }
    }
    return matchingLines;
}


function kpos(cm, params){
  window.lastscroll = cm_editbox.getScrollInfo()
  window.lastline = cm_editbox.getCursor().line
  window.lastch = cm_editbox.getCursor().ch
}
CodeMirror.Vim.defineEx('kpos', null, kpos)

function rpos(cm, params){
  cm_editbox.setCursor({'line':window.lastline, 'ch': window.lastch})
  cm_editbox.scrollTo(window.lastscroll.left, window.lastscroll.top)
}
CodeMirror.Vim.defineEx('rpos', null, rpos)

function notes(cm, params){
  make_popup(`^e in normal insert visual
finds between _table_ markers(or visual) and runs as table

,\\ visual
aligns by |
,, ,= visual
aligns by , or = respectively
,; visual
aligns by :

^j ^k normal
goes up or down to non whitespace character

^y normal visual
sort visual or vip

,y visualblock
sort by visualblock

,l ,c ,r visualblock
align left, center, right

vw insert
select word, then yank word

cw insert
change word or next word

s' s" s[ s\\ s{ s( s_ visual
surrounds by ' " [] | {} () _

,a insert
escape A

,I insert
escape I

vb insert
select between |

zv normal
select between ---

zb normal
select in table section

kj insert normal
auto complete based on file contents

jk fd insert
escape

,/ ,? insert
search forward or backward and drop back to insert

,h ,j ,k ,l insert normal
jump between | and - respectivly for tables

;; insert normal
command line

,<space>
stop search highlight

]- [- normal
jump to ---

'' insert
place "

# re stuff
(,)(?=(?:[^"]|"[^"]*")*$) # csv: capture unencolsed ',' chars
(\\#|\\/\\/)(\\S|\\s\\s).*$ # Big comment
(\\#|\\/\\/)\\s.*$ # Small comments
\\w?"([^"\\\\]|\\\\.)*("|$) # Double quotes
(?![ \\{\\(\\[])\\w?'([^'\\\\]|\\\\.)*'\\s*(?=[\\)\\],:\\}.$ ])/ # Single quote code
(^| )'([^']|'\\w)*'( |$) # Single quote prose

# non complete calendar events
\| (?!-)\S[^\|]+

# find by surrounding
(__)(.*?)\\1

# shuffle search
/(?:([dameagrirnbne])(?!.*?\\1)){13}/.exec($0.innerText)
/(?:([trarneicoos])(?!.*?\\1)){11}/.exec($0.innerText)

# quick sanity check on table
class Row(Entity):
  prop = Property()
for i in t._indices: r[i] = Row(**r[i]).to_dict()


`)
}
CodeMirror.Vim.defineEx('notes', null, notes)

function uuid4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

</script>
<script src="lib/brython_aio.js"></script>
<script src="lib/brython_stdlib.js"></script>
<script type="text/python">

from browser import aio, window
from browser import window
from browser import document as doc
from browser.html import *
#import time
#import traceback

alert, prompt, confirm = window.alert, window.prompt, window.confirm

class fopen():
  def __init__(self, new_file=False):
    if new_file:
      self.opts = {
        'type': 'saveFile',
        'accepts': [{
          'description': 'Text file',
          'extensions': ['txt'],
          'mimeTypes': ['text/plain'],
        }],
      }
    else:
      self.opts = {}

  async def __aenter__(self):
    if self.opts:
      self.fileHandle = await window.chooseFileSystemEntries(self.opts)
    else:
      self.fileHandle = await window.chooseFileSystemEntries()
    self.file = await self.fileHandle.getFile()
    self.text = await self.file.text()

    return self

  async def write(self, content):
    writer = await self.fileHandle.createWriter()
    await writer.truncate(0)
    await writer.write(0, content)

    await writer.close()

  async def __aexit__(self, *l):
    pass



def slot(name, slots='', *defaults, verbose=False):
  'Slot class generator. Similar to named tuple, but mutable.'

  args = tuple(slots.split(' '))
  largs = ', '.join(args[:-len(defaults)] if defaults else args)
  kwargs = ', '.join(f'{k}={repr(v)}' for k, v in zip(args[-len(defaults):], defaults))
  all_args = ', '.join(i for i in [largs, kwargs] if i)
  sargs = ', '.join(f'self.{i}' for i in args) + ' = ' + ', '.join(args)
  rargs = ', '.join(f'"{k}": self.{k}' for k in args if not k.startswith('_'))
  slot_template = f'''
class {name}:
  __slots__ = {repr(args)}

  def __init__(self, {all_args}):
    {sargs}

  def __repr__(self):
    return str({{{rargs}}})

  def __call__(self, **kw):
    return self.__class__(**dict({{{rargs}}}, **kw))

  def to_dict(self):
    return {{{rargs}}}

'''.strip()
  if verbose:
    return(slot_template)
  local = {}
  exec(slot_template, local)
  return local[name]


def prop(name, slots='', *defaults, verbose=False):
  'Slot class generator. Similar to named tuple, but mutable.'

  args = tuple(slots.split(' '))

  binds = ', '.join(f'"{i}": []' for i in args)
  unders = tuple([f'_{i}' for i in args])

  largs = ', '.join(args[:-len(defaults)] if defaults else args)
  kwargs = ', '.join(f'{k}={repr(v)}' for k, v in zip(args[-len(defaults):], defaults))
  all_args = ', '.join(i for i in [largs, kwargs] if i)
  sargs = ', '.join(f'self._{i}' for i in args) + ' = ' + ', '.join(args)
  rargs = ', '.join(f'"{k}": self._{k}' for k in args if not k.startswith('_'))

  prop_temp = '''  @property
  def {_prop}(self):
    return self._{_prop}

  @{_prop}.setter
  def {_prop}(self, value):
    if self._{_prop} != value:
      last = self._{_prop}
      self._{_prop} = value

      for c in self._callbacks['{_prop}']:
        c(self, last, value)

  @classmethod
  def on_{_prop}(cls, f):
    cls._callbacks['{_prop}'].append(f)
    return f
'''
  gen_props = '\n'.join(prop_temp.format(_prop=a) for a in args)

  slot_template = f'''
class {name}:
  __slots__ = {repr(unders)}

  _callbacks = {{{binds}}}

  def __init__(self, {all_args}):
    {sargs}

  def __repr__(self):
    return str({{{rargs}}})

  def __call__(self, **kw):
    return self.__class__(**dict({{{rargs}}}, **kw))

  def to_dict(self):
    return {{{rargs}}}

  @classmethod
  def bind(cls, **kw):
    for k, v in kw.items():
      cls._callbacks[k].append(v)

  @classmethod
  def unbind(cls, **kw):
    for k, v in kw.items():
      cls._callbacks[k].remove(v)

{gen_props}

'''.strip()
  if verbose:
    return(slot_template)
  local = {}
  exec(slot_template, local)
  return local[name]


def compose(cfg, base=prop, verbose=False):
  entities = {}

  for cls, props in cfg['cls'].items():
    mixed = {'cls': cls, 'uuid': ''}

    for c in props['_components']:
      mixed.update(cfg['components'][c])

    mixed.update(props)

    entities[cls] = base(cls, ' '.join(mixed.keys()), *mixed.values(), verbose=verbose)

  return entities


import _jsre as re

def split(pat, string):
  out = []
  _string = string
  found = re.findall(pat, string)

  while found:
    tar = found.pop(0)
    out.append(_string.split(tar)[0])
    _string = tar.join(_string.split(tar)[1:])
  out.append(_string)
  return out

re.split = split

def Task(coro, Id, block):
  async def _task():
    block[Id] = None
    try:
      block[Id] = await coro
    except Exception as e:
      block[Id] = e

    if not block[Id]:
      del block[Id]
  return _task()

async def gather(*coros, rate=0):
  dones = {}
  counts = 0 # only task0, task1, task2 because brython coro is missing __name__
  for c in coros:
    aio.run(aio.Task(c, f'task{counts}', dones))
    counts += 1
  while not all(dones.values()):
    await aio.sleep(rate)
  return dones

aio.gather = gather
aio.Task = Task

class Dimension:
  def __init__(self, bottom, height, left, right, top, width):
    self.bottom = bottom
    self.height = height
    self.left = left
    self.right = right
    self.top = top
    self.width = width
    self.center = (left + (width/2), top + (height/2))

  def __repr__(self):
    return "{" + f"'top': {repr(self.top)}, 'bottom': {repr(self.bottom)}, 'left': {repr(self.left)}, 'right': {repr(self.right)}, 'height': {repr(self.height)}, 'width': {repr(self.width)}, 'center': {repr(self.center)}" + "}"

def getdim(el):
  br = el.getBoundingClientRect()
  out = {
          'bottom': br.bottom,
          'height': br.height,
          'left': br.left,
          'right': br.right,
          'top': br.top,
          'width': br.width
          }
  return Dimension(**out)

class Event:
  '''
  Asyncio primitive, Event.
  https://docs.python.org/3/library/asyncio-sync.html
  '''

  def __init__(self, *):
    self._set = False

  async def wait(self):
    while not self._set:
      await aio.sleep(0)

  def is_set(self):
    return self._set

  def set(self):
    self._set = True

  def clear(self):
    self._set = False

aio.Event = Event

class Lock:
  def __init__(self, *):
    self._locked = False

  async def acquire(self):
    while self._locked:
      await aio.sleep(0)
    self._locked = True

  def release(self):
    if not self._locked:
      raise RuntimeError('Lock is already released')
    self._locked = False

  def locked(self):
    return self._locked

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()

aio.Lock = Lock

class Semaphore:
  def __init__(self, value=1, *):
    self._locked = False
    self.count = value
    self.limit = value

  async def acquire(self):
    while self.count < 1:
      await aio.sleep(0)
    self.count -= 1

  def release(self):
    self.count = min(self.count + 1, self.limit)

  def locked(self):
    return self.count == 0

  async def __aenter__(self):
    await self.acquire()
    return self

  async def __aexit__(self, *l):
    self.release()

aio.Semaphore = Semaphore

def itemgetter(*items):
  if len(items) == 1:
    item = items[0]
    def g(obj):
      return obj[item]
  else:
    def g(obj):
      return tuple(obj[item] for item in items)
  return g


class groupby:
  # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
  # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
  def __init__(self, iterable, key=None):
    if key is None:
      key = lambda x: x
    self.keyfunc = key
    self.it = iter(iterable)
    self.tgtkey = self.currkey = self.currvalue = object()
  def __iter__(self):
    return self
  def __next__(self):
    self.id = object()
    while self.currkey == self.tgtkey:
      self.currvalue = next(self.it)  # Exit on StopIteration
      self.currkey = self.keyfunc(self.currvalue)
    self.tgtkey = self.currkey
    return (self.currkey, self._grouper(self.tgtkey, self.id))
  def _grouper(self, tgtkey, id):
    while self.id is id and self.currkey == tgtkey:
      yield self.currvalue
      try:
        self.currvalue = next(self.it)
      except StopIteration:
        return
      self.currkey = self.keyfunc(self.currvalue)

def repeat(object, times=None):
  # repeat(10, 3) --> 10 10 10
  if times is None:
    while True:
      yield object
  else:
    for i in range(times):
      yield object

def zip_longest(*args, fillvalue=None):
  # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
  iterators = [iter(it) for it in args]
  num_active = len(iterators)
  if not num_active:
    return
  while True:
    values = []
    for i, it in enumerate(iterators):
      try:
        value = next(it)
      except StopIteration:
        num_active -= 1
        if not num_active:
          return
        iterators[i] = repeat(fillvalue)
        value = fillvalue
      values.append(value)
    yield tuple(values)

def partial(func, *args, **keywords):
  def newfunc(*fargs, **fkeywords):
    newkeywords = {**keywords, **fkeywords}
    return func(*args, *fargs, **newkeywords)
  newfunc.func = func
  newfunc.args = args
  newfunc.keywords = keywords
  return newfunc

def s2m(s, *types, fillvalue='', filltype=str, ignorecomment=True):
  return [[t(j.strip() or fillvalue) for j, t in zip_longest(i.split('|'), types, fillvalue=filltype)]
      for i in s.strip().splitlines()
      if (ignorecomment and not i.strip().startswith('#') or not ignorecomment)]

def s2d(s, *types, fillvalue='', filltype=str, ignorecomment=True):
  _headers = [i.strip() for i in s.strip().splitlines()[0].lstrip('#').split('|')]
  return [dict(zip(_headers, [t(j.strip() or fillvalue) for j, t in zip_longest(i.split('|'), types, fillvalue=filltype)]))
      for i in s.strip().splitlines()[1:]
      if (ignorecomment and not i.strip().startswith('#') or not ignorecomment)]

def is_num(_in):
  try:
    float(_in)
    return True
  except:
    return False

def align(_dat, transpose=False):
  if isinstance(_dat[0], dict):
    fill(_dat)
    _heads = list(_dat[0].keys())
    ig = itemgetter(*_heads)
    dat = [_heads, *[list(ig(i)) for i in _dat]]
  else:
    dat = [[str(j) for j in i] for i in _dat]
  if transpose:
    dat = list(map(list, zip(*dat)))

  max_len = max(len(i) for i in dat)
  for i in dat:
    i.extend(['']*(max_len-len(i)))
  widths = [max(map(len, col)) for col in zip(*dat)]
  _out = ''
  for row in dat:
    _out += ' | '.join((val.ljust(width) if not is_num(val) else val.rjust(width)
      for val, width in zip(row, widths))).rstrip() + '\n'
  return _out

# --- end focus


ctrl = False
tables = {}
_options = {}
editbox = window.editbox
cm_editbox = window.cm_editbox
_options['editbox'] = cm_editbox
_options['so'] = 6*12
_options['center'] = True
_options['body'] = doc.querySelector('body')
_options['window'] = window
_options['limelight'] = None
_options['printer'] = 'quick'
_options['relative_number'] = True

def runup(cm, params):
  cm_editbox.save()
  tar = window.findMatches(cm_editbox.getTextArea().value, cm_editbox.getCursor().ch, cm_editbox.getCursor().line)[0]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("runup", None, runup)
def rundown(cm, params):
  cm_editbox.save()
  tar = window.findMatches(_options['editbox'].getTextArea().value, _options['editbox'].getCursor().ch, _options['editbox'].getCursor().line)[-1]
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(tar)+", 'ch':"+str(_options['editbox'].getCursor().ch)+"})")
window.CodeMirror.Vim.defineEx("rundown", None, rundown)

def showRelativeLines(cm):
  #cm.setOption('lineNumbers', cm.state.vim.visualMode)
  lineNum = cm.getCursor().line + 1;

  if _options['limelight'] is not None:
    look_at = int(doc.querySelector('.CodeMirror').scrollHeight/12)
    last_line = cm.lastLine()
    if len(cm_editbox.getSelections()) > 1:
      cur_line = cm_editbox.listSelections()[0].anchor.line
      cur_line_bot = cm_editbox.listSelections()[-1].anchor.line
    else:
      cur_line = cm.getCursor(True).line
      cur_line_bot = cm.getCursor(False).line
    line_range = range(cur_line, cur_line_bot+1)
    up = True
    down = True
    for i in range(look_at):
      if _options['limelight']:
        if cm_editbox.state.vim.visualMode:
          if cur_line-i in line_range:
            cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          else:
            cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          if cur_line+i in line_range:
            cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          else:
            cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
        else:
          #going down
          if cur_line+i <= last_line and down and cm.getLine(cur_line+i).strip():
            cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
          elif cur_line+i <= last_line and i:
            cm.addLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
            down = False

          #going up
          if cur_line-i >= 0 and up and cm.getLine(cur_line-i).strip():
            cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
          elif cur_line-i >= 0 and i:
            cm.addLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
            up = False
      else:
        cm.removeLineClass(cur_line-i, 'text', 'CodeMirror-activeline')
        cm.removeLineClass(cur_line+i, 'text', 'CodeMirror-activeline')
      cm.removeLineClass(lineNum-1-i, 'gutter', 'CodeMirror-activeline-gutter')
      cm.removeLineClass(lineNum-1+i, 'gutter', 'CodeMirror-activeline-gutter')
    cm.addLineClass(lineNum-1, 'gutter', 'CodeMirror-activeline-gutter')

    if (cm.getCursor().line == lineNum):
      #cm.addLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
      #cm.removeLineClass(l, 'gutter', 'CodeMirror-activeline-gutter')
      return


    #cm.getCursor().line = lineNum
  def temp(l):
    if _options['relative_number']:
      return abs(lineNum-l)
    else:
      return l
  cm.setOption('lineNumberFormatter', temp);
  if _options['center'] and not cm_editbox.state.vim.insertMode and not cm_editbox.state.vim.visualMode:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',doc.querySelector('.CodeMirror').scrollHeight/2)
  else:
    doc.querySelector('.CodeMirror').CodeMirror.setOption('cursorScrollMargin',_options['so'])
doc.querySelector('.CodeMirror').CodeMirror.on('cursorActivity', showRelativeLines)




_options['_line_numbers'] = True
def line_numbers(state=False):
  cm_editbox.setOption('lineNumbers', state)
  _options['_line_numbers'] = state

_options['line_numbers'] = line_numbers

def on_down(ev):
  global ctrl, tables
  if ev.ctrlKey:
    ctrl=True
  else:
    ctrl=False

  if ev.which == 37 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', False)
      cm_editbox.setOption('lineWrapping', True)
      cm_editbox.setOption('readOnly', True)
  if ev.which == 39 and ctrl:
    if not cm_editbox.state.vim.insertMode:
      ev.preventDefault()
      ev.stopPropagation()
      if _options['_line_numbers']:
        cm_editbox.setOption('lineNumbers', True)
      cm_editbox.setOption('lineWrapping', False)
      cm_editbox.setOption('readOnly', False)
  if chr(ev.which)=='G' and ctrl:
    start = cm_editbox.getCursor(True).line
    end = cm_editbox.getCursor(False).line
    if start == end:
      print(cm_editbox.getCursor().line + 1)
    else:
      diff = abs(start-end)
      print('{}:{}({})'.format(start+1, end+1, diff+1))
    ev.preventDefault()
    ev.stopPropagation()
window.bind('keydown', on_down)

def do_py() -> None:
  try:
    def print(*objects, sep=' ', end='\n'):
      pstack.append(sep.join(str(o) for o in objects) + end)
    window.vdo("gv")
    data = cm_editbox.getSelection()
    exec(data)
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())

def run_py(cm, params):
  do_py()
window.CodeMirror.Vim.defineEx("do_py", None, run_py)

def run_file(cm, params):
  try:
    def print(*objects, sep=' ', end='\n'):
      pstack.append(sep.join(str(o) for o in objects) + end)
    exec(cm_editbox.getValue())
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())
window.CodeMirror.Vim.defineEx("run_file", None, run_file)

def do_tp() -> None:
  try:
    window.vdo("gvo")
    data = cm_editbox.getSelection()
    lpad = min(len(i) - len(i.lstrip()) for i in data.splitlines())
    out = align(s2m(data, ignorecomment=False), True)
    out = '\n'.join(f'{" "*lpad}{i}' for i in out.splitlines())
    cm_editbox.replaceSelection(out.strip('\n'))
  except Exception as e:
    import traceback
    window.make_popup(traceback.format_exc())

def run_tp(cm, params):
  do_tp()
window.CodeMirror.Vim.defineEx("do_tp", None, run_tp)

def runpy(cm, params):
  #g = globals()
  #g.update(_options)
  exec(params.argString, globals(), _options)

window.CodeMirror.Vim.defineEx("py", None, runpy)


def do_reg(_do = "sum(n)", _reg = '"') -> dict:
  args = _do.split(';')

  sel = window.CodeMirror.Vim.getRegisterController().getRegister(_reg).keyBuffer[0]

  l  = re.split(r'\s+', sel)
  li = re.split(r'\s*\n\s*', sel)
  n  = [float(i) for i in re.findall(r'[-+]?[0-9]*\.?[0-9]+', sel)]
  w  = re.findall(r'\w+', sel)

  outs = []
  for i in args:
    outs.append(eval(i))
  res = str(dict(zip(args, outs)))
  print(res)
  if len(outs) == 1:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [str(outs[0])]
  else:
    window.CodeMirror.Vim.getRegisterController().getRegister("z").keyBuffer = [res]
def runnums(cm, params):
  do_reg(params.argString)
window.CodeMirror.Vim.defineEx("nums", None, runnums)
#_options['nums'] = do_reg
_options['do_reg'] = do_reg

def compare(cm, params):
  new = window.CodeMirror.Vim.getRegisterController().getRegister('a').keyBuffer[0]
  old = window.CodeMirror.Vim.getRegisterController().getRegister('d').keyBuffer[0]
  window.make_popup(render_diff(old, new))
window.CodeMirror.Vim.defineEx("compare", None, compare)
window.CodeMirror.Vim.defineEx("diff", None, compare)

def groupby_text(predicate=''):
  predicate = predicate.strip()
  window.vdo('gv')
  dat = cm_editbox.getSelection().splitlines()
  #gb = groupby(dat, key=lambda i: predicate in i)
  gb = groupby(dat, key=partial(re.findall, predicate, flags=re.I))
  gb = '\n\n'.join('\n'.join(v) for k, v in gb)
  window.vdo('gv')
  cm_editbox.replaceSelection(gb)
def run_groupby_text(cm, params):
  try:
    groupby_text(params.argString)
  except Exception as e:
    window.make_popup(str(e))
window.CodeMirror.Vim.defineEx("gb", None, run_groupby_text)

def groupby_column(predicate=''):
  predicate = predicate.strip()
  window.vdo('gv')
  dat = cm_editbox.getSelection().splitlines()
  gb = groupby(dat, key=partial(re.findall, r'(?<=^([^\|]+\|){' + predicate + r'})[^\|]+', flags=re.I))
  gb = '\n\n'.join('\n'.join(v) for k, v in gb)
  window.vdo('gv')
  cm_editbox.replaceSelection(gb)
def run_groupby_column(cm, params):
  try:
    groupby_column(params.argString)
  except Exception as e:
    window.make_popup(str(e))
window.CodeMirror.Vim.defineEx("gbc", None, run_groupby_column)

def better_sort():
  #import re
  oldpos = cm_editbox.getCursor()
  if not cm_editbox.state.vim.visualLine:
    window.CodeMirror.Vim.exitInsertMode(cm_editbox)
    window.vdo('gv') # hack for vim visual stating on codemirror
  dat = cm_editbox.getSelection()

  # Genius snippet.
  def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else re.sub(r'\s\s+', ' ', text.strip().lower())
            for text in _nsre.split(s)]

  def if_comment(i):
    if i.lstrip().startswith('#'):
      return i
    if i.strip() == '':
      return ''
    return False

  def better_sort(s):
    gb = groupby(s.splitlines(), key=if_comment)
    gb = [list(v) for k, v in gb]
    #gb = '\n'.join('\n'.join(sorted(i, key=natural_sort_key)) for i in gb)
    gb = '\n'.join('\n'.join(window.natsort(i)) for i in gb)
    return(gb)

  cm_editbox.replaceSelection(better_sort(dat))
  window.eval("document.querySelector('.CodeMirror').CodeMirror.setCursor({'line':"+str(oldpos.line)+", 'ch':"+str(oldpos.ch)+"})")
  window.CodeMirror.Vim.handleKey(cm_editbox, '<Esc>', 'macro')
def run_better_sort(cm, params):
  try:
    better_sort()
  except Exception as e:
    window.make_popup(str(e))
window.CodeMirror.Vim.defineEx("better_sort", None, run_better_sort)


def run_align(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection()
  lpad = min(len(i) - len(i.lstrip()) for i in data.splitlines())
  out = align(s2m(data,  ignorecomment=False))
  out = '\n'.join(f'{" "*lpad}{i}' for i in out.splitlines())
  window.vdo('gv')
  cm_editbox.replaceSelection(out.strip('\n'))
window.CodeMirror.Vim.defineEx("align", None, run_align)

def run_stack(cm, params):
  window.vdo('gv')
  data = cm_editbox.getSelection()
  if data[0] == '{':
    out = sstack(eval(data))
  else:
    out = str(stack(data))
  window.vdo('gv')
  cm_editbox.replaceSelection(out.strip('\n'))
window.CodeMirror.Vim.defineEx("stack", None, run_stack)

def move(cm, params):
  window.vdo('gv')
  if not cm_editbox.state.vim.visualLine:
    window.vdo('V')
  window.vdo('d')
  where = params.argString.strip()
  cur_line = cm.getCursor().line
  if where[0] == '+':
    temp_int = int(where[1:]) - len(window.reg('"').splitlines())
    window.vdo(f'{temp_int}jp')
  elif where[0] == '-':
    window.vdo(f'{where[1:]}kp')
  else:
    temp_int = int(where) - len(window.reg('"').splitlines())
    if cur_line < int(where):
      window.vdo(f'{temp_int}Gp')
    else:
      window.vdo(f'{where}Gp')
window.CodeMirror.Vim.defineEx("move", None, move)

#--- async stuff


class Popup:
  lock = aio.Lock()

  def __init__(self, _root):
    self._root = _root
    self.frame = DIV(Class='darken', Id='popupbg', style={
      'background': 'rgba(0, 0, 0, 0)',
      'transition': 'background .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'width': '100%',
      'height': '100%',
      'position': 'fixed',
      'top': '0px',
      'left': '0px',
      'z-index': '1',
    })

    self.box = DIV(style={
      'position': 'fixed',
      'opacity': 0,
      'transition': 'opacity .3s, top .3s',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'border': 'none',
      'color': 'white',
      'outline': 'none',
      'z-index': '1',
      'max-height': '100%',
      'max-width': '100%',
    })

  async def __aenter__(self):
    await self.lock.acquire()
    self._root <= self.frame
    self._root <= self.box

    await aio.sleep(.05)
    self.frame.style['background'] = 'rgba(0, 0, 0, .5)'
    self.box.style['opacity'] = 1

    return self.box

  async def __aexit__(self, type, value, traceback):
    self.frame.style['background'] = 'rgba(0, 0, 0, 0)'
    self.box.style['opacity'] = 0
    await aio.sleep(.4)

    self.frame.remove()
    self.box.remove()
    self.lock.release()

async def popup(content):
  async with Popup(doc) as p:
    p <= content
    center(p)
    with UIEventStream([doc['popupbg'], 'click']) as stream:
      await _any(stream)


class Stagger:
  def __init__(self, base_delay, rate):
    self.delay = base_delay
    self.rate = rate

  async def delay_fun(self, fun, delay):
    await aio.sleep(delay)
    fun()

  def stagger(self, fun):
    aio.run(self.delay_fun(fun, self.delay))
    self.delay += self.rate

  def __enter__(self):
    return self.stagger

  def __exit__(self, *_):
    pass


def center(el):
  'bottom height left right top width'
  root = getdim(doc.querySelector('body'))
  eldim = getdim(el)
  el.left = int(root.center[0] - eldim.width//2)
  el.top = int(root.center[1] - eldim.height//2)



def hilo(a, b, c):
  if c < b: b, c = c, b
  if b < a: a, b = b, a
  if c < b: b, c = c, b
  return a + c

def complement(r, g, b, a):
  k = hilo(r, g, b)
  return (*tuple(k - u for u in (r, g, b)), a)

def tint(r, g, b, a, val):
  '''Tints rgb values to apply 'white' layer to materials'''

  rt = r + (val * (255 - r))
  gt = g + (val * (255 - g))
  bt = b + (val * (255 - b))
  return (rt, gt, bt, a)

def shade(r, g, b, a, val):
  rt = r - r*val
  gt = g - g*val
  bt = b - b*val
  return (rt, gt, bt, a)

def is_dark(color):
  # determine color too dark
  # HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
  r, g, b, _ = color
  hsp =  0.299 * r**2 + 0.587 * g**2 + 0.114 * b**2
  return 127.5 >= hsp**(1/2.0)

base_color = [18, 18, 18, 1]

def space(*l, **kw):
  return DIV(*l, style={'position': 'absolute', 'margin': '0px', 'padding': '0px',
      'display': 'flex',
      'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      'transition': 'all 0.3s',
      'box-sizing': 'border-box',}, **kw)


opacities = {0:  0, 1: .05, 2: .07, 3: .08, 4: .09, 6: .11, 8: .12, 12: .14, 16: .15, 24: .16}
shadows = {0: 'none',
            1: '0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)',
            2: '0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)',
            3: '0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)',
            4: '0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)',
            6: '0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)',
            8: '0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)',
            12: '0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)',
            16: '0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)',
            24: '0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)',}

'''
High-emphasis text has an opacity of 87%
Medium-emphasis text and hint text have opacities of 60%
Disabled text has an opacity of 38%
Default error helper text: This text uses a hex value of #B00020 at 100% opacity
'''

font_dark = (0, 0, 0)
font_light = (255, 255, 255)
font_error = (176, 0, 32, 1) #B00020

#material design specs
font_opacities = {'high': .87, 'medium': .6, 'disabled': .38}
def font_color(dark=True, emphasis='high'):
  if emphasis == 'error':
    return font_error
  if dark:
    return *font_light, font_opacities[emphasis]
  return *font_dark, font_opacities[emphasis]

def elevate(self, value, color=base_color, flat=False):
  # tint and shadows
  if not flat:
    if color == base_color:
      self.style['background'] = f'rgba{tint(*color, opacities[value])}'
    else:
      self.style['background'] = f'rgba{tint(*color, opacities[value]*2)}'
    #self.style['box-shadow'] = shadows[value]
  else:
    if is_dark(color):
      self.style['background'] = f'rgba(255, 255, 255, {opacities[value]})'
    else:
      self.style['background'] = f'rgba(0, 0, 0, {opacities[value]})'
    #self.style['box-shadow'] = shadows[0]

def flex(*l, base=DIV, color=base_color, padding='12px 18px', elevation=0, flow='row wrap', justify='flex-start', align_items='stretch', align_content='stretch', grow=1, flat=False, style={}, marked=False, emphasis='high', **kw):
  dark = is_dark(color)

  base_style = {
        # commented for flatter look
        'margin': '8px',
        'border-radius': '5px',

        'border': 'none',
        'font-size': '16px',
        'cursor': 'default',
        'color': f'rgba{font_color(dark, emphasis)}',
        'outline': 'none',
        'display': 'flex' if not marked else 'block',
        'transition-timing-function': 'cubic-bezier(0.4, 0.0, 0.2, 1)',
        'transition': 'all 0.3s',
        'box-sizing': 'border-box',
        'overflow': 'auto',
      }
  base_style.update(style)

  self = base(*l, style=base_style, **kw)

  # tint and shadows
  elevate(self, elevation, color, flat)
  #if not flat:
  #  self.style['background'] = f'rgba{tint(*color, opacities[elevation])}'
  #  self.style['box-shadow'] = shadows[elevation]
  #else:
  #  self.style['background'] = f'rgba(255, 255, 255, {opacities[elevation]})'

  self.style['padding'] = padding

  # row (default)   : left to right in ltr; right to left in rtl
  # row-reverse     : right to left in ltr; left to right in rtl
  # column          : same as row but top to bottom
  # column-reverse  : same as row-reverse but bottom to top
  # nowrap (default): all flex items will be on one line
  # wrap            : flex items will wrap onto multiple lines, from top to bottom.
  # wrap-reverse    : flex items will wrap onto multiple lines from bottom to top.
  self.style['flex-flow'] = flow

  # flex-start (default): items are packed toward the start of the flex-direction.
  # flex-end            : items are packed toward the end of the flex-direction.
  # start               : items are packed toward the start of the writing-mode direction.
  # end                 : items are packed toward the end of the writing-mode direction.
  # left                : items are packed toward left edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
  # right               : items are packed toward right edge of the container, unless that doesn't make sense with the flex-direction, then it behaves like start.
  # center              : items are centered along the line
  # space-between       : items are evenly distributed in the line; first item is on the start line, last item on the end line
  # space-around        : items are evenly distributed in the line with equal space around them. Note that visually the spaces aren't equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.
  # space-evenly        : items are distributed so that the spacing between any two items (and the space to the edges) is equal.
  self.style['justify-content'] = justify

  # stretch (default)              : stretch to fill the container (still respect min-width/max-width)
  # flex-start / start / self-start: items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the flex-direction rules or the writing-mode rules.
  # flex-end / end / self-end      : items are placed at the end of the cross axis. The difference again is subtle and is about respecting flex-direction rules vs. writing-mode rules.
  # center                         : items are centered in the cross-axis
  # baseline                       : items are aligned such as their baselines align
  self.style['align-items'] = align_items

  # flex-start / start: items packed to the start of the container. The (more supported) flex-start honors the flex-direction while start honors the writing-mode direction.
  # flex-end / end    : items packed to the end of the container. The (more support) flex-end honors the flex-direction while end honors the writing-mode direction.
  # center            : items centered in the container
  # space-between     : items evenly distributed; the first line is at the start of the container while the last one is at the end
  # space-around      : items evenly distributed with equal space around each line
  # space-evenly      : items are evenly distributed with equal space around them
  # stretch (default) : lines stretch to take up the remaining space
  self.style['align-content'] = align_content

  self.style['flex-grow'] = grow

  return self

def textbox(text='', placeholder='', name='', _list='', _type='', force_list=False, multiline=True, *l, **kw):
  if multiline:
    self = flex(text, *l, base=TEXTAREA, placeholder=placeholder, name=name, **kw)
  else:
    self = flex(*l, base=INPUT, placeholder=placeholder, name=name, **kw)
    self.value = text
    self.setAttribute('type', _type)
    self.setAttribute('list', _list)

  self.style['border-bottom'] = f'solid 2px rgba{tint(*(0, 0, 128, 1), opacities[6])}'

  base_elevation = kw.get('elevation', 0)
  color = kw.get('color', base_color)
  flat = kw.get('flat', False)

  self.bind('mouseenter', lambda ev: elevate(self, base_elevation + 2, color, flat))
  self.bind('mouseleave', lambda ev: elevate(self, base_elevation, color, flat))

  self.bind('focus', lambda ev: elevate(self, base_elevation + 2, color, flat))
  self.bind('blur', lambda ev: elevate(self, base_elevation, color, flat))

  if force_list:
    def erase(ev):
      if self.value:
        self.setAttribute('placeholder', self.value)
      self.value = ''
    def force(ev):
      dataset = doc.querySelector(f'#{_list}').possibilities
      if not self.value:
        if ph := self.getAttribute('placeholder') in dataset:
          self.value = ph
        else:
          self.value = dataset[0]
      else:
        for opt in dataset:
          if self.value.lower() in opt.lower():
            self.value = opt
            break
        else:
          self.value = dataset[0]
    self.bind('focus', erase)
    self.bind('click', erase)
    self.bind('blur', force)
    force(None)

  return self

class InputOptions(DATALIST):
  def __init__(self, possibilities, *l, **kw):
    self.possibilities = possibilities
    super().__init__(*l, **kw)
    self.update()

  def update(self):
    self.clear()
    for opt in self.possibilities:
      self <= OPTION(value=opt)

  def __repr__(self):
    return "{" + f"'possibilities': {repr(self.possibilities)}" + "}"

def edge(*l, flat=True, **kw):
  return flex(*l, **kw, flat=flat, padding='0px', style={'border-radius': '0px', 'margin': '0px'})

def card(*l, **kw):
  return flex(*l, **kw)

def label(*l, flow='column', justify='center', flat=True, **kw):
  return card(*l, flow=flow, justify=justify, flat=flat, **kw)


def button(*l, elevation=0, flat=False, raised=False, flow='column', justify='center', align_items='center', **kw):
  if raised:
    elevation = 2
  else:
    flat = True

  self = flex(*l,
       elevation=elevation,
       flat=flat,
       tabindex=0,
       justify=justify,
       flow=flow,
       align_items=align_items,
       **kw)

  base_elevation = elevation
  color = kw.get('color', base_color)
  flat = flat

  self.bind('mouseenter', lambda ev: elevate(self, base_elevation + 6, color, flat))
  self.bind('mouseleave', lambda ev: elevate(self, base_elevation, color, flat))

  self.bind('focus', lambda ev: elevate(self, base_elevation + 6, color, flat))
  self.bind('blur', lambda ev: elevate(self, base_elevation, color, flat))


  def on_enter(ev):
    if ev.type=='mouseup':
      elevate(self, base_elevation + 6, color, flat)
    elif ev.keyCode in (13, 32):
      ev.preventDefault()
      elevate(self, base_elevation + 6, color, flat)
      self.click()

  self.bind('keyup', on_enter)
  self.bind('mouseup', on_enter)

  def on_keydown(ev):
    if ev.type=='mousedown' or ev.keyCode in (13, 32):
      ev.preventDefault()
      elevate(self, base_elevation, color, flat)

  self.bind('keydown', on_keydown)
  self.bind('mousedown', on_keydown)

  return self

def fab(_icon, *l, **kw):
  return button(icon(_icon), elevation=6, raised=True, style={'padding': '18px', 'border-radius': '50%'})

def icon(_icon, *l, **kw):
  return I(_icon, *l, Class='material-icons', **kw)

class snack:
  lock = aio.Lock()

  def __init__(self, *l, delay=5, **kw):
    self.delay = delay
    self.el = label(*l, **kw, elevation=6, flat=False, style={'width': '100%',
                                  'border-radius': '0px',
                                  'position': 'fixed',
                                  'margin': '0px',
                                  'bottom': '-48px',
                                  'height': '48px',})
    doc <= self.el
    aio.run(self.show())

  async def show(self):
    await self.lock.acquire()
    await aio.sleep(.05)
    self.el.style['bottom'] = 0
    await aio.sleep(.3 + self.delay)
    await self.hide()

  async def hide(self):
    self.el.style['bottom'] = '-48px'
    await aio.sleep(.3)
    self.el.remove()
    self.lock.release()

  def __repr__(self):
    return "{" + f"'delay': {repr(self.delay)}" + "}"

def grid2tracks(cols=[], rows=[], width=0, height=0, offx=0, offy=0):
  _width = width
  _cols = [0]
  for c in cols:
    if c == ...:
      _cols.append(c)
    elif c < 1:
      _cols.append(_width - width + _width * c)
      width -= _width * c
    else:
      _cols.append(_width - width + c)
      width -= c

  _height = height
  _rows = [0]
  for c in rows:
    if c == ...:
      _rows.append(c)
    elif c < 1:
      _rows.append(_height - height + _height * c)
      height -= _height * c
    else:
      _rows.append(_height - height + c)
      height -= c

  if ... in _cols:
    idx = _cols.index(...)
    _cols[idx:idx+1] = [_cols[idx-1]]
    _cols[idx:] = [i+width for i in _cols[idx:]]
    width = 0

  if ... in _rows:
    idx = _rows.index(...)
    _rows[idx:idx+1] = [_rows[idx-1]]
    _rows[idx:] = [i+height for i in _rows[idx:]]
    height = 0

  _cols = [round(i+offx+width//2) for i in _cols]
  _rows = [round(i+offy+height//2) for i in _rows]

  return _cols, _rows

def gmap(c, r, obj, x=0, y=0, ex=None, ey=None):
  if ex is None:
    ex = x
  if ey is None:
    ey = y

  obj.left, obj.top = c[:-1][x], r[:-1][y]
  obj.width, obj.height = c[1:][ex] - obj.left, r[1:][ey] - obj.top

class UIEventStream:
  def __init__(self, *selects, join=None):
    # select = [obj, *events]
    if join:
      self.out
    else:
      self.out = []
    self.selects = selects
    self.binds = []

  def __enter__(self):
    for o, *evs in self.selects:
      for ev in evs:
        on_event = self._on_event(o, ev, self.out)
        o.bind(ev, on_event)
        self.binds.append((o, ev, on_event))
    return self.out

  def __exit__(self, *l):
    for o, ev, fun in self.binds:
      o.unbind(ev, fun)

  @staticmethod
  def _on_event(o, ev, out):
    def on_event(*l, **kw):
      l[0].preventDefault()
      l[0].stopPropagation()
      out.append((o, ev, (l, kw)))
    return on_event

class EventStream:
  def __init__(self, *selects, join=None):
    # select = [obj, *events]
    if join:
      self.out
    else:
      self.out = []
    self.selects = selects
    self.binds = []

  def __enter__(self):
    for o, *evs in self.selects:
      for ev in evs:
        on_event = self._on_event(o, ev, self.out)
        o.bind(**{ev: on_event})
        self.binds.append((o, ev, on_event))
    return self.out

  def __exit__(self, *l):
    for o, ev, fun in self.binds:
      o.unbind(**{ev: fun})

  @staticmethod
  def _on_event(o, ev, out):
    def on_event(*l, **kw):
      out.append((o, ev, (l, kw)))
    return on_event

async def _any(_iterable):
  'Await for any(_iterable) to be true'

  while not any(_iterable):
    await aio.sleep(0)
  return _iterable



def try_cast(s):
  try:
    return eval(s)
  except:
    return s

def stack(s):
  out = {}
  last_depth = -1
  stack = [out]

  for l in s.strip('\n').splitlines():
    if not l.strip() or l.lstrip().startswith('#'):
      continue

    depth = (len(l) - len(l.lstrip())) // 2

    left = l.partition(':')[0].strip()
    right = l.partition(':')[2].strip()

    if depth < last_depth:
      if depth:
        stack = stack[:depth+1]
      else:
        stack = [stack[0]]
      last_depth = depth


    if depth > last_depth:
      if right == '[':
        stack[-1][left] = []
        stack.append(stack[-1][left])
      elif isinstance(stack[-1], list):
        if l.strip() != ']':
          stack[-1].append(try_cast(l.strip()))
      elif right:
        stack[-1][left] = try_cast(right)
      else:
        stack[-1][left] = {}

        stack.append(stack[-1][left])
      last_depth = depth

    else:
      if right == '[':
        stack[-1][left] = []
        stack.append(stack[-1][left])
      elif isinstance(stack[-1], list):
        if l.strip() != ']':
          stack[-1].append(try_cast(l.strip()))
      elif right:
        stack[-1][left] = try_cast(right)
      else:
        stack[-1][left] = {}

        stack.append(stack[-1][left])

  return out

def _stack(d, out=[], depth=0):
  for k, v in d.items():
    if isinstance(v, dict):
      out.append(' '*depth + f'{k}:')
      _stack(v, out, depth+2)
    elif isinstance(v, list):
      out.append(' '*depth + f'{k}: [')
      for i in v:
        out.append(' '*(depth+2) + f'{i!r}')
      out.append(' '*(depth+2) + ']')
    else:
      out.append(' '*depth + f'{k}: {v!r}')

def sstack(d, depth=0):
  out = []
  if isinstance(d, list):
    d = dict(enumerate(d))
  _stack(d, out, depth)
  return '\n'.join(out)

def fill(s, default=''):
  if isinstance(s, dict):
    keys = {k for i in s.values() for k in i.keys()}
    #out = [keys] + [[i.get(k, '') for k in keys] for i in s.values()]
    for i in s.values():
      for k in keys:
        if k not in i:
          i[k] = default
  else:
    keys = {k for i in s for k in i.keys()}
    for i in s:
      for k in keys:
        if k not in i:
          i[k] = default
  return s

save_me = []
loaded = False
_options['save_me'] = save_me

def save_on_blur(*l, **kw):
  if loaded:
    save_me.append(True)

window.onblur = save_on_blur

async def auto_saver():
  global loaded
  await popup('Click to load')
  async with fopen() as f:
    cm_editbox.setValue(f.text)
    loaded = True
    while True:
      await _any(save_me)
      cm_editbox.save()
      await f.write(re.sub(r' +$', '', editbox.value, flags=re.M))
      save_me.clear()
      print('Saved')

pstack = []
async def printer():
  while True:
    if pstack:
      if _options['printer'] == 'quick':
        cm_editbox.openNotification('<pre>' + ''.join(pstack).replace('<', '&lt;').replace('>', '&gt;').strip('\n').replace('\n', '<br>') + '</pre>')
      else:
        window.make_popup(''.join(pstack).strip('\n'))
      pstack.clear()
    await aio.sleep(1)

async def main():
  res = await aio.gather(auto_saver(), printer())
  window.alert(str(res))

aio.run(main())


</script>
<script>
  var _logger = function(msg){
    if(msg != "using indexedDB for stdlib modules cache" && msg != 'empty stack'){
      cm_editbox.openNotification('<pre>'+msg+'</pre>')
      }
      //cm_editbox.openNotification('<p>'+msg.split('\n').join('<br>')+'</p>')
      }

      console.log=_logger
      console.error=make_popup
      console.warning=make_popup
      </script>
</html>
