<html>
<title>Launcher</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="rabbit.png"><style>

body { background: rgba(18, 18, 18, 1); color: rgba(255,255,255,.87);}

@font-face {
  font-family: Mono;
  src: url("lib/RobotoMono-Light.ttf") format("truetype");
}

@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url("lib/MaterialIcons-Regular.ttf") format('truetype')
}

.material-icons {
  font-family: 'Material Icons' !important;
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}

* {
  font-family: Mono;
  font-size: 16px;
}

pre, code, pre > * {
  font-family: Mono;
}

.shadow_0 {
  box-shadow: none
}
.shadow_1{
  box-shadow: 0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)
}
.shadow_2{
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)
}
.shadow_3{
  box-shadow: 0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)
}
.shadow_4{
  box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)
}
.shadow_6{
  box-shadow: 0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)
}
.shadow_8{
  box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)
}
.shadow_12{
  box-shadow: 0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)
}
.shadow_16{
  box-shadow: 0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)
}
.shadow_24{
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)
}

dialog {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 0px;
  box-shadow: 0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20);
  box-sizing: border-box;
}
.card {
  background-color: rgba(18,18,18,1);
  color: rgba(255,255,255,.87);
  border: none;
  padding: 12px 16px;
  box-sizing: border-box;
}

button, textarea, input{
  background: none;
  color: rgba(255,255,255,.87);
  border: none;
  border-bottom: 2px solid #00ccff;
  outline: none;
  box-sizing: border-box;
}

.glow_crimson, .tile_crimson:hover, .tile_crimson:focus{
  box-shadow: 0 4px 5px 0 rgba(220, 20, 60, 0.14), 0 1px 10px 0 rgba(220, 20, 60, 0.12), 0 2px 4px -1px rgba(220, 20, 60, 0.20);
  background: rgb(220, 20, 60) !important;
}

.glow_emerald, .tile_emerald:hover, .tile_emerald:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 89, 11, 0.14), 0 1px 10px 0 rgba(0, 89, 11, 0.12), 0 2px 4px -1px rgba(0, 89, 11, 0.20);
  background: rgb(0, 89, 11) !important;
}

.glow_cobalt, .tile_cobalt:hover, .tile_cobalt:focus{
  box-shadow: 0 4px 5px 0 rgba(0, 71, 171, 0.14), 0 1px 10px 0 rgba(0, 71, 171, 0.12), 0 2px 4px -1px rgba(0, 71, 171, 0.20);
  background: rgb(0, 71, 171) !important;
}

.glow_gold, .tile_gold:hover, .tile_gold:focus{
  box-shadow: 0 4px 5px 0 rgba(255, 215, 0, 0.14), 0 1px 10px 0 rgba(255, 215, 0, 0.12), 0 2px 4px -1px rgba(255, 215, 0, 0.20);
  background: rgb(255, 215, 0) !important;
}

.show_over {
  opacity: 0;
}
div:hover > .hide_over,
div:focus > .hide_over {
  opacity: 0;
}
div:hover > .show_over,
div:focus > .show_over {
  opacity: 1;
}

.animate { 
  transition-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
  transition: all 0.3s;
}

.warn{
  border-bottom: 2px solid #B00020;
}

::placeholder {
  color: rgba(255,255,255,.6);
}

</style>
<body onload="brython({indexedDB: false})"></body>
<script src="lib/brython.js"></script>
<script type="text/python">
from browser import window
from browser import document as doc
#from browser import aio as asyncio
from browser.html import *

import math
import random

def partial(func, *args, **keywords):
  def newfunc(*fargs, **fkeywords):
    newkeywords = {**keywords, **fkeywords}
    return func(*args, *fargs, **newkeywords)
  newfunc.func = func
  newfunc.args = args
  newfunc.keywords = keywords
  return newfunc
  
def box(*l, base=DIV, **kw):
  sty = kw.get('style', {})
  sty['box-sizing'] = 'border-box'
  sty['display'] = 'inline'
  sty['position'] = 'absolute'
  kw['style'] = sty
  return base(*l, **kw)
  
def icon(_icon, *l, **kw):
  return I(_icon, *l, Class='material-icons', **kw)

def popup(root, width='auto', height='auto'):
  if isinstance(root, (tuple, list, str, int, float, dict, set)):
    root = DIV(root)
  d = DIALOG(root)
  root.style['width'] = width
  root.style['height'] = height
      
  @bind('close', d)
  def _(ev):
    d.remove()

  doc <= d
  
  d.showModal()
  
  return d
  
class Popup:
  def __init__(self, *l, **kw):
    self.d = popup(*l, **kw)
    
  def __enter__(self):
    return self
    
  def __exit__(self, *l):
    self.d.close()
  
def attr_map(i, **kw):
  for k, v in kw.items():
    setattr(i, k, v)

def recycle(items, data, how=attr_map):
  buff = max(len(items) - len(data), 0)
  for i, d in zip(items, data + [{}]*buff):
    if isinstance(d, dict):
      how(i, **d)
    else:
      how(i, **{k: getattr(d, k) for k in d.__slots__})

def tile(text='', _icon='', title='', background='', 
    font_size='24px', icon_size='64px', align='center', base=DIV, **kw):
  sty = kw.get('style', {})
  sty['overflow'] = 'hidden'
  kw['style'] = sty
  
  cla = kw.get('Class', '').split(' ')
  cla += ['animate']
  kw['Class'] = ' '.join(cla)
  
  out = []
  out.append(DIV(style={
      'width': '100%',
      'height': '100%',
      'background': f'url({background})' or 'none',
      'background-size': 'cover',
      'background-position': 'center',
      #'z-index': '-1',
      'position': 'absolute',
      'left': 0,
      'top': 0,
      }))
      
  out.append(icon(_icon or '', 
    style={
      'position': 'absolute',
      'left': '50%',
      'top': '50%',
      'transform': 'translate(-50%, -50%)',
      'font-size': icon_size}))
      
  out.append(DIV(text or '', 
    style={
      'position': 'absolute',
      'left': '50%' if align=='center' else '0px',
      'top': '50%',
      'transform': 'translate(-50%, -50%)' if align=='center' else 'translate(0%, -50%)',
      'font-size': font_size,
      'text-align': align}))

  if text and _icon:
    out[-1].attrs['class'] = 'show_over animate'
    out[-2].attrs['class'] = 'hide_over material-icons animate'
  else:
    out[-1].attrs['class'] = 'animate'
    out[-2].attrs['class'] = 'material-icons animate'
    
  out.append(DIV(f'{title}' or '', 
    style={
      'position': 'absolute',
      'left': 0,
      'bottom': 0,
      'display': 'initial' if title else 'none',
      'background': 'rgba(0,0,0,.5)',
      'padding': '8px'}))
      
  return box(out, base=base, **kw)

def update_tile(instance, text='', _icon='', title='', background='', **kw):
  ui_background, ui_icon, ui_text, ui_title = instance.children
  
  ui_background.style['background-image'] = f'url({background})' if background else 'none'
  ui_icon.text = _icon or ''
  ui_text.text = text or ''
  
  if text and _icon:
    ui_text.attrs['class'] = 'show_over animate'
    ui_icon.attrs['class'] = 'hide_over material-icons animate'
  else:
    ui_text.attrs['class'] = 'animate'
    ui_icon.attrs['class'] = 'material-icons animate'
  
  ui_title.text = title or ''
  ui_title.style['display'] = 'initial' if title else 'none'
  
  if not any([text, _icon, title, title, background]):
    instance.style['display'] = 'none'
  else:
    instance.style['display'] = 'initial'
  
def tracks_to_coords(tracks, x=0, y=0, ex=None, ey=None, padding=0):
  # uses a tracks layout to return x,y/w,h values
  columns, rows = tracks
  if ex is None: ex = x
  if ey is None: ey = y

  return (columns[x][0] + padding, rows[y][0] + padding,
    columns[ex][1] - columns[x][0] - padding*2,
    rows[ey][1] - rows[y][0] - padding*2)
    
coords_map = 'left', 'top', 'width', 'height'
def gmap(instance, *l, **kw):
  for k, v in zip(coords_map, tracks_to_coords(*l, **kw)):
    instance.style[k] = v

def axis_to_tracks(axis, viewport):
  # Used to generate a non-uniform grid.
  axis = [[v*b if isinstance(b, float) else b for b in a] 
    for v, a in zip(viewport, axis)]

  for v, a in zip(viewport, axis):
    if (count:=len([i for i in a if i is ...])):
      fill = (v - sum(i for i in a if i is not ...))/count
      while ... in a:
        a[a.index(...)] = fill

  axis = [[round(sum(a[:i])) for i in range(len(a)+1)] for a in axis]
  axis = [[(a[i], a[i+1]) for i in range(len(a)-1)] for a in axis]
  
  return axis

def slot(name, *components, verbose=False):
  'Slot class generator. Similar to named tuple, but mutable.'
  if isinstance(components[0], str):
    components = [*components]
    slots = components.pop(0)
    defaults = components
    args = tuple(slots.split(' '))
    largs = ', '.join(args[:-len(defaults)] if defaults else args)
  else:
    base = {}
    for c in components:
      base.update(c)

    args = tuple(base.keys())
    defaults = tuple(base.values())
    largs = ', '.join(args[:-len(defaults)] if defaults else args)

  # Gather list of collections
  collections = {k: repr(v) for k, v in zip(args[-len(defaults):], defaults)
      if type(v) in (list, tuple, dict, set)}

  # Set default signature.
  kwargs = ', '.join(f'{k}={repr(None if k in collections else v)}' for k, v in zip(args[-len(defaults):], defaults))
  all_args = ', '.join(i for i in [largs, kwargs] if i)

  # Self setters.
  sargs = '\n    '.join(f'self.{k} = {v}' for k, v in zip(args, (f'{collections[i]} if {i} is None else {i}' if i in collections else i for i in args)))


  slot_template = f'''
class {name}:
  __slots__ = {repr(args)}
  def __init__(self,
      {all_args}):
    {sargs}
    
  def __repr__(self):
    return f'{{self.__class__.__name__}}({{", ".join(f"{{k}}={{getattr(self, k)!r}}" for k in self.__slots__)}})'
'''.strip()
  # Verbosity to print out generated code.
  if verbose:
    return slot_template

  local = {}
  exec(slot_template, local)
  return local[name]

class Observable:
  def __init__(self, *events):
    self.callbacks = {i:[] for i in events}

  def on(self, *event):
    def _on(f):
      for _event in event:
        self.callbacks[_event].append(f)
      return f
    return _on

  def bind(self, **kw):
    for k, v in kw.items():
      self.callbacks[k].append(v)

  def unbind(self, **kw):
    for k, v in kw.items():
      self.callbacks[k].remove(v)

  def emit(self, *event, **kw):
    for _event in event:
      for e in self.callbacks[_event]:
        e(_event, **kw)

class Task:
  def __init__(self):
    pass

  def build(self):
    pass

  def resize(self):
    pass
  
  def close(self):
    pass

  def focus(self):
    pass

  def blur(self):
    pass

def delay(d):
  def _delay(f):
    return Delay(d, f)
  return _delay

def stagger(l, d):
  d = d/len(l)
  def _stagger(f):
    for idx, i in enumerate(l, 1):
      if isinstance(i, (tuple, list)):
        Delay(idx*d, f, *i)
      elif isinstance(i, (dict)):
        Delay(idx*d, f, **i)
      else:
        Delay(idx*d, f, i)
  return _stagger

class Delay(Observable):
  def __init__(self, d, fun, *l, **kw):
    self.d = d*1000
    self.fun = fun
    self.l = l
    self.kw = kw
    self.start = window.Date.now()
    self.running = True
    self.timer = window.setTimeout(self.tick, self.d)

    Observable.__init__(self, 'tick', 'end', 'cancel')

  def tick(self):
    self.emit('tick')
    if self.fun(*self.l, **self.kw) is True and self.d:
      self.timer = window.setTimeout(self.tick, (self.start - window.Date.now())%self.d)
    else:
      self.running = False
      self.emit('end')

  def cancel(self):
    window.clearTimeout(self.timer)
    self.running = False
    self.emit('cancel')

class Loop(Observable):
  def __init__(self, d, fun):
    self.d = d*1000
    self.fun = fun
    self.start = window.Date.now()
    self.running = True
    self.last = self.start
    self.timer = window.setTimeout(self.tick, self.d)

    Observable.__init__(self, 'tick', 'end', 'cancel')

  def tick(self):
    dt = window.Date.now() - self.last
    self.last += dt
    self.emit('tick')
    if self.fun(dt) is not False and self.d:
      self.timer = window.setTimeout(self.tick, (self.start - window.Date.now())%self.d)
    else:
      self.running = False
      self.emit('end')

  def cancel(self):
    window.clearTimeout(self.timer)
    self.running = False
    self.emit('cancel')

def debounce(d):
  _delay = None
  def _debounce(f):
    def __debounce(*l, **kw):
      nonlocal _delay
      if _delay:
        _delay.cancel()
      _delay = Delay(d, f, *l, **kw)
    return __debounce
  return _debounce

def throttle(d):
  _delay, last, _l, _kw = None, -1, [], {}
  def _throttle(f):
    def do():
      nonlocal last
      last = window.Date.now()
      f(*_l, **_kw)
    def __throttle(*l, **kw):
      nonlocal _delay, last, _l, _kw
      if _delay and _delay.running:
        _l, _kw = l, kw
      elif ~last and window.Date.now() - last < d*1000:
        _l, _kw = l, kw
        _delay = Delay(d - (window.Date.now() - last)/1000, do)
      else: 
        last = window.Date.now()
        f(*l, **kw)
    return __throttle
  return _throttle

def bind(events, *element):
  def _bind(f):
    for e in events.split(' '):
      for _e in element:
        _e.bind(e, f)
    return f
  return _bind
  
def bind_once(events, *element):
  def _bind(f):
    def _unbind(*l, **kw):
      for e in events.split(' '):
        for _e in element:
          _e.unbind(e, _unbind)
      return f(*l, **kw)
        
    for e in events.split(' '):
      for _e in element:
        _e.bind(e, _unbind)
    return f
    
  return _bind


# end of import ish stuff
# -----------------------

task_stack = []

class Launcher(Task, Observable):
  def __init__(self):
    self.visible = False

    self.launch_tile = partial(tile, style={'background': 'rgba(40, 40, 40, 1)'}, Class='tile_cobalt')
    
    self.viewport = []
    self.cell_size = []
    self.grid_size = []
    self.offset = []
    self.tracks = []

    self.tiles = []
    self.root = []
    self.scroll = 0

    self.items = [
      {'title': 'Match game', '_icon': 'view_module', 'launch': Match_game},
      ]

    Observable.__init__(self, 'resize')

  def build(self):
    self.viewport = doc.select_one('body').width, \
      doc.select_one('body').height

    self.cell_size = [min(self.viewport)//3 - 32]*2
    self.grid_size = [a//b for a, b in zip(self.viewport, self.cell_size)]
    self.offset = [(a-b*c)/2 for a, b, c in zip(self.viewport, self.cell_size, self.grid_size)]

    self.tracks = [[(round(a+b*i), round(a+b+b*i)) for i in range(c)]  # (coord, length) pairs
      for a, b, c in zip(self.offset, self.cell_size, self.grid_size)]

    for el in self.root:
      el.remove()

    self.tiles = [self.launch_tile() for i in range(self.grid_size[0]*self.grid_size[1])]

    @bind_once('click', *self.tiles)
    def on_click(event):
      idx = self.tiles.index(event.currentTarget)
      tar = self.items[min(self.grid_size)*self.scroll:][idx]
      new_task = tar['launch']()
      task_stack[0:0] = [new_task]
      new_task.focus()
      self.blur()

    self.root = [*self.tiles]

    recycle(self.tiles, self.items[min(self.grid_size)*self.scroll:], update_tile)

    for idx, i in enumerate(self.root):
      gmap(i, self.tracks, idx//self.grid_size[1], idx%self.grid_size[1], padding=8)
      if not self.visible:
        i.style.opacity = 0

    doc <= self.root

  def blur(self):
    self.visible = False

    for i in self.root:
      i.style.opacity = 0

    @delay(.3)
    def _blur():
      for el in self.root:
        el.remove()

  def focus(self):
    self.build()
    self.visible = True

    @delay(0)
    def anim_in():
      for idx, i in enumerate(self.root):
        i.style.opacity = 1
  
  def resize(self):
    if self.visible:
      self.build()

      
class Match_game(Task, Observable):
  def __init__(self):
    self.visible = False

    self.game_tile = partial(tile, style={'background': 'rgba(40, 40, 40, 1)'}, Class='tile_cobalt')

    self.Tile = slot('Tile', 'value hidden matched', '', True, False)
    
    items = ['Apple', 'Banana', 'Cat', 'Dog', 'Echo', 'Fly', 'Taco', 'Run']*2
    self.tiles = [self.Tile(i) for i in items]
    random.shuffle(self.tiles)
    
    self.viewport = []
    self.cell_size = []
    self.grid_size = []
    self.offset = []
    self.tracks = []

    #self.tiles = []
    self.root = []
    self.scroll = 0
    
  def update_game_tile(self, instance, value='', hidden=True, matched=False):
    ui_background, ui_icon, ui_text, ui_title = instance.children
    ui_text.style['opacity'] = 0 if hidden else 1

    if matched:
      update_tile(instance)
    else:
      update_tile(instance, text=value)

  def check_selection(self, s1, s2):
    if s1.value == s2.value:
      s1.matched = True
      s2.matched = True
    else:
      s1.hidden = True
      s2.hidden = True

  def build(self):
    self.viewport = doc.select_one('body').width, \
      doc.select_one('body').height

    self.cell_size = [min(self.viewport)//4]*2
    self.grid_size = 4, 4
    self.offset = [(a-b*c)/2 for a, b, c in zip(self.viewport, self.cell_size, self.grid_size)]

    self.tracks = [[(round(a+b*i), round(a+b+b*i)) for i in range(c)]  # (coord, length) pairs
      for a, b, c in zip(self.offset, self.cell_size, self.grid_size)]
  
    for el in self.root:
      el.remove()

    self.ui_tiles = [self.game_tile() for i in range(self.grid_size[0]*self.grid_size[1])]

    @bind('click', *self.ui_tiles)
    def _(ev):
      idx = self.ui_tiles.index(ev.currentTarget)

      if not self.tiles[idx].matched and self.tiles[idx].hidden:
        self.tiles[idx].hidden = False

        recycle(self.ui_tiles, self.tiles, self.update_game_tile)

        selected = [i for i in self.tiles if not i.hidden and not i.matched]
        if len(selected) > 1:
          self.check_selection(*selected)

          @delay(1)
          def _():
            recycle(self.ui_tiles, self.tiles, self.update_game_tile)

    self.close_button = tile('close', 'close',
        style={
          'left': 0,
          'top': 0,
          'background': 'rgba(40, 40, 40, 1)',
          'width': self.cell_size[0]//1.5,
          'height': self.cell_size[0]//1.5,
          'opacity': 1 if self.visible else 0},
        Class='tile_crimson')

    bind_once('click', self.close_button)(self.close)

    self.root = [self.close_button, *self.ui_tiles]

    recycle(self.ui_tiles, self.tiles, self.update_game_tile)

    for idx, i in enumerate(self.ui_tiles):
      gmap(i, self.tracks, idx//self.grid_size[1], idx%self.grid_size[1], padding=8)
      if not self.visible:
        i.style.opacity = 0
        i.children[2].style.opacity = 1

    @delay(len(self.tiles)/4)
    def _():
      @stagger([*zip(self.ui_tiles, self.tiles)], .3)
      def __(ui, data):
        if data.hidden:
          ui.children[2].style.opacity = 0

    doc <= self.root

  def blur(self):
    self.visible = False

    @stagger(self.root, .3)
    def anim_in(i):
      i.style.opacity = 0

    @delay(.6)
    def _blur():
      for el in self.root:
        el.remove()

  def focus(self):
    self.build()
    self.visible = True

    @stagger(self.root, .3)
    def anim_in(i):
      i.style.opacity = 1
  
  def resize(self):
    if self.visible:
      self.build()

  def close(self, *l, **kw):
    task_stack.remove(self)
    launcher.focus()
    self.blur()



launcher = Launcher()

launcher.focus()

@debounce(.01)
def on_resize(*l, **kw):
  if task_stack:
    task_stack[0].resize()
  launcher.resize()

window.onresize = on_resize

#asyncio.run(main())
#next(l)

</script>
<script>
var _logger = function(msg){
  if(msg != "using indexedDB for stdlib modules cache"){
    alert(msg)
  }
}

console.log=_logger
console.error=_logger
console.warning=_logger
</script>
</html>
